{"rule_id": 291, "name": "unit42-new-malware-with-ties-to-sunorcal-discovered", "description": "-", "references": [], "File_Names": ["winhelp.dat", "ole32.dll", "sctr.dll", "uc.dat", "winhelp.cpl", "Update.lnk", "help.lnk", "FJIOW.tmp", "Applet.cpl", "WUpdate.lnk", "CMD.EXE", "tashdqdxp.co", "Shlwapi.dll", "control.exe"], "MD5_Hashes": [], "SHA1_Hashes": [], "SHA256_Hashes": ["799139b5278dc2ac24279cc6c3db44f4ef0ea78ee7b721b0ace38fd8018c51ac", "18ac3b14300ecfeed4b64a844c16dccb06b0e3513d0954d6c6182f2ea14e4c92", "9213f70bce491991c4cbbbd7dc3e67d3a3d535b965d7064973b35c50f265e59b", "c906250e0a4c457663e37119ebe1efa1e4b97eef1d975f383ac3243f9f09908c", "1fcda755e8fa23d27329e4bc0443a82e1c1e9a6c1691639db256a187365e4db1", "cb7c0cf1750baaa11783e93369230ee666b9f3da7298e4d1bb9a07af6a439f2f", "26c234c73e2c3448589c7d4a0cf17f615ad3666541a4e611e2d8b77637205bcf", "d560f44188fb56d3abb11d9508e1167329470de19b811163eb1167534722e666", "c0f8bb77284b96e07cab1c3fab8800b1bbd030720c74628c4ee5666694ef903d", "ae9f158e4886cfdbfb4f1b3b25707d05f6fd873d0be9d8e7334a2c28741228ee", "38ea33dab0ba2edd16ecd98cba161c550d1036b253c8666c4110d198948329fb", "81d887fefdbb0219647991c2b7bddf45c2fede4dc6fc18408f1706e0279615b2", "98eb5465c6330b9b49df2e7c9ad0b1164aa5b35423d9e80495a178eb510cdc1c", "58312fb742ce881e040e1b5b8555f00a402b8dd4fc886acaae2f862040b3bfc5", "05ddbd0506ec95fb460b3994e5b21cdb0418ba4aa406374ca1b91249349b7640"], "Registry_Entries": ["HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders\\Common\nStartup\n\nAlternatively, if the privilege was unable to be obtained, Reaver.v2 will obtain the user\u2019s\nstartup folder by querying the following registry key:\n\nHKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders\\Startup\n\nReaver proceeds to write a shortcut \ufb01le to \u2018%TEMP%\\~WUpdate.lnk\u2019. This \ufb01le is then copied\u0000\u0000\nto a \ufb01lename of \u2018Windows Update.lnk\u2019, which is placed in the startup path previously\u0000\nidenti\ufb01ed. This shortcut \ufb01le points to the path of the previously written \u2018Applet.cpl\u2019 \ufb01le. Finally,\u0000\u0000\u0000\nReaver.v1 will execute the \u2018~WUpdate.lnk\u2019 \ufb01le in a new process, thus loading the recently\u0000\ndropped malicious CPL \ufb01le.\u0000\n\nReaver.v2\n\nReaver.v2 begins by attempting to enable the SeDebugPrivilege privilege for the running\nprocess. In the event this is successful, the malware will use the following path to store any\ndropped \ufb01les:\u0000\n\n%COMMONPROGRAMFILES%\\services\\\n\nIn the event it is not successful, this alternative path will be used instead:\n\n%APPDATA%\\microsoft\\mmc\\\n\nReaver.v2 proceeds to decrypt an embedded \ufb01le using a simple XOR obfuscation routine.\u0000\nThis \ufb01le is written to the following \ufb01le path:\u0000\u0000\n\n% TEMP%\\Update.~tmp\n\nAfter the \ufb01le is written, it is then copied to a \ufb01lename of \u2019winhelp.cpl\u2019 in the directory that was\u0000\u0000\ninitially chosen. After this \ufb01le is copied, the original \u2018Update.~tmp\u2019 \ufb01le is deleted. At this stage\u0000\u0000\nthe malware will identify the correct startup path using the same technique witnessed in\nearlier variants.\n\nA shortcut \ufb01le is generated in the following path:\u0000\n\n%TEMP%\\~Update.lnk\n\nThis \u2018~Update.lnk\u2019 \ufb01le is then copied to a \ufb01lename of \u2018Windows help.lnk\u2019, which is placed in\u0000\u0000\nthe startup path previously identi\ufb01ed. This shortcut \ufb01le points to the path of the previously\u0000\u0000\nwritten \u2018winhelp.cpl\u2019 \ufb01le. It will speci\ufb01cally load this CPL \ufb01le via a call to the built-in Microsoft\u0000\u0000\u0000\nWindows \u2018control.exe\u2019 utility. Finally, Reaver.v2 will execute the \u2018~Update.lnk\u2019 \ufb01le in a new\u0000\nprocess, thus loading the recently dropped malicious CPL \ufb01le.\u0000\n\nReaver.v3\n\nLike Reaver.v2, Reaver.v3 begins by attempting to enable the SeDebugPrivilege privilege for\nthe running process. In the event this is successful, the malware will use the following path to\nstore any dropped \ufb01les:\u0000\n\n%COMMONPROGRAMFILES%\\services\\\n\nIn the event it is not successful, this alternative path will be used instead:\n\n \n\f%APPDATA%\\microsoft\\credentials\\\n\nReaver.v3 proceeds to write an embedded Microsoft Cabinet (CAB) \ufb01le to the following\u0000\nlocation:\n\n%TEMP%\\winhelp.dat\n\nThis cabinet \ufb01le is then extracted to the previously identi\ufb01ed \ufb01le path. The contents of this\u0000\u0000\u0000\ncabinet \ufb01le consist of a Microsoft Control Panel item with a \ufb01lename of \u2018winhelp.cpl\u2019.\u0000\u0000\n\nMuch like the previous version of Reaver, Reaver.v3 will query the necessary registry keys to\ndetermine the correct startup path to use. Again, a shortcut \ufb01le is written to the %TEMP%\u0000\npath with a name of \u2018~Update.lnk\u2019, which is in turn copied to the identi\ufb01ed startup path with a\u0000\n\ufb01lename of \u2018Windows help.lnk\u2019. This shortcut \ufb01le calls the built-in \u2018control.exe\u2019 utility to in turn\u0000\u0000\nload the previously dropped malicious CPL \ufb01le of \u2018winhelp.cpl\u2019.\u0000\n\nFinally, the malware calls the \u2018winhelp.cpl\u2019 \ufb01le in a new process via the following command:\u0000\n\ncontrol [path_previously_identi\ufb01ed]\\winhelp.cpl\u0000\n\nReaver HTTP Payload\n\nThe malicious CPL payload of Reaver has the following two exported functions:\n\nCPlApplet\nDllEntryPoint\n\nWhen the CPlApplet function is loaded, Reaver will initially determine if the SeDebugPrivilege\nprivilege is able to be obtained. The malware proceeds to decrypt and embedded\ncon\ufb01guration of 128 bytes using a simple XOR routine. The following example decrypted\u0000\ncon\ufb01guration is as follows:\u0000\n\n1 00000000: 77 77 77 2E 74 61 73 68  64 71 64 78 70 2E 63 6F  www.tashdqdxp.co\n00000010: 6D 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  m...............\n00000020: 38 30 00 00 00 00 00 00  00 00 00 00 00 00 00 00  80..............\n00000030: 33 30 00 00 00 00 00 00  00 00 00 00 00 00 00 00  30..............\n00000040: 57 69 6E 64 6F 77 73 20  55 70 64 61 74 65 00 00  Windows Update..\n00000050: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................\n00000060: 41 70 70 6C 65 74 00 00  00 00 00 00 00 00 00 00  Applet..........\n00000070: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................\n\n\f2\n\n\f3\n\n\f4\n\n\f5\n\n\f6\n\n7\n\n\f8\n\n\fAs we can see, the following information is present within this con\ufb01guration:\u0000\n\nRemote Command and Control (C2) server\nRemote port\nSleep timer\n\nReaver continues to collect various information from the victim machine, including the\nfollowing:\n\nCPU speed\nComputer name\nUsername\nIP Address\nMicrosoft Windows version\n\n\fPhysical and virtual memory information\n\nThe malware proceeds to communicate with the remote server via HTTP GET and POST\nrequests. Data that is sent is compressed and then base64-encoded before being included in\nthe requests.\n\nWe have observed the following capabilities of this payload:\n\nGet drive information\nRead \ufb01les\u0000\nWrite \ufb01les\u0000\nDelete \ufb01les\u0000\nMove \ufb01les\u0000\nSpawn processes\nCreate directories\n\nReaver TCP Payload\n\nThe malicious CPL payload of Reaver has the following three exported functions:\n\nServiceMain\nCPlApplet\nDllEntryPoint\n\nWhen the malware is initially loaded, DllEntryPoint will be called, which in turn will call a\nfunction that is responsible for decompressing a blob of data. The decompressed data\nconsists of various key/value pairings that represent important strings used by Reaver. An\nexample of this decompressed data can be seen below:\n\nRA@10001=ole32.dll\nRA@10002=CoCreateGuid\nRA@10003=Shlwapi.dll\nRA@10004=SHDeleteKeyA\nRA@10005=wininet.dll\nRA@10006=InternetOpenA\n[TRUNCATED]\nRA@10288=%s\\%s\nRA@10289=CMD.EXE\nRA@10290=%s=\nRA@10311=\\%sctr.dll\nRA@10312=\\uc.dat\nRA@10313=ChangeServiceConfig2A\nRA@10314=QueryServiceConfig2A\n\n1\n\n2\n\n\f3\n\n4\n\n5\n\n\f6\n\n7\n\n8\n\n9\n\n10\n\n\f11\n\n12\n\n13\n\n\f14\n\nWhen the malware wishes to retrieve one of these decoded strings, it will simply call a\nfunction with an integer argument that is responsible for providing it. For example, calling this\nfunction with an argument of \u201810001\u2019 would retrieve a string of \u2018ole32.dll\u2019.\n\nThe DllEntryPoint function proceeds to attempt to obtain the SeDebugPrivilege privilege, and\nalso calls WSAStartup for future network activity.\n\nWhen the CPlApplet function is loaded, it will begin by decompressing an embedded\ncon\ufb01guration using the same compression algorithm used previously. An example of this\u0000\ndecompressed con\ufb01guration may be seen below:\u0000\n\n\fFigure\n2\nDecompressed\nReaver\ncon\ufb01guration\u0000\n\nThis con\ufb01guration contains multiple pieces of information, including the following:\u0000\n\nNetwork port\nSleep timer between network requests\nRemote Command and Control (C2)\nService Name\nService Description\nService Display Name\nHardcoded String. This may be either a campaign identi\ufb01er, or perhaps a malware\u0000\nversioning string.\n\nThe malware proceeds to check to see if the original dropped malware \ufb01le exists. In the event\u0000\nit does, Reaver will move this \ufb01le to \u2018%TEMP%\\~FJIOW.tmp\u2019 and delete this new \ufb01le. This\u0000\u0000\nsimply acts as cleanup to ensure original \ufb01le artifacts no longer reside on the infected\u0000\nmachine. Reaver will then install itself as a service in the event it is running with\nSeDebugPrivilege privileges.  The service is con\ufb01gured with a name, description, and display\u0000\nname that is provided within the con\ufb01guration.\u0000\n\nReaver continues to collect various information from the victim machine, including the\nfollowing:\n\nComputer name\nVolume serial number\nMicrosoft Windows version\nCPU speed\nANSI code page\nOEM code page identi\ufb01er for the operating system\u0000\nPhysical and virtual memory information\n\nReaver encrypts this data using an incremental XOR key and uploads it to the con\ufb01gured\u0000\nremote server on the port speci\ufb01ed. The following example Python code shows how this\u0000\nencryption takes place:\n\n\fc = 0\nout = "], "URLs": [], "weight": 0.0}