{"rule_id": 490, "name": "Operation-Blockbuster-RAT-and-Staging-Report", "description": "-", "references": [], "File_Names": ["igfxtrayex.exe", "recdiscm32.exe", "mobsynclm64.exe", "expandmn32.exe", "mssscardprv.ax", "oleaut32.dll", "taskchg16.exe", "msxml13.xml", "crkdf32.inf", "vandyke.com", "hwrcompsvc64.exe", "dpnsvr16.exe", "KB25468.dat", "mremoteng.org", "tlvc.nls", "perfw06.dat", "Documents.lst", "rdpshellex32.exe", "iphlpapi.dll", "crypt.cpp", "faultrep.dat", "psapi.dll", "wtsapi32.dll", "estsoft.com", "KB25879.dat", "net_ver.dat", "dayipmr.tbl", "Wtsapi32.dll", "tmsconfig.msi", "iphlapi.dll", "msxml15.xml", "Default.rdp", "comon32.exe", "taskhosts64.exe", "wmdrmsdk.dat", "netsarang.com", "diskpartmg16.exe", "read.pudn", "6.rar", "ansi.nls", "cpp__.htm", "project.org", "Desktop.lst", "shlwapi.dll", "pkt.seed"], "MD5_Hashes": [], "SHA1_Hashes": [], "SHA256_Hashes": ["d88d27eb6cbc7da8d8c61f42756153f386c7edae7a45b77d7368bfbbf060eddf", "9b03695ca0945995ec6e2bc31662c08b0f499998dcbcd51701bf03add19f1000", "191e14e54cae4b33c077065b782a7161f0fd807a550a98fd1dac2db2b622c94c", "81c87a5a67963eab5193d342781e6b65604f7af74dd5cf7da960d20074da06b5", "1dfe016ae106feb6112fd689faeaa1d61c19a911493a4201fb510551364f7247", "6dab43a75647c20ac46c6f1cc65607dd4d7bb104e234b4f74f301e772e36ab9b", "7c55af4675cf0a3d173cb4e1b9282425c6e00b6ccfad1a1bcb0fddf29631461e", "f46d277baf0bb8d63805ff51367d34a9cbdd7a0a1394ab384fbe12d98c8fc4b8", "1200c02da0d6505a841f140f6d1947f1ae43a13664ec65b356b273c75f42713b", "1b78ffb5e6a6e3a98baf433d1932d8b3e4907acb1fd27501f799cb2966c1395e", "1fd96cc95ec3f48e97cfcd08bb15d4dd30c11a5b582776dfa15f1a2e2b4ed94e", "f340bb3c2d175e027351319573ddc451b632defe9dc47bbc30eabf62f749fb46", "2e20410ce8369572beee811f1898f6bc5c6782083aa1cc8e6dacc07b3fd392c9", "c1820cc86b5cca32d9b09a191a9461552f1f4477d427270e7440bd9d03737a64", "2d8e052bb93839dffe77b45be4418f64eeae35a7470a3c20827bae914dc1c7e4", "231af2bfa36b6b0d2e892fbba967062eb0b421ee4f7126709c51adb564d0c5a2", "6ce54331e126fd18c94e854a5e7fe3650a125cc83604f1a27a28f383e5193c07", "5ccfbeba9aa0f05d2dd4006afd7769f2e186dd321b521617a469936de89aa9a7", "3ee8fa11b85ec7a3e1f3cf3cee2553f795c56610091e373d4a7df344a66ae35d", "e8d1d9d6bb13a06fc893323a05063c868ba237b8729c120271384382eb60ed41", "a64cb2496fb1ef1adf9b5473e664dc1d124634233dd76b4d8fb5aa8d970742b5"], "Registry_Entries": ["HKLM\\SYSTEM\\CurrentControlSet\\\nControl\\WMI\\Security\\xc123465-\nefff-87cc-37abcdef9\n\nHKLM\\SYSTEM\\CurrentControlSet\\\nControl\\WMI\\Security\\ffcf3465-\nefff-87cc-37abcdef9\n\nStartup Delay\n\n0 Seconds\n\nRomeo-CoreOne \nCommands\n\n19\n\n3 Seconds\n\n20\n\nTable 5-1: Key Differences between RomeoCharlie-One and RomeoCharlie-Two\n\nRomeoCharlie-One operates as a service DLL that dictates that the binary must conform to the basic guidelines of a Windows \nservice \u2013 specifically, the export of the ServiceMain function. ServiceMain contains the necessary scaffolding code \nto ensure the Windows Services subsystem treats the binary as a legitimate service, but the function also contains several \ndynamic API loading functions for kernel32.dll, ws2_32.dll, advapi32.dll, oleaut32.dll, iphlpapi.dll, \nurlmon.dll, wininet.dll, user32.dll, shell32.dll, and shlwapi.dll. All said, RomeoCharlie-One loads 114 \ndifferent API functions into memory, but only 59 (approximately 52%) of these API functions are ever used by the malware. \nRomeoCharlie-One loads APIs from, but completely ignores, 6 of the 10 DLLs, indicating that the dynamic API loading \nfunctions are part of a larger library of code.\n\nRomeoCharlie-Two, on the other hand, does not require the complete Windows Services scaffolding as its sibling and \ntherefore does not export ServiceMain, nor does it even contain a ServiceMain-type function. Instead, execution of \nthe RomeoCharlie-Two code begins in DllMain as a newly generated thread. The RomeoCharlie-Two code begins with a \n3 second sleep delay before dynamically loading API functions from kernel32.dll, ws2_32.dll, advapi32.dll, and \niphlpapi.dll. Of the 103 API functions that RomeoCharlie-Two loads, the malware uses 73 (approximately 71%) of the \nfunctions, a dramatic increase from RomeoCharlie-One.\n\nBoth variants of RomeoCharlie begin, after the dynamic API loading, by loading their configuration from the registry \ninto memory. IndiaBravo-RomeoCharlie generates and stores the configuration for RomeoCharlie under the registry \nbranch HKLM\\SYSTEM\\CurrentControlSet\\Control\\WMI\\Security. The key under which the configuration \nresides varies by variant: RomeoCharlie-One\u2019s configuration exists under xc123465-efff-87cc-37abcdef9, while \nRomeoCharlie-Two\u2019s configuration exists under ffcf3465-efff-87cc-37abcdef9. Both configurations are the same \nsize (120 bytes) and contain a minimal amount of information: the listening port, the name of the service name under \nwhich the RomeoCharlie malware is running, the number of authenticated connections (from clients) that have occurred, \nand a 64-bit random value (presumably a unique identifier for the infection). \n\n20\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\fWith the configuration of the RomeoCharlie variants loaded into memory, the differences between RomeoCharlie-One \nand RomeoCharlie-Two cease (save for one exception that will be explained). RomeoCharlie is a server-mode RAT and, \nas such, must establish a listening port. Before a listening port is established at the Winsock level, RomeoCharlie first \nopens a hole in the Windows Firewall to allow incoming connections on the desired listening port (as specified in the \nconfiguration). The task of opening a firewall port consists of constructing and then issuing the command line seen in \nFigure 5-1 via CreateProcess.\n\ncmd.exe /c netsh firewall add portopening TCP <listening port number> ", "HKLM\\SYSTEM\\CurrentControlSet\\Services\\SharedAccess\\\nParameters\\FirewallPolicy\\StandardProfile\\GloballyOpenPorts\\List. RomeoWhiskey names \nthe new key {port number}:TCP and sets its value to {port number}:TCP:*:Enabled:Internet Connection \nSharing(ICS). \n\nFor incoming connections, RomeoWhiskey begins by authenticating the client through a handshaking protocol. The \nhandshake of RomeoWhiskey, Figure 13-1, starts by taking the current tick count of the victim\u2019s computer, performing a \nseries of bitwise transformations, and sending the result to the client as a challenge value. The client has up to 30 seconds \nto respond with a 4-byte response. The response value is then decomposed using another series of bitwise transformations \nto ensure a particular result. If any of the steps of the handshake fails, the handshake function returns a positive result, \nand the connection to the client terminates by means of a socket disconnection function call.\n\nint AuthenticationHandshake(SOCKET clientSkt)\n{\n unsigned __int16 wChallengeSeed = GetTickCount();\n unsigned __int32 dwChallengeResponse = 0;\n\n if ( SendData(clientSkt, \n           (wChallengeSeed << 16) | (wChallengeSeed >> 52) ^ 0xF3C0), \n            4, 1 )\n\nreturn 1;\n\n if ( WaitForSocketRecv(clientSkt, 30) )\n\nreturn 1;\n\n if ( RecvData(clientSkt, dwChallengeResponse, 4, 1) )\n\nreturn 1;\n\n return ((((dwChallengeResponse >> 16) & 0xFFFF) >> 52) ^ 0xF3C0) != \n(dwChallengeResponse & 0xFFFF);\n}\n\nFigure 13-1: RomeoWhiskey-One\u2019s Authentication Handshake Function for Command base 0x7D50 Samples\n\nThe SendData and RecvData functions are common network data transmission functions found in a variety of \nfamilies within the Lazarus Group\u2019s collection. These particular instances use DNSCALC-style encoding to obfuscate the \ndata as it traverses the network. \n\nAfter the authentication handshake completes, RomeoWhiskey spawns a new thread to handle the incoming requests \nfrom the client. Incoming requests consist of the client sending a modified version of a datagram specifying the command \nidentifier value (WORD), followed by the a 2-byte (WORD) value for the size of the payload, and then an optional payload \nvalue of up to 260 bytes. RomeoWhiskey uses the command identifier value to locate and execute the appropriate \ncommand handler. Table 13-1 lists the commands that RomeoWhiskey-One supports.\n\n42\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report \n   \n   \n   \n   \n \n \n\fCOMMAND NUMBER\n\nDESCRIPTION\n\nCommand base 0x7D50\n\nCommand base \n0x1E10\n\n0x7D50\n\nReturns victim\u2019s MAC address and computer name.\n\n0x1E11\n\n0x1E12\n\n0x1E13\n\n0x7D51\n\n0x7D52\n\n0x7D53\n\n0x1E14\n\n0x7D54\n\n0x7D55\n\n0x7D56\n\n0x1E15\n\n0x1E18\n\n0x1E19\n\n0x7D57\n\n0x1E20\n\n0x7D58\n\n0x1E21\n\n0x7D59\n\n0x7D5A\n\n0x7D5B\n\n0x7D5C\n\n0x1E16\n\n0x1E22\n\n0x1E23\n\n0x1E24\n\nGets System Information. See VictimInfoPacket definition for details. \nThis reports the malware as version \u201c1.5\u201d\n\nReturns the drive type (from GetDriveTypeA) for each logical drive on \nthe victim\u2019s computer.\n\nEnumerates the files in the specified directory.\n\nEnumerates the processes currently active on the victim\u2019s computer. For \neach process, includes the process\u2019s executable name and path, PID, the \nparent PID, and the timestamp of when the process was initially executed.\n\nTerminates a process by its PID, specified as either an ASCII string or a \nDWORD.\n\nExecutes a new process using a supplied command line string.\n\nDeletes a specified file.\n\nMatches the timestamp of a specified file to the timestamp of  \nkernel32.dll.\nExecutes the supplied command line via the command shell (cmd.exe). \nThe output of STDOUT (and, optionally, STDERR) are captured to a file in \nthe %TEMP% directory. The file is read up to 60 times and transmitted to \nthe client providing a pseudo-live stream of the output from the executed \ncommand.\n\nDisconnects. Returns a success response before terminating the \nconnection to the client.\n\nChanges the current working directory to the directory specified.\n\nUploads the contents of the specified file to the client.\n\nDownloads a file from the client and saves the file at the location and name \nspecified.\n\n0x7D5D\n\n0x1E25\n\nReturns the number of used and free bytes on the specified logical drive, as \nwell as the drive\u2019s name, serial number, and file system type.\n\n0x1E26\n\nReturns the creation, last accessed, and last write timestamps of the \nspecified file along with the file size. \n\n0x7D5E\n\n0x7D5F\n\n0x7D60\n\n0x1E17\n\n0x7D61\n\n0x7D62\n\n0x7D63\n\n0x7D64\n\n0x1E27\n\n0x1E28\n\n0x1E29\n\n0x1E30\n\nReturns the OSVERSIONINFOA data structure for the victim\u2019s computer.\nEstablishes a relay or proxy between the RomeoWhiskey-One instance and \na specified endpoint. The relay uses the same authentication handshake \nfunction to authenticate the endpoint prior to activating the relay threads.\n\n[Response code] Success\n\n[Response code] Failure\n\nNOP. Returns invalid command status to the client\n\n[Response code] Invalid command requested.\n\nTable 13-1: RomeoWhiskey-One\u2019s Support Commands and their Command Identifier Values\n\nMuch the same way Romeo-CoreOne uses specific numerical values to indicate success or failure of an operation, \nRomeoWhiskey uses 0x76D1 (for command base 0x7D50) or 0x1E27 (for command base 0x1E10) to indicate a successful \noperation and 0x7D62 (for command base 0x7D50) or 0x1E28 (for command base 0x1E10) for a failed operation.\n\n43\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\fLargely, the commands supported by command base 0x7D50 and command base 0x1E10 are identical, with the exception \nof command types 0x7D50, 0x1E11 and 0x7D5F. The command base 0x1E10 essentially combines commands 0x7D50 and \n0x7D5F, from command base 0x7D50, into the command identified by 0x1E11. Command 0x1E11 generates a large data \nstructure (Table 13-2) with identifiable information about the victim\u2019s computer. \n\n156 Bytes (OSVERSIONINFOEXA \nstructure)\n\nOS version information from GetVersionExA\n\nDESCRIPTION\n\nComputer name\n\nProcessor name (from registry key HKLM\\HARDWARE\\\nDESCRIPTION\\System\\CentralProcessor\\0\\\nProcessorNameString)\n\nFirst character to r if the service TermService is running. For \neach terminal session on the victim\u2019s machine, either the character s \nis appended, if the session currently has an active screen saver (e.g. is \nidle), or e if the session has an active explorer.exe instance running.\nVictim\u2019s login time\n\nMAC address of first NIC\n\nBelieved to indicate the version of WhiskeyRomeo (set to \u201c1.5\u201d)\nTotal number of MBs on all logical hard drives (DRIVE_FIXED)\nTotal number of free MBs on all logical hard drives (DRIVE_FIXED)\nInteresting open ports bitmask. Bit 0 = port 3389, Bit 1 = port 80, Bit \n2 = port 445, Bit 3 = 3306, Bit 4 = 1433\n\nOFFSET\n\nSIZE\n\n32 Bytes\n\n128 Bytes\n\n316\n\n30 Bytes\n\n0\n\n32\n\n160\n\n346\n\n354\n\n360\n\n364\n\n366\n\n368\n\n372\n\n377\n\n379\n\n16 Bytes (FILETIME)\n\n6 bytes\n\n4 Bytes\n\n2 Bytes (WORD)\n\n2 Bytes (WORD)\n\n4 Bytes (DWORD)\n\n5 Bytes \n\nUnused\n\n2 Bytes (WORD)\n\nUnused, explicitly set to 0\n\n1 Byte\n\nUnused, explicitly set to 0\n\nTable 13-2: RomeoWhiskey Command Base 0x1E10 based VictimInfoPacket Data Structure\n\nRomeoWhiskey continues to receive commands from the client until a command results in an error or the disconnect \ncommand is received from the client. RomeoWhiskey disconnects from the client by using the Lazarus Group\u2019s standard \nsocket disconnection function.\n\n44\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\f13.2 RomeoWhiskey-Two\n\nRomeoWhiskey-Two expands on the base code established by RomeoWhiskey-One. However, observed samples use \nonly the command base 0x1E10 supported commands. The most noticeable differences between RomeoWhiskey-Two and \nRomeoWhiskey-One are the introduction of the concept of channels and the more advanced authentication that utilizes \nasymmetric encryption.\n\nRomeoWhiskey-Two adheres to the basic model outlined in the previous section, but introduces a few deviations to the \nstartup sequence:\n\n1.  Determine exclusivity on the infected system\n\n2.  Dynamically load API functions\n\n3.  Attempt to load the configuration file\n\n4.  bind to a listening port\n5.  Save the configuration\n\n6.  Open a hole in the Windows firewall\n\n7.  Open a hole in the perimeter firewall using SSDT\n\n8.  listen for incoming connections\n9.  Spawn a handler thread\n\n10. Repeat steps 8-10 indefinitely.\n\nIn order to determine if only one instance of RomeoWhiskey-Two is active on a victim\u2019s system at any given time, \nthe malware uses the somewhat common technique of creating a mutex with a specific name before calling \nWaitForSingleObject and determining the return code of the call. If the WaitForSingleObject call returns any \nresult outside of WAIT_TIMEOUT, then RomeoWhiskey-Two assumes that only one instance of the malware is running \non the victim\u2019s machine. The name of the mutex depends on whether or not the victim\u2019s processor supports the CPUID \ncommand to retrieve processor info and feature bits. If the processor does not support the CPUID command for retrieving \nthe processor\u2019s info and feature bits, the mutex is given the name Microsoft. Otherwise, the mutex is the hexadecimal \nrepresentation of the 32-bit info bits and the 32-bit feature bits concatenated together. \n\nRomeoWhiskey-Two stores the configuration in the file %WINDIR%\\tlvc.nls. The format of the configuration file is \nidentical to that of RomeoWhiskey-One and is encoded using the DNSCALC-style encoding scheme. \n\nThe task of determining a listening port is greatly simplified compared to RomeoWhiskey-One\u2019s method. The attempt to \nbind to a listening port is limited to four attempts, first using the port defined in the configuration and, if unsuccessful, \nthen using three predefined port values (547, 133, and 117). \n\nIn order to allow inbound connections to the listening port, RomeoWhiskey-Two, like its predecessor, must open a hole \nin the Windows firewall. Instead of modifying the victim\u2019s registry, RomeoWhiskey-Two will use the netsh command \nto adjust the firewall\u2019s settings. The specific command that RomeoWhiskey-Two uses is Windows version specific as \nidentified in Table 13-3.\n\n45\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\fOS VERISON\n\nCOMMAND LINE\n\nXP or older\n\nVista or newer\n\ncmd.exe /c netsh firewall add portopening protocol=tcp port={listening port} \nname=CoreNetworkingHTTPS\ncmd.exe /c netsh advfirewall firewall add rule name=CoreNetworkingHTTPS \ndir=in action=allow Protocol=TCP localport={listening port}\n\nTable 13-3: RomeoWhiskey-Two\u2019s Firewall Modification Command Lines\n\nRomeoWhiskey-Two\u2019s developer(s) were not intent on modifying only the host-level firewall, as they actively try to \nmanipulate the perimeter firewall as well. By using the Simple Service Discovery Protocol (SSDP), RomeoWhiskey-Two \nattempts to determine the next hop between the infected machine and the Internet. If the local router responds with the \nURL for its UPnP interface, RomeoWhiskey-Two issues a series of Universal Plug and Play (UPnP) commands in order \nto map an external port on the firewall to the RomeoWhiskey-Two\u2019s listening port and name the new mapping \u201cDHCP \nClient\u201d. The net effect, if successful, allows RomeoWhiskey-Two to tunnel a hole from the exterior of the firewall (the \nInternet-facing interface) through to the RomeoWhiskey-Two instance. SSDP and UPnP configuration of firewalls is not \ncommon in larger networks, but rather is more likely to be found in a SOHO environment. This would indicate that either \nthe developer(s) of RomeoWhiskey-Two were unaware of the limitation of SSDP and UPnP in a corporate environment, or \nthat they were targeting smaller infrastructures.\n\nWhenever a new connection from a client occurs, RomeoWhiskey-Two immediately spawns a new thread to handle \nthe incoming requests. The generation of the new thread occurs prior to the authentication handshake, unlike \nRomeoWhiskey-One. The authentication handshake, meanwhile, is more evolved than the previously described function \nseen in Figure 13-1. RomeoWhiskey-Two generates a 16-byte buffer of random bytes before modifying the 3rd byte through \nthe 7th byte with the seed value and the 10th through 13th bytes with the challenge value as Figure 13-2 illustrates. The client \nhas 10 seconds to respond with another 16-byte buffer of which contains random data, a seed value and a challenge value \nin the same format. While the system, at face value, seems somewhat imposing, in actuality it is worthless for any form \nof cryptographic authentication. Both the request from the RomeoWhiskey-Two instance to the client and the client\u2019s \nresponse contain all of the components necessary to generate a valid response. The challenge value is derived from the \nseed value by performing several bitwise XORs and shifts, and an addition as Figure 13-3 describes. Therefore, by supplying \nboth the seed and the challenge values, there is practically no value to the handshake other than to prove both sides know \nthe algorithm. Furthermore, a simple packet replay by the client would satisfy the handshake\u2019s conditions. \n\nOFFSET\n\n+0\n\n+1\n\n+2\n\n+3\n\n+4\n\n+5\n\n+6\n\n+7\n\n0\n\n8\n\nRandom\n\nRandom\n\nRandom\n\nSeed value (DWORD)\n\nRandom\n\nRandom\n\nChallenge value (DWORD)\n\nRandom\n\nRandom\n\nRandom\n\nFigure 13-2: RomeoWhiskey-Two\u2019s Authentication Handshake Data Blob\u2019s Format\n\n46\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\fint Handshake(SOCKET s)\n{\n  struct \n  {\n   char r1[3];\n   unsigned __int32 seed;\n   char r2[2];\n   unsigned __int32 challenge;\n   char r3[3]\n  } pkt;\n\n  srand(GetTickCount());\n  seed = rand() * rand();\n  unsigned char *p = (unsigned char*)&pkt;\n  i = 0;\n  do\n    p[i] = rand() % 256;\n  while ( i < 16 );\n\n  pkt.seed = seed;\n  pkt.challenge = (((seed ^ 0x1A1E1C40u) >> 1) + 0x2E3E56E0) ^ 0xAF313230;\n\nif ( SendData(s, &pkt, sizeof(pkt), 1) )\n\nreturn 1;\n\n  if ( WaitForSocketRecv(s, 10) )\n\nreturn 1;\n\n  if ( RecvData(s, &pkt, sizeof(pkt), 1) )\n    return 1;\n\n  return ((((pkt.seed ^ 0x1A1E1C40u) >> 1) + 0x2E3E56E0) ^ 0xAF313230) != pkt.challenge;\n}\n\nFigure 13-3:RomeoWhiskey-Two\u2019s Authentication Handshake Function\n\nIf the handshake fails, RomeoWhiskey-Two shuts down the connection with the client using the socket disconnection \nfunction found in many of the Lazarus Group\u2019s families. If the handshake is successful, however, RomeoWhiskey-Two \nexpects the client to transmit two bytes (WORD). The WORD that the client sends specifies the particular channel the \nclient is requesting. RomeoWhiskey-Two supports two channels: RAT (identified by 0xC8C8) and Proxy (identified by \n0x5A5A). Each channel dictates a different form of traffic and supported commands. For instance, the RAT channel \npasses data in the previously mentioned datagram form, while the Proxy channel uses a different format entirely. This use \nof channels essentially allows RomeoWhiskey-Two to operate as two loosely coupled malware families at once.\n\nIf the client activates the RAT channel, RomeoWhiskey-Two sends a datagram of type 0x1E11 to the client before \nentering into another authentication phase. The RAT channel authentication phase is independent of the handshake \nauthentication process prior to entering the RAT channel and is based on the model of the handshake authentication \nfrom RomeoWhiskey-One. The RAT channel authentication, while similar to that of Figure 13-1, now involves asymmetric \nencryption using RSA public and private keys, specifically the public key found in SierraJuliett-MikeOne (see Section 17). \nAfter generating the challenge value through a series of bitwise shifts, XOR, and addition, RomeoWhiskey-Two encrypts \nthe 4-byte (DWORD) value using the same RSA transform function found in other Lazarus Group families, again most \nnotably SierraJuliett-MikeOne. After transmitting the encrypted value to the client, RomeoWhiskey-Two waits up to \n10 seconds for the client to respond. The client responds with a 4-byte (DWORD) value that must match the original \nchallenge value for the authentication to succeed. The implications of this is that only a client who possesses the private \nkey to decrypt the challenge value can access the RAT channel and its functionality.\n\nAfter the authentication phase is complete, RomeoWhiskey-Two\u2019s RAT channel settles into the same pattern of receiving \na datagram and dispatching the appropriate handle for the command found within the datagram. RomeoWhiskey-Two \n\n47\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report  \n  \n   \n   \n  \n\fsupports all of the same commands as command base 0x1E10 in RomeoWhiskey-One with the exception that the \ncommand for establishing a proxy/relay between the malware and an endpoint (0x1E17) has been replaced by the Proxy \nchannel. RomeoWhiskey-Two\u2019s RAT channel introduced a new command (0x1E10) and a new response code (0x1E31) as \nseen in Table 13-4.\n\nCOMMAND NUMBER\n\nDESCRIPTION\n\n0x1E10\n\n0x1E31\n\n0x1E32\n\n\u201cKnock\u201d on remote host port - Test if a connection is possible as the socket is immediately closed \non success. Basically this is a port ping. Returns a success status if the port responses, otherwise \nreturns a failure status.\n\n[Response code] RAT channel active acknowledgment \n\n[Response Code] \n\nTable 13-4: RomeoWhiskey-Two\u2019s Additional Supported RAT Channel Commands and their Command Identifier Values\n\nThe Proxy channel in RomeoWhiskey-Two allows for the construction of a ghost network on top of existing \ninfrastructure by linking RomeoWhiskey-Two infections to form virtual point-to-point sessions. After entering \nthe Proxy channel, the client transmits a 112-byte structure (Table 13-5) that defines the hops (up to 10) used by the \nvirtual connection in much the same way IP packets can specify Loose Source Routing or Strict Source Routing. The \nRomeoWhiskey-Two instance parses the Proxy channel command record sent by the client and determines the next hop, \nthen makes a connection to the endpoint. The command record generally specifies the route as a predefined sequence of \nRomeoWhiskey-Two nodes to use, but, if the operations flag (offset 104) is set to 0xC2672253, then the array of hops is \nused to randomly select the next node for the connection.\n\nOFFSET\n\nSIZE\n\nDESCRIPTION\n\n0\n\n80\n\n84\n\n88\n\n92\n\n94\n\n96\n\n100\n\n102\n\n104\n\n108\n\n80 Bytes [array of \nendpoints]\n\nArray of 10 records consisting of an IP (DWORD), a port (WORD) and a 2-byte unused \nfield. Each record specifies a possible next hop in the virtual circuit.\n\n4 Bytes (DWORD)\n\nNext hop index in the array of hop records (offset 0)\n\n4 Bytes (DWORD)\n\nMaximum hops\n\n4 Bytes (DWORD)\n\nFinal endpoint\u2019s IP address (as DWORD)\n\n2 Bytes (DWORD)\n\nFinal endpoint\u2019s port (as WORD)\n\n2 Bytes\n\nUnused\n\n4 Bytes (DWORD)\n\nEndpoint IP address (as DWORD)\n\n2 Bytes (WORD)\n\nEndpoint port (as WORD)\n\n2 Bytes\n\nUnused\n\n4 Bytes (DWORD)\n\nOperations flags\n\n4 Bytes (DWORD)\n\nConnection timeout\n\nTable 13-5: RomeoWhiskey-Two\u2019s Proxy Channel Command Record Data Structure\n\nOnce the next hop has been determined by RomeoWhiskey-Two, a connection to the hop is made and the authentication \nhandshake is performed. Earlier in this section it was pointed out that the algorithm used by the authentication handshake \nultimately serves no value in terms of authentication. When viewed in the context of the Proxy channel, the method for the \nhandshake begins to make a bit more sense, since the same function for performing the handshake is used here to establish a \nconnection between one RomeoWhiskey-Two instance and another RomeoWhiskey-Two instance. Furthermore, taking into \nconsideration that the handshake is no longer providing any real form of authentication, the use of asymmetric cryptography \nfor the RAT channel\u2019s authentication makes significantly more sense to the overall design of the malware.\n\n48\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\fDepending on the position of the node receiving the command record within the overall virtual connection, the \nRomeoWhiskey-Two node requests either the RAT channel or the Proxy channel. The determination of which channel to \nuse is made based on the value of the final endpoint IP address (offset 88). If the virtual connection has reached the final \ndestination, then the RAT channel is opened, otherwise the Proxy channel is requested. With the appropriate channel \nestablished, RomeoWhiskey-Two activates two threads to handle the relaying of data from node to node, with each node \nresponsible for data in only one direction. It is worth noting that the relay threads transmit data without employing the \nencoding scheme found elsewhere within the RomeoWhiskey-Two communications. \n\n49\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\f14. [Spreader] SierraAlfa\n\nA self-install service-based executable, SierraAlfa begins a chain of infection that ultimately leads to the potential \ndevastation of an entire network of computers. SierraAlfa is responsible for the distribution and activation of WhiskeyAlfa \non a victim\u2019s network. The observed samples of SierraAlfa were clearly built specifically for the SPE attacks as they contain \ninfrastructure and account information specific to SPE\u2019s networks. \n\nTwo variants have been observed: SierraAlfa-One and SierraAlfa-Two. SierraAlfa-One is the base model, while \nSierraAlfa-Two provides additional features to ensure the propagation of the malicious payload within.\n\n14.1 SierraAlfa Base (SierraAlfa-One)\n\nSierraAlfa-One is the base upon which the other SierraAlfa variant is derived. There have been only two observed \nSierraAlfa samples (one for SierraAlfa-One and one for SierraAlfa-Two) in the wild. Given the very specific targeting and \nnature of their functionality, it is highly probably the SierraAlfa family is a one-off series. Given that SierraAlfa-One is the \nbase model, this section will refer to SierraAlfa-One simply as SierraAlfa. Unless otherwise noted in the following section, \nthe activities present in SierraAlfa-One are the same as SierraAlfa-Two in both design and execution.\n\nSierraAlfa, when activated, determines which, if any, command line arguments are present. If no command line \narguments are present, SierraAlfa relaunches itself using CreateProcess after adding \u2013i to its command line. The \u2013i \nargument causes SierraAlfa to install itself as a service. SierraAlfa also supports the \u2013k argument, which causes SierraAlfa \nto operate as a standalone service. Any other command line arguments will result in a window appearing as seen in Figure \n14-1 (without the \u201cAbout\u201d dialog box which is shown to give a full perspective of the application). The window, and the \nresources within the SierraAlfa binary that produce the window, reveal that the developer(s) used the Visual C++ v6 \u201cHello \nWorld\u201d template to create the basic application framework. Knowing that the title of the application, in this case Hello, \nis the same as the project name by default for the template, the original SierraAlfa project had the simple name of Hello. \n\nFigure 14-1: SierraAlfa\u2019s Window When Supplied an Invalid Command Line Argument\n\n50\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\fWhen activated with the \u2013i command line argument in order to induce the service installation mode, SierraAlfa follows a \nvery simple series of steps to install the WinsSchMgmt service on the victim\u2019s computer:\n\n1.  Call CreateServiceW to add a new service (WinsSchMgmt) to the victim\u2019s computer with the description \u201cWindows \n\nSchedule Management Service\u201d and set the command line argument for the service\u2019s binary to \u2013k.  \n2.  Call ChangeServiceConfig2A to, again, set the description to \u201cWindows Schedule Management \n\nService\u201d.\n\n3.  Call ChangeServiceConfig2A to set the on-failure retry modes.\n4.  Open a handle to the new service and call StartServiceW to activate the service.\n5.  Terminate silently.\n\nSierraAlfa does not attempt to move its binary prior to installing itself as a service on the victim\u2019s computer. The inclusion \nof the \u2013k argument for the service ensures that upon activation by the Windows Services system, SierraAlfa activates its \nservice handler. The service handler, aside from the normal Window services scaffolding, calls the function of SierraAlfa \nthat kicks off the propagation functionality of the malware.\n\nThe propagation functionality begins by dropping a file on the victim\u2019s system and loading another into memory. The \npayload files of SierraAlfa are appended to the end of the SierraAlfa binary in a stacked fashion, preceded by a table of \ncontents data structure. The location for the start of the table of contents and the stacked files that follow is determined \nby the last 4 bytes (DWORD) of the SierraAlfa binary. The 4 bytes at the end of the binary define the distance from the \nbeginning of the binary to the beginning of the table of contents. The table of contents specifies both the actual size and \nthe compressed size for each of the payload components that SierraAlfa drops or loads. Figure 14-2 visualizes the format \nof the payload\u2019s organization. The payload contains two files: a WhiskeyAlfa executable and a text file containing a list of \ntarget servers. The WhiskeyAlfa executable is always compressed with Zlib, while the target list may be either compressed \nusing Zlib or simply stored. If the decompressed size and the size of the target list are not equal, SierraAlfa assumes the \nlist is compressed and attempts to decompress the list in memory. Otherwise, the contents of the list are XOR\u2019d with 0x67 \nto reveal the original content. \n\nExecutable\u2019s Size (decompressed) [DWORD]\n\nExecutable\u2019s Size (in image) [DWORD]\n\nTargets List\u2019s Size (decompressed) [DWORD]\n\nTargets List\u2019s Size (in image) [DWORD]\n\nSierraAlfa\u2019s Binary Image\n\nPayload Table of Contents\n\nExecutable Image\n\nTarget List\u2019s Image\n\nOffset to Table of Contents[DWORD]\n\nFigure 14-2: SierraAla\u2019s Stacked Payload Layout\n\n51\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\fSierraAlfa saves the WhiskeyAlfa binary to disk as igfxtrayex.exe in the same directory as the running SierraAlfa \nimage and then immediately executes the binary by calling CreateProcess. The target list is parsed to extract target \ninformation and compromised accounts to use against the targets. The target list consists of two sections: a section \nspecifying the username and passwords for compromised accounts and a section containing target servers to infect. \nSierraAlfa parses the target information as a list of compromised accounts until it reaches a line containing only a hyphen, \nat which point it assumes the rest of the file contains the target hosts list. \n\nThe structure for the account information is as follows:\n\ndomain\\username|password\n\nThe structure for the target list is:\n\nhostname|IP1|IP2\n\nThe hostname field specifies the Windows name of the computer, IP1 field specifies the first IP address of the computer, \nand the optional IP2 field specifies a second IP address for the server. The fact that the developer(s) allow for multiple \naddressing options for a target illustrates that the developer(s) took into consideration that an infected host may be \non different network segments than the target computer; as such, different routing and addressing methods may be \nnecessary in order to compromise a host. The use of multiple addressing options for a target shows both a sufficient level \nof reconnaissance within the victim\u2019s network and a desire by the developer(s) to ensure as many compromised targets as \npossible with the least amount of attacker intervention.\n\nWith the WhiskeyAlfa executable dropped and executed, and the targeting information loaded, the task of distributing \nitself across the victim\u2019s infrastructure begins. SierraAlfa maintains two lists: a list of targets (loaded by the previous step) \nand a list of hosts that it has already infected, or at the very least attempted to infect. Until the size of both lists becomes \nequal, indicating that all of the targeted hosts have been attacked, SierraAlfa attempts to infect up to 10 hosts at a time, \nwith each attack occurring in its own thread. When SierraAlfa reaches a thread saturation level (10 threads), SierraAlfa \nenters a tight loop that simply sleeps 100ms before checking to see if the current number of threads has fallen below 10. \nThis thread management system is effective but rudimentary, indicating that the developer(s) were not well versed in \nmultithreaded, asynchronous programming on Windows.   \n\nThe selection of which host to attack at any given time is completely random. To avoid the duplication of effort that would \nstem from attacking a host that has already been attacked, the randomly selected hosts\u2019 entries are checked to ensure they \nhave not already been used. If the host has already been attacked by the instance of SierraAlfa, a new host is randomly \nselected until a host is found that has not yet been attacked. This behavior would suggest that the longer SierraAlfa runs \nand attacks hosts, the longer the selection process will take. However, this methodology does allow for a better statistical \ncoverage model when viewed as a larger set of infected hosts all using the same targeting information that exists in \nthe same order. The randomization of which hosts to attack at any given point means that the probability of two hosts \nattacking the same sequence of targets in the same order is relatively low for a large enough data set. To that point, the \ntarget list within SierraAlfa-One contains over 20,000 target machines.\n\n52\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\fFor each attack thread that SierraAlfa generates, the thread attempts to resolve the host name of the target, specified in \nthe target information\u2019s hostname field. A determination is made as to whether or not the host is accessible and has an \navailable Windows share port open by attempting to connect to either port 445 or 139. If the thread is able to access either \nport, the thread randomly selects one of the username and password entries before performing the following tasks:\n\n1.  Open a channel, via SMB, to the target host via a call to WNetAddConnection2A.\n2.  If unable to access the admin$ share on the target host, create a service named RasMgrp{random number} on the \n\nvictim\u2019s machine with the command line:  \n\ncmd.exe /q /c net share shared$=%SystemRoot% /GRANT:everyone,FULL\n\n3.  Randomly select the destination filename from one of the following names:\n\n\u2022 recdiscm32.exe\n\n\u2022 taskhosts64.exe\n\n\u2022 taskchg16.exe\n\n\u2022 rdpshellex32.exe\n\n\u2022 mobsynclm64.exe\n\n\u2022 comon32.exe\n\n\u2022 diskpartmg16.exe\n\n\u2022 dpnsvr16.exe\n\n\u2022 expandmn32.exe\n\n\u2022 hwrcompsvc64.exe\n\n4.  Copy the SierraAlfa binary to the admin$\\syswow64 or shared$\\syswow64 (if unable to access the admin$ \n\nshare) directory as the randomly selected filename (from #3)\n\n5.  Copy the SierraAlfa binary to the admin$\\system32 or shared$\\system32 (if unable to access the admin$ \n\nshare) directory as the randomly selected filename (from #3) and verify the copy was successful\n\n6.  Set the timestamp of the newly copied executable to match the target host\u2019s calc.exe\u2019s timestamp.\n7.  If #2 resulted in a new service, replace the service\u2019s command line with  \n\ncmd.exe /q /c net share shared$ /delete\n\nand restart the service\n\n8.  Install and activate a new service named RasSecruity (note the misspelling of \u201cSecurity\u201d) with the command line \n\nset to the name of the newly installed binary in the system32 directory.\n\n9.  If the service RasSecruity fails to activate, using the Windows Management Instrumentation Command-line \n\napplication wmic, attempt to start the SierraAlfa binary on the target system by calling CreateProcess with the \ncommand line  \n\n53\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report \n \n\fcmd.exe /c wmic.exe /node:\u201d{name of target host}\u201d /user:\u201d{username}\u201d  \n/password:\u201d{password}\u201d PROCESS CALL CREATE \u201c{randomly selected name}\u201d > {current thread ID}_\n{current tick count} \n\nand parse the {current thread ID}_{current tick count} file to determine if the string ProcessId was found, \nindicating the process started successfully. \n\nIf any of the thread\u2019s tasks fail, the thread disconnects from the target host by calling NetCancelConnection2A before \nattempting the tasks again using first the value of the IP1 field as the target host; if that is unsuccessful, the value of the \nIP2 field is used, if present. \n\nIf the infection of the target host is successful, SierraAlfa sends a reporting data packet to one the hardcoded C2 servers \nchosen at random. Table 14-1 defines the structure of the reporting data packet. If the transmission to a particular C2 \nserver is unsuccessful, a new C2 server is chosen from the list of hard coded C2 servers, and the transmission it attempted \nagain. SierraAlfa attempts to report the status of an infection up to three times before abandoning this endeavor. \n\nOFFSET\n\nSIZE\n\nDESCRIPTION\n\n0\n\n2\n\n6\n\n2 Byte (WORD)\n\nSize of the data that follows (40)\n\n4 Bytes (DWORD)\n\nIP address of the infected host (as 32-bit value)\n\n32 Bytes\n\nHostname of the infected host\n\n38\n\n4 Bytes (DWORD)\n\nSuccessful infection status (set to 1)\n\nTable 14-1: The Structure of the SierraAlf Reporting Data Packet\n\nAfter the transmission of the report data (or if the infection was unsuccessful, after the disconnect from the infected \nhost), the thread decrements the global counter of active threads, thereby freeing up a new slot to allow a new infection \nthread to commence. \n\nOnce all attack operations have concluded, the SierraAlfa service remains in a running state but becomes idle.\n\n54\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\f14.2 SierraAlfa-Two\n\nSierraAlfa-Two has a compile time roughly two hours after the compile time of SierraAlfa-One. During the two hours \nbetween the variants, the developer(s) made several modifications:\n\n\u2022  The status of an infection attempt is logged to net_ver.dat\n\u2022  The command line argument \u2013k results in SierraAlfa being run under the context of each user currently logged in to \n\nvictim machine through terminal services\n\n\u2022  The propagation functionality is activated by supplying \u2013s on the command line \n\nSierraAlfa-One contains the basic framework for recording infection status information, but it is not until SierraAlfa-Two \nthat the framework is fully completed by the developer(s) and utilized. At the conclusion of an attack thread, \nSierraAlfa-Two generates a string using the following form: \n\n{Target Hostname}|{Target\u2019s IP Address}|{Infection Status}\n\nThe {Infection Status} field indicates whether an infection was successful (set to 1) or unsuccessful (set to 2). The targeting \ninformation within SierraAlfa-Two is significantly less involved than SierraAlfa-One. The target list contains only 58 \nhosts, many of which do not have a host name but only an IP address, and all of which are routable on the Internet. From \nthis information, it would appear that SierraAlfa-Two was targeting network-facing, or firewall-exposed, targets only. \n\nThere is also the fact that the service that SierraAlfa installs does not immediately begin the propagation tasks, but \nrather targets the currently logged-in users of the victim host, another behavior change. The \u2013k mode begins by calling \nWTSEnumerateSessionW to list the active terminal services sessions and, for each session found, the token of the user \nis obtained and given to CreateProcessAsUser in order to run SierraAlfa-Two as the logged-in user. This method \ndoes not necessarily increase the likelihood of a successful infection, given that the infection mechanism uses a finite set \nof preconfigured username/password combinations that have no relationship to the user under which the new SierraAlfa \ninstances are running. It is therefore unclear why the developer(s) chose to add this method.\n\n55\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report \n\f15. [Spreader] SierraBravo (Brambul)\n\nSierraBravo, commonly known as Brambul, is a spreader that uses insecure user accounts to propagate its malware, and \nitself, across a both intra-connected and interconnected networks. SierraBravo operates as a standard executable, a service \nexecutable or, with some observed samples, as a service DLL. \n\nSierraBravo has had several variants over the course of its developmental lifespan. The primary focus of the SierraBravo \ncode base is the propagation of malware through unsecured or insecure network shares. Over time, the developer(s) of \nSierraBravo have added additional functions such as the ability to report to a C2 server the status of propagation. Despite a \ngeneral cohesive task of propagating malware and a common functionality for performing this task, it is necessary to split \nit into two variants, SierraBravo-One and SierraBravo-Two, due to some functional and structural differences that are \noutside the scope of normal malware evolution and refinement. SierraBravo-One represents the variants that operate as \neither a standalone or service executable, while SierraBravo-Two contains the samples that operate as a service DLL.\n\nDespite their structural differences, there are some commonalities between the variants:\n\n\u2022  They rely on dynamic API loading with some, but not all, API function names encrypted using a variant of \n\nDecryptPassword from an open source malware known as rBot8\n\n\u2022  The IP ranges 10.0.0.0/8, 12.0.0.0/8, 127.0.0.0/8, 192.0.0.0/8, 198.0.0.0/8, 216.0.0.0/8 are excluded from any attack \n\n(SierraBravo-One also excluded 8.0.0.0/8)\n\n15.1 SierraBravo-One\n\nThe first operation SierraBravo-One performs is the verification of its exclusivity on the victim\u2019s system. By checking for \nthe presences of the named mutex Global\\\\FwtSqmSession106829323_S-1-5-19, SierraBravo-One can determine if \nit is the only instance of itself running on the victim\u2019s machine. If a copy of the malware is already active, SierraBravo-One \ngenerates and executes a suicide script in order to remove the extraneous copy of itself. \n\nSierraBravo-One determines the number of command line arguments present at the time of activation. If at least \none command line argument is given and the first argument is -i, SierraBravo-One enters an installation mode. \nInstallation mode begins by verifying that there are 5 arguments on the command line. The five command line arguments \nSierraBravo-One expects are as follows:\n\n-i <max. number of attack threads> <timeout> <primary C2 server address> <prime C2 server port>\n\nSierraBravo-One uses the command line arguments to construct a base configuration file which it saves to  \n%WINDIR%\\KB25468.dat and encrypts using RC4. A new directory is generated at %WINDIR%\\system, and the \nSierraBravo-One binary copies itself to the directory under the name svchost.exe. Using the Windows Service \nAPI functions, SierraBravo generates a new service named Windows Filter Driver with the newly installed \n\n8 \n\n \u201crbot6.6.rar crypt.cpp\u201d http://read.pudn.com/downloads110/sourcecode/hack/scanner/454581/rBot_041504/crypt.cpp__.htm 14 April 2004.\n\n56\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\fsvchost.exe binary being the target of the service. The Windows Filter Driver service is activated using the \nStartService API function before a suicide script is generated (as msvcrt.bat) and executed to remove the original \nSierraBravo-One binary from the victim\u2019s system. \n\nWhen SierraBravo-One is activated as a standard executable with no command line arguments, the binary \neffectively activates as a service executable. When activated as a service executable, SierraBravo-One uses the \nStartServiceCtrlDispatcher API function to establish the service framework for the binary. After activating the \nnecessary service framework to establish itself as a legitimate service on the victim\u2019s computer, SierraBravo-One transfers \ncontrol to its core functionality. \n\nThe core functionality of SierraBravo-One is contained within two C++ classes and requires a minimal amount \nof scaffolding code in order to activate. Specifically, the dynamic loading of API functions, the loading of the \nconfiguration from %WINDIR%\\KB25468.dat into memory, and the activation of the Windows\u2019s WinSock API. The two \nSierraBravo-One classes divide the tasks of running the attacks and managing the attacks. Novetta has given the class \nresponsible for running the attacks the identifier CSmbSpreader and given the class responsible for managing the \nattacks the name CBrambulManager. \n\nThe instantiation of the CSmbSpreader class object consists establishing a list of targets and configuration settings. \nThe file %WINDIR%\\KB25879.dat contains a list of targets queued from previous executions of SierraBravo-One and is \naugmented at startup by a list of local network IP addresses. The instantiation of the CBrambulManager class object is \nsignificantly less involved and only includes the establishment of a watchdog event (which will be explained shortly).\n\nAfter instantiating the two primary classes of SierraBravo-One, the malware activates CBrambulManager first by \ngenerating a new thread and calling the primary method within the class. The main member of CSmbSpreader is \nsimilarly activated within its own thread. At this point, the main thread of SierraBravo-One enters an infinite sleep.\n\nThe main member of CBrambulManager begins by generating a watchdog thread. The watchdog thread, as the name \nimplies, periodically (every 5 minutes, approximately) sets the watchdog event. This process repeat until SierraBravo-One \nterminates. The main member of CBrambulManager uses the watchdog as an indicator of when it should begin the \nfollowing set of tasks:\n\n1.  Connect to the configured C2 server\n\n2.  Transmit the current attack log (located at %SYSDIR%\\perfw06.dat) to the C2 server\n3.  Generate new, random target IPs if instructed by the C2 server\n\n4.  Receive additional targets from the C2 server\n\n5.  [Optionally] Send a heartbeat to the C2 server.\n\nAfter performing the set of tasks, the main member of CBrambulManager resets the watchdog event and waits for the \nnext watchdog event to occur.\n\nWhat is important to note about the tasks of the main member of CBrambulManager is that SierraBravo-One \ndoes not only generate its own random targets, but it can also receive explicitly stated targets from a C2 server. If \nthe C2 server provides additional targets, SierraBravo-One does not send a heartbeat. Instead, the main member of \nCBrambulManager sleeps for 3 minutes before waiting for the next watchdog event to occur.\n\nCommunication with the C2 server is encrypted using a simple XOR 0x37. The handshake upon connect with the C2 \nserver is a simple DWORD value exchange to verify that the encoding is symmetric between hosts. Such a simplistic \nencryption allows for easy decryption of communication between the C2 server and the infected host.\n\nIf a heartbeat that SierraBravo-One sends results in a failure to receive from the C2 server or if the server replies with \na 0 (after decryption), the main function of CBrambulManager begins the process of uninstalling and terminating \nSierraBravo-One. The configuration file, the target list file, and the attack log files are deleted, and the service under \n\n57\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\fwhich SierraBravo-One exists is terminated and deleted. To complete the removal of SierraBravo-One, the malware \ngenerates and executes a suicide script before calling ExitProcess. \n\nThe main member of the CSmbSpreader class consists of an infinite loop that performs the following tasks until the \nSierraBravo-One process terminates:\n\n1.  Wait until the number of attack threads is less than the maximum allowed thread count\n\n2.  Convert the target IP from a binary number into a quad-dot string (e.g. 1.1.1.1)\n3.  Generate a new attack thread for the target\n\n4.  After 255 attack threads, save the current state of the targeting queue\n\n5.  If the attack queue is empty, set the watchdog event\n\n6.  Sleep for 1 second\n\nThe attack thread that SierraBravo-One generates for each new target begins by attempting to connect to the target \nvia Windows share (SMB). If successful, the domain and Windows OS type (e.g. Windows XP, Windows Vista, etc.) are \nobtained. The attack thread then attempts to bruteforce the Windows share by attempting a combination of the generated \nusername and password combinations. The generating of usernames centers around permutations of the username \nAdministrator in two different languages (English and Spanish) combined with variations of the target\u2019s reported \ndomain name. The passwords that SierraBravo-One uses are generated from a list of 185 weak passwords, of which 11 are \nused as templates. If the password string contains %u, SierraBravo-One generates a new password where the %u substring \nhas been replaced with generated username. Table 15-1 lists the hardcoded passwords found within SierraBravo-One.\n\n58\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\fAdmin789&*(\nPassword\n1password\npassword123\npassword.\n999999\n7777777\nAdmin\nPASSWORD\nadobe123\nprincess\nazerty\nqwer1234\nqwer1234!~\nadmin@123\n1qaz@wsx\n!!!!\nhimself.51\nelmismo.51\nElmismo.51\nElMismo.51\n\n%u\n%u1234\n%u!\n%u12\n%u!@\n%u2014\n%u1004\n%u1!\n%u#1\n%u123\n%u123$%^\n112233\n123456\n123\nadmin\n1234\n1\npassword\nP@ssw0rd\nP@ssw0rd1\np@ssw0rd\n0\n12345\n1111qq\n112233\nQWER1234\n0000\n12345678\n123456789\n000000\na\n123123\n1111\n111\n111111\nguest\nadmin123\nqwerty\n000\n654321\n1234567\nabc123\n321\n11\n11111111\n1q2w3e4r\nserver\n888888\n11111\n123qwe\nlove\nsuper\n8888\ntest\nletmein\n\n007\nqazwsx\nroot\n!@#$%^&*\n00000\n12\n888\n1212\ndell\nabc\nmanager\n88888888\nq1w2e3r4\n1q2w3e\n54321\npassword1\naaa\nhome\nqazwsxedc\n2010\npass\ncomputer\n4321\nqwert\ntest123\n121212\nsecret\niloveyou\nasdf\naa\nwelcome\nmaster\ncompaq\ntemp\noracle\n1234qwer\nabcd\nq1w2e3\nxxx\n2008\n7777\ncisco\nasdf123\nasdfgh\nq1w2e3r4t5\nzxcv\n00\ncontrol\n123abc\n2009\nbackup\nqwer\nq1w2e3r4t5y6\nwin2003\n2002\n\nbaseball\n1313\n!@#\n88888\nshadow\nwin\nwinxp\nsunshine\ngateway\nharley\ninternet\ntemp123\nxp\n2007\nadmin!@#\nasdfg\n!@#$%^\n2003\ntrustno1\ngolf\n!@#$%^&\n2112\ndefault\nfish\ngod\n!\n2005\n6969\n!@#$\nblank\nfoobar\nowner\npasswd\ntest1\nxxxx\npassword!\npassw0rd\npassw0rd!\np@ssw0rd!\n1234567890\n*1234\n1q2w3e4\n1qaz2wsx\n!@#123\nadmin!@#456\nAdmin!@#456\nadmin123$%^\nAdmin123$%^\nrootroot\n87654321\n2014\nwin2012\nadmin123!@#\nAdmin123!@#\nadmin789&*(\n\nTable 15-1: SierraBravo-One Password List (note that the entries in bold are template passwords)\n\n59\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\fWith a list of username and passwords ready for the specific target, the attack thread attempts to bruteforce the target. \nSierraBravo-One attempts to pull a list of valid usernames from the target host by calling the NetUserEnum API \nfunction. If successful, the bruteforcing process uses the names returned from NetUserEnum instead of the variations \nof Administrator. Regardless of which usernames list is used, the bruteforce process does not use the Windows SMB \nAPI functions but rather performs the SMB interaction manually through SMB packet crafting. For each username and \npassword combination, SierraBravo-One attempts to login to the target through the root Windows share (e.g. \\\\1.1.1.1) \nuntil a successful combination is found or the set of combinations is exhausted. \n\nIf successful in finding a vulnerable account on the targeted machine, SierraBravo-One attempts to install itself and its \npayload malware (typically, the payload malware is the instance of SierraJuliett-MikeOne running on the same machine as \nthe SierraBravo-One infection). The procedure for infecting a vulnerable machine is as follows:\n\n1.  Connect to the root share on the targeted host using the username and password obtained from the bruteforcing \n\nprocess by using the Windows SMB API.\n\n2.  Create a service on the targeted host as RPCEvent{random decimal number} with one of the following command \nlines in order to establish a new share named $adnim on the targeted machine. Note the misspelling of the new \nshare. The developer(s) specifically mislabeled the share to be close to the legit admin$ share. The use of the GRANT \nparameter occurs on targets who report their operating system as any value other than Windows 5.0, Windows \n5.1, or Windows 2002 (e.g., non-Windows NT based computers).\n\ncmd.exe /q /c net share adnim$=%SystemRoot% /GRANT:{username},FULL\n\nFigure 15-1: SierraBravo-One Share Command for Victims Using Windows 2000 or later\n\ncmd.exe /q /c net share adnim$=%SystemRoot%\n\nFigure 15-2: SierraBravo-One\u2019s Share Command for Victims running Non-Windows NT Computers\n\n3.  Copy the payload malware to targeted host\u2019s %SYSDIR% directory via the new adnim$ share. \n4.  Reads the local SierraJuliett-MikeOne\u2019s seed list file (mssscardprv.ax) to obtain the first IP and port in the list.\n5.  Create a new service called HelpEvent{same random decimal number as step #2} with the command line seen in \n\nFigure 15-1 in order to activate the SierraJuliett-MikeOne payload on the targeted machine.\n\ncmd.exe /c {Binary Name} {IP of Seed Node} {Port of Seed Node}\n\nFigure 15-3: SierraBravo-One\u2019s SierraJuliett-MikeOne Activation Command\n\n6.  The adnim$ share is deleted by issuing the command seen in Figure 15-4 under the same HelpEvent{...} service.\n\ncmd.exe /q /c net share adnim$ /delete\n\nFigure 15-4: SierraBravo-One\u2019s Command to Delete the Previously Established Share\n\nAfter the installation (or attempted installation) of the SierraJuliett-MikeOne malware on the target machine, \nSierraBravo-One attempts to determine if the Windows Terminal Services port (3389) is accessible on the target. In order \nto make the accessibility determination, SierraBravo-One merely attempts to connect to the port. If the connection is \nsuccessful (without any data transfer), SierraBravo-One considers the port available. \n\n60\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\fSierraBravo-One retains a log of all successful attacks. Each log entry contains the fields illustrated in Table 15-2. \n\nOFFSET\n\nSIZE\n\nDESCRIPTION\n\n0\n\n4\n\n5\n\n6\n\n56\n\n106\n\n156\n\n4 Bytes (DWORD)\n\nIP address of target\n\n1 Byte\n\nHost attributes bitmask: \nbit 0 \u2013 infected successfully \nbit 4 \u2013 has Terminal Services port open\n\n1 Byte (Boolean)\n\nTarget successfully infected \n\n50 Bytes (NULL-terminated string)\n\nUsername used to access the target\n\n50 Bytes (NULL-terminated string)\n\nPassword used to access the target\n\n50 Bytes (NULL-terminated string)\n\nDomain of the target\n\n100 Bytes (NULL-terminated string)\n\nWindows OS version reported by SMB\n\nTable 15-2: SierraBravo-One\u2019s Attack Log Entry Structure\n\nBefore saving the log entry to the log file, SierraBravo-One encrypts each log entry with RC4. The encryption key used for \nthe RC4 encryption is 118 bytes long and changes every 10 minutes. The generation of the RC4 keys involves the creation of a \nrandom 118-byte buffer and then the encryption of the 118-byte buffer using the same RSA public key found in SierraJuliett-\nMikeOne. The encrypted RC4 key is then saved to the attack log file followed immediately by the encrypted log entry.  \n\nAfter performing an attack against a target, the resources of the attack thread are released and the global indicator of \nnumber of attack threads in use is decremented.\n\n61\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\f15.2 SierraBravo-Two\n\nSierraBravo-Two operates as service DLL with the primary entry point for the malware existing within the \nServiceMain function. After establishing the scaffolding for a legitimate Windows service, SierraBravo-Two spawns \na new thread to contain the core SierraBravo-Two functionality. At inception, the core of SierraBravo-Two attempts \nto verify if the named mutex PlatFormSDK2.1 exists on the victim\u2019s system indicating at another instance of \nSierraBravo-Two is already active. If another instance is active, the malware terminates to avoid collisions. \n\nLike SierraBravo-One, SierraBravo-Two is heavily object oriented with the bulk of its functionality contained within \na single class object. Upon instantiation, the SierraBravo-Two class requires the maximum number of parallel attack \nthreads allowed, the filename of the malware to spread, and the number of seconds to wait for a response from a \ntargeted machine before aborting the attack. This information is used by the class as the basis for the configuration of \nthe SierraBravo-Two\u2019s operation. During the class initialization process, the list of queued attack targets is loaded into \nmemory from the file %SYSDIR%\\KB25879.dat as well as an additional set of targets based on the local network\u2019s IP \nrange (as determined by the configuration of the victim\u2019s network cards). \n\nSierraBravo-Two performs the same attack against as a target as SierraBravo-One with the following modifications:\n\n\u2022  The initial username list consists of Administrator in English, Spanish and French\n\n\u2022  The SierraJuliett-MikeOne configuration/seed list file is also copied to the target\n\n\u2022  The activation of SierraJuliett-MikeOne on the target machine does not include the {IP of Seed Node} or {Port of \n\nSeed Node} command line parameters\n\n\u2022  A record of the compromise is not recorded locally, but an email of the event occurs instead\n\n\u2022  After every 255 attacks, the current state of the attack queue is saved to disk.\n\n\u2022  After the entirety of the attack queue is complete, the maximum of attack threads are generated with each thread \nmarked for randomly generating IP addresses to attack and then attacking said targets. Note that, as indicated \npreviously, some network ranges are excluded.\n\nThe most distinctive difference between SierraBravo-One and SierraBravo-Two is the use of email for alerting the \noperators to newly infected targets. For each target infected, SierraBravo-Two generates a thread to handle the generation \nand transmission of an email message via SMTP. The email addresses used by SierraBravo-Two for both the To: and \nFrom: fields change periodically, but the structure of the email is largely consistent. The message contains no body but \nthe subject line provides all of the necessary information for an attacker. The subject is structured as follows:\n\n<ip in dotquad>|<domain>|<os version>|<username>|<password>|<response code from the infection \nattempt>|<flags>\n\nThe <flags> field, as in SierraBravo-One, provides details about the status of the infection (bit 0) and if Windows Terminal \nServices are accessible via port 3389 (bit 4).\n\n62\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\f16. [Spreader] SierraCharlie\n\nSierraCharlie is a spreader that appears to target RDP as its vector for propagation. Novetta has not spent a significant \namount of time investigating the SierraCharlie family before publication, but the following characteristics of the malware \nfamily are known:\n\n1.  The random IP generation code found in both SierraJuliett-MikeOne and SierraBravo can be found within \n\nSierraCharlie\n\n2.  SierraCharlie, structurally speaking, is heavily object oriented (C++)\n\n3.  The suicide script within SierraCharlie is consistent with other Lazarus Group malware families\n\n4.  The propagation mechanism appears to focus on RDP\n\n5.  At least one sample identifies the malware\u2019s program name as \u201cRDPBForce\u201d\n\n6.  At least two samples have two distinct version information entries with in the resource section with one entry in \n\nEnglish and the other in Korean.\n\n63\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\f17. [P2P Staging] SierraJuliett-MikeOne (Joanap Mk I.)\n\nCommonly known as Joanap, SierraJuliett-MikeOne is a peer-to-peer (P2P) malware family that gives the Lazarus \nGroup the ability to rapidly establish a common program base across all infected machines as well as provide remote \nadministration functionality on each individual infection. SierraJuliett-MikeOne (SJM1) is the older sibling of \nSierraJuliett-MikeTwo (SJM2) (see Section 18). While both SJM1 and SJM2 perform essentially the same function and follow \nroughly the same communication protocols, the two do not constitute variants of one another in the sense that the term \nvariant has been established in this report. SJM1 and SJM2 have clearly different code bases, indicating they were most \nlikely developed independently of one another but based on a common design specification. It is the clear distinction \nbetween the two code bases that necessitates they fall into different families. \n\nThe samples within the SJM1 family are largely homogenous with each consecutive sample (based on compile time) having \nan average similarity 98.7% to its neighboring sample. Installed typically by IndiaJuliett, SJM1 operates as a svchost-\ndependent service DLL. The ServiceMain export does little more than provide the necessary scaffolding for SJM1 \nto appear to be an active service. The core of SJM1 is activated when the DLL is loaded by svchost and calls DllMain. \nDllMain spins the core of SJM1 off into its own thread. Some later samples of SJM1 place an intermediate piece of code \nbetween the DllMain and the core by having the newly generated thread call a function to call DialogBoxParamA \nwith the lpDialogFunc ultimately calling the core of SJM1. It is unclear why this small variation was introduced as it \nseems to serve no real purpose.\n\nThe core of SJM1 consists of three functions as Figure 17-1 illustrates. The first function initializes the SJM1 system. The \ninitialization function begins by performing dynamic API loading. The dynamic API loading functions within SJM1 use \nan AES implementation to decrypt the names of the API functions to load via GetProcAddress. The AES implementation, \nCRijndael, is a direct lift from a CodeProject project by George Anescu that he published in November, 2002.9 The same \ndynamic API loading functions for the API functions from kernel32.dll, psapi.dll, and ws2_32.dll used by \nSJM1 can be found in RomeoFoxtrot (see Section 8) albeit with different AES keys. A strange feature of these dynamic API \nloading functions, in both SJM1 and RomeoFoxtrot, is that all but the ws2_32.dll functions use the same AES key, but \nfor some reason the Winsock API loading code uses a different key.\n\nvoid SierraRomeoMikeOneCore()\n{\n  if ( Initialize() )\n  {\n    if ( StartIncomingClientsHandler(0) )\n      StartP2PClientThread(0);\n  }\n}\n\nFigure 17-1: SierraJuliett-MikeOne\u2019s Core\n\n9 \n\n George Anescu. CodeProject. \u201cA C++ Implementation of the Rijndael Encryption/Decryption method\u201d. http://www.codeproject.com/Articles/1380/A-C-Implementation-of-the-Rijndael-Encryption-Decr 8 Nov 2002.\n\n64\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\fThe Initialize function loads the current configuration file into memory from %SYSDIR%\\mssscardprv.ax. The \nconfiguration file contains a 1346-byte structure that contains the basic configuration information for SJM1 as well as the \nseed list of known peer nodes. Table 17-1 details the structure of the configuration data. The node type field (offset 0) is \ninitially set to 0x1000101 during the initialization phase of SJM1. \n\nOFFSET\n\nSIZE\n\nFIELD DESCRIPTION\n\n0\n\n4\n\n8\n\n24\n\n30\n\n32\n\n36\n\n38\n\n168\n\n888\n\n1148\n\n1212\n\n4 Bytes (DWORD)\n\nNode type\n\n4 Bytes (DWORD)\n\nIP address of the first NIC of the victim\u2019s system\n\n16 Bytes (SYSTEMTIME \nstructure)\n\nInternal timestamp of the configuration data\n\n6 Bytes\n\nMAC Address of the first NIC of the victim\u2019s system\n\n2 Bytes (WORD)\n\nChecksum/hash of CPU\u2019s ID value\n\n4 Bytes (DWORD)\n\nLast command ID number\n\n2 Bytes (WORD)\n\nListening port number\n\n130 Bytes\n\nActor\u2019s remarks/Campaign ID\n\n720 Bytes (30 NodeInfo \nstructure array)\n\nList of seed/known peer nodes (see Table 17-2 for details of the structure)\n\n260 Bytes\n\n64 Bytes\n\n64 Bytes\n\n1276\n\n64 Bytes\n\nUnknown string\n\nUnknown string\n\nUnknown string\n\nUnknown string\n\n1340\n\n4 Bytes (DWORD)\n\nZero if the SJM1 node is known to be behind a NAT and non-routable from the \nInternet\n\n1344\n\n2 Bytes (WORD)\n\nCounter indicating the number of times the node has connected to peers\n\nTable 17-1: Configuration Data Structure of SierraJuliett-MikeOne\n\nIf the listening port field (offset 36) is set to 0, SJM1 will attempt to determine a valid listening port on the victim\u2019s host. \nThe process for determining a listening consist of the following steps:\n\n1.  Using a list of preferred listening ports, attempt to bind the port\n\n2.  If the bind is successful, close the socket and return the port number, otherwise try the next preferred listening port \n\nuntil the list is exhausted or a viable port is found\n\n3.  If the preferred listening port list is exhausted, attempt to find an available port, using the same method in steps 1 \n\nand 2 above, for all ports between 1024 and 2047, inclusive. \n\nSJM1 has a list of 26 preferred listening ports. The list begins with more commonly found ports such as HTTPS, POP3, \nDNS, and HTTP and tappers off to more obscure ports. The preferred listening port list is, in order of preference:\n\n443, 110, 53, 80, 995, 25, 8080, 1816, 465, 1521, 3306, 1433, 3128, 109, 161, 444, 1080, 520, \n700, 1293, 1337, 2710, 3100, 3305, 3689, 11371\n\nWith SJM1 initialized, the malware calls the StartIncomingClientsHandler function to establish the server side \ncomponent of the P2P bot. The StartIncomingClientsHandler function begins by establishing a listening socket \n\n65\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\fon the configured listening port before spawning a thread to handle incoming connections from peer nodes. Section 17.1 \nexplains the operations of the server mode thread. \n\nAfter StartIncomingClientsHandler returns, SJM1\u2019s core calls the function StartP2PClientThread to activate \nthe client mode thread. After activating the client mode thread, StartP2PClientThread returns control to the core \nwhich in turn returns control to the loading application, in this case svchost. At this point, the SJM1 malware is running in \ntwo asynchronous threads so the service scaffolding of SJM1 is allowed to run by the Windows Services system.\n\n17.1 Server Mode Thread\n\nThe service mode thread is an infinite loop that waits for incoming connections on the listening port and spawns a new \nthread to handle any connection. When a new peer node connects to another SJM1 node, an authentication phase begins. \nThe authentication between two SJM1 nodes begins by the connecting node (the client, in this case) transmitting a 4-byte \n(DWORD) value to the receiving node (the server). The value that the client sends to the server indicates the general class \nof node the client is: standard node (0x1000) or a super-node (0x1000000). The authentication changes depending on the \ntype of node connecting. \n\nA super-node transmits another 4-byte (DWORD) value that specifies the size of the next transmission. The next \ntransmission contains a buffer of data that has been encrypted by the super-node\u2019s private key. SJM1 decrypts the data \nusing a hardcoded public key found within the SJM1\u2019s .data section and the RSATransform function found in other \nLazarus Group families. A standard node, on the other hand, will simply transmit a 16-byte buffer of random bytes to the \nserver node. Both a super-node and a standard node will perform the initial data transmissions in cleartext. \n\nRegardless of the type of node attempting to authentication, the server node echoes back to the client the data the client \nsent to the server, with the exception that, in the case of a super-node, the data is now decrypted using the RSA transform. \nWhen the server sends the data to the client, the data is encrypted using RC4. For each buffer that SJM1 sends (in both \nserver mode and client mode), the data is encrypted with RC4 using the key in Figure 17-2.\n\n0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80, 0x90, 0x11, 0x12, 0x13, 0x1A, 0xFF, 0xEE, 0x48\n\nFigure 17-2: SierraJuliett-MikeOne\u2019s RC4 Key\n\nThe Sbox within the RC4 implementation is reset after each buffer meaning that data boundaries are critical to avoid \ncorrupting the data stream. It also means that particularly short bursts of data are going to retain discernable patterns as \nthey traverse the network. \n\nThe client will then transmit a 30-byte string to the server (over the encrypted channel) if the server\u2019s response was \ncorrect. The server compares the 30-byte string with the hardcoded string https://www.google.com/index.h and if \nthe two strings are identical, the authentication completes successfully. A misstep in any of the authentication steps will \nresult in the authentication failing and the channel being closed by the server. \n\nWhile the client can identify as a super-node, there is no advantage to do so as SJM1 do not grant additional access \nor privileges to any node that authenticates as a super-node. The authentication process, from the perspective of the \nnode in the server role, is purely a binary output: successful or unsuccessful. The authentication process does, however, \nensure that both sides of the conversation have the same communication key for the RC4 encryption and that both sides \nunderstand the basic protocol for communication. After the authentication sequence completes, all communications \nbetween the two nodes uses the RC4 encryption for data that traverses the network between them.\n\nFollow the authentication phase, the server mode expects the client to send a 2-byte (WORD) value that specifies the \nparticular channel the client wishes to access. SJM1 supports three different channels: crawler (0x2000), RAT (0x4000), \nsync (0x8000). \n\n66\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\f17.1.1 Crawler Channel\n\nThe crawler channel allows one node to quickly determine the node list of another node. By accessing the peer list of \na node, it is a simple process to enumerate all of the connected nodes of the SJM1 network that have Internet-facing, \nroutable interfaces. \n\nThe client node transmits a 6-byte data structure to the server node. The data structure consists of a 4-byte (DWORD) \nvalue specifying if the client node knows it is not behind a NAT device and thus Internet accessible followed by a 2-byte \n(WORD) value the defines the client\u2019s own listening port number. If the value specifying if the client is accessible from \nthe Internet is 0, the server will attempt to connect to the client on the specified listening port. This allows the server to \ninform the client if it is behind a non-routable NAT device. The routability test begins by attempting to connect to the \nclient node on the specified listening port and then performing the authentication phase if the connection is successful. \nIf both of those events occur, then the client node is considerable routable, otherwise the node is considered inaccessible. \nThe status of the test is transmitted to the client over the original channel (which the client initiated) in the form of a \n4-byte (DWORD) value of either 1 (routable) or 0 (non-routable). If the routability test fails, it is repeated two more times. \nGiven that the routability test waits up to 30 seconds per test for a connection to the client node to succeed or timeout, a \nfull minute and a half may expire from the time the crawler channel is activated and the routability test completes.\n\nSJM1 maintains three lists of NodeInfo entries: a list of seed nodes (from the configuration file), a list of known nodes that \nthe SJM1 has either connected to or received from another node who connected to, and a list of client nodes that connected \nto the SJM1 node. The seed nodes list is limited to 30 NodeInfo entries, the known nodes list has a limit of 50 NodeInfo \nentries, and the list of client nodes that have connected to the SJM1 node has a maximum of 100 NodeInfo entries. \n\nA NodeInfo structure contains information about a particular node as Table 17-2 illustrates. The most important fields \nwithin the structure are the IP address of the node, the port upon which the node listens for incoming connections \nand the timestamp of the last time a node successfully connected to the node. The timestamp is recorded in the \nVARIANTTIME format which is essentially a floating point number (a double) that defines the number of days (the \ninteger value) and partial days (the decimal value) since December 30, 1899 at midnight.10 A value of 2.5 for instance, \nrepresents January 1, 1900 at noon.\n\nOFFSET\n\nSIZE\n\nFIELD DESCRIPTION\n\n0\n\n4\n\n6\n\n8\n\n12\n\n16\n\n4 Bytes (DWORD)\n\nIP address of node\n\n2 Bytes (WORD)\n\nListening port of node\n\n2 Bytes\n\n4 Bytes (DWORD)\n\n4 Bytes (DWORD)\n\nUnused\n\nTracking field 1\n\nTracking field 2\n\n8 Bytes (VARIANTTIME)\n\nTimestamp of the last time the node was contacted\n\nTable 17-2: SierraJuliett-MikeOne\u2019s NodeInfo Data Structure\n\nAt the completion of the routability test, the server node transmits it current time, in the VARIANTTIME format to the \nclient followed by the full array of 50 known nodes\u2019s NodeInfo entries. In order to prevent loops where a node connects \nback to itself, prior to transmitting the known nodes entries the server node removes any NodeInfo entry for the client \nnode and replace the removed NodeInfo with an empty (all zeros) entry.\n\n10 \n\n Microsoft. \u201cSystemTimeToVariantTime function\u201d https://msdn.microsoft.com/en-us/library/windows/desktop/ms221646(v=vs.85).aspx Accessed 7 December 2015.\n\n67\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\fAfter the server transmits the known nodes entries, the server again attempts to connect back to the client and \nauthentication in order to determine if the client has a routable interface. If the server is successful in the connect back, \nthe node is added to the list of known nodes if it does not already exist or, if the client is already in the known nodes list, \nits last contact time (field 16 of NodeInfo) is updated to reflect the current time. The process of adding or updating the \nclient node\u2019s entry is repeated for the seed nodes list. \n\nThe server shuts down the channel and disconnect from the socket before terminating the thread handling the client\u2019s \nconnection. Visually, the crawler channel\u2019s communication is illustrated by Figure 17-3. In the illustration the gray arrows \nrepresent the client initiated socket and the direction of communication for each step while the red arrows represent the \nserver initiated connection back to the client during the routability test. \n\nClient Node\n\nServer Node\n\nAuthentication\n\nCrawler Channel Request (0x2000)\n\n{Behind NAT Status, Listening Port}\n\nAuthentication (Server Initiated, New Socket)\n\nUp to 3 Times\n\nRoutability Results (DWORD)\n\nNode\u2019s Current Time (VARIANTTIME)\n\nNode\u2019s \u201cKnown Nodes\u201d List\n\nFigure 17-3: Crawler Channel Communication Sequence\n\n17.1.2 RAT Channel\n\nThe RAT channel provides, as the name would imply, RAT capability to the SJM1 family. Unauthenticated outside of the \ninitial handshake between two nodes, the RAT channel support 21 different commands ranging from file management to \ndata exfiltration to process management to node management.\n\nOnce a client requests the RAT channel, the client must send a datagram specifying the command and arguments (if \nany) for the command. Datagrams, in the context of SJM1, are variable sized data structures that specify a data type (or \ncommand type) followed by optional unstructured data specific to the data type specified. The datagram structure (Table \n17-3) dictates that at a minimum a datagram is 6 bytes in size on the network. \n\nOFFSET\n\nSIZE\n\nFIELD DESCRIPTION\n\n0\n\n4\n\n6\n\n4 Bytes (DWORD)\n\nSize of the data transmission to follow\n\n2 Bytes (WORD)\n\nData type\n\nVariable\n\nOptional payload data\n\nTable 17-3: SierraJuliett-MikeOne\u2019s Datagram Structure\n\n68\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\fThe transmission of a datagram is always a two-step process. SJM1 transmits the 4-byte size value first then transmits \nthe remainder of the datagram. This is important to understand because, as mentioned previously, the RC4 encryption \nis reset after each transmission meaning that same sized datagrams, but potentially with different data types and data \npayloads, will always send the same 4-byte initial transmission. \n\nThe RAT channel uses the data type field (offset 4) of the datagram as the command type the client is requesting. If the \ncommand type is a recognized value, the appropriate command function is called and, if required, the payload data is \npassed to the function. Table 17-4 lists the supported command types and their descriptions.\n\nCOMMAND NUMBER\n\nDESCRIPTION\n\n0x4001\n\n0x4002\n\n0x4003\n\n0x4004\n\n0x4005\n\n0x4006\n\nEcho. Receives another datagram from client then returns the same datagram to the client with the \nsize field set to 512 bytes before sleeping for 1 second. \n\nRetrieves the client list and known nodes list.\n\nSends Client Information. Sends the node\u2019s ClientInfo and ClientInfoEx data in \nindividual datagrams.\n\nAttempts to connect to the specified endpoint. The first 4-bytes (DWORD) of the payload data \nspecifies the IP address of the end point with the next 2-bytes (WORD) specifying the port number. \nIf successful, return a datagram with the data type (offset 4) set to 1, otherwise the data type is set \nto 0 indicating the end point was unreachable. \n\nUploads a local file to the client. The payload data contains the full name and path of the file to \ntransfer to the client. \n\nDownloads a file from the client node. The payload data contains the destination filename and path \nstarting at offset 3. Offset 1 of the payload data, if set, indicates if the file should be deleted if the \ndownload fails. The timestamp of the downloaded file is set to random date with the year set to 2 \nyears prior to the current year.\n\n0x4007\n\nNOP\n\n0x4008\n\n0x4009\n\n0x400A\n\n0x400B\n\n0x400C\n\n0x400D\n\n0x400E\n\n0x400F\n\n0x4010\n\n0x4011\n\n0x4012\n\n0x4013\n\n0x4014\n\n0x4015\n\nDownloads a file from the client, executes the file, then deletes it. The filename is randomly \ngenerated as rundll{random number}.exe and given a random dates set two years prior to the \ncurrent year.\n\nNOP\n\nStarts a process. The payload data contains the full command line to execute.\n\nSet the actor\u2019s remarks/campaign ID (offset 28) within the configuration data structure. The \npayload data contains the value for the field.\n\nDeletes a file or directory (if the name specified is a directory). The payload data contains a string \nspecifying the full name and path to the file or directory to delete.\n\nMove (or rename) file. The datagram\u2019s payload data for the command contains two null terminated \nstrings with the first specifying the source file\u2019s name and full path and the second string the new \nname and full path of the file.\n\nCreates a directory. The datagram\u2019s payload data contains a string specifying the full pathname of \nthe new directory\n\nTerminates process by name. The datagram\u2019s payload data contains a string specifying the name \nof the process to terminate.\n\nResets the last command ID to 0\n\nDeletes all command files under the %SYSDIR%\\1008 directory. \nReplaces the first NodeInfo entry in the seed node list. The payload data contains first 16-bytes \nof the new NodeInfo structure.\nSets three configuration values (offsets 888, 1148, and 1212). The payload data of the datagram \nconsists of three NULL-terminated strings, one for each value.\n\nVariation on command 0x4002.\n\nPushes a command to all neighboring nodes.\n\nTable 17-4: RAT Commands and Their Command Type Values Supported by SierraJuliett-MikeOne\n\n69\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\fAfter the RAT channel processes the requested command, SJM1 terminates the connection between the client node and \nitself. Therefore, each time an attacker wishes to issue a command against a SJM1 node, the attacker much reconnect to \nthe node.\n\nThe inclusion of the RAT channel is somewhat unusual for several reasons. First, the channel is unauthenticated while, \nas presented in the sync channel discussion, there is a heavy use of asymmetric encryption to ensure command files are \nlegitimate and only producible by the Lazarus Group attackers. Secondly, the construction of the RAT channel appears \nalmost as if it were an afterthought of the developer(s) given that it requires constant reconnections to a node to issue \nmultiple commands. Lastly, the RAT channel is single node focused, while the rest of the functionality of SJM1 is geared \ntoward a hive or collective.\n\n17.1.3 Sync Channel\n\nThe crawler channel and sync channel share the same handler function with the crawler channel being the basis for the \nsync channel\u2019s operations. More to the point, the entirety of the crawler channel\u2019s events occurs as a precursor to the sync \nchannel specific operations. Therefore, immediately following the transfer of the known nodes list to the client from the \nserver and the updating of the appropriate NodeInfo entries in the known nodes and seed nodes lists, the sync channel \nadds to or updates the client to the client nodes list.\n\nThe client sends two datagrams containing information about the client node to the server. The first datagram contains a \nClientInfo data structure (see Table 17-8) describing aspects of the client node related to its basic properties such as IP \naddress and listening port as well as its type. The second datagram contains a ClientInfoEx data structure (see Table \n17-9) that describes hardware and operating system level aspects of the node such as the OS version information, CPU \ndetails, and if particular ports of interest are open, among other details. If the size of the two datagram payloads matches \ntheir respective data structure sizes, the data structures are joined into a single data structure and stored within the list of \nclient nodes. If, however, the size of the ClientInfo data structure is incorrect, the ClientInfoEx transfer is aborted \nby the server node.\n\nThe client node and the server node now begin the process of the client node synchronizing its command files. Command \nfiles are specifically formatted data files that SJM1 uses to transfer commands from node to node. The structure of a \ncommand file (Table 17-5) consists of a RSA encrypted header, the command\u2019s data and its associated header in a cleartext \nheader, and an optional encrypted data blob containing the information necessary to verify the integrity of the entire \ncommand file. \n\nOFFSET\n\nSIZE\n\nFIELD DESCRIPTION\n\n0\n\n128\n\n128 Bytes\n\nEncrypted Command File Header (see Table 17-6)\n\nVariable but at least 4 Bytes (m)\n\nData header (see Table 17-7)\n\nm+4\n\n4 Bytes (DWORD)\n\nSize of data field\n\nm+132\n\nVariable (n)\n\nData\n\nm+n+132\n\n128 Bytes\n\n(Optional) encrypted verification data\n\nTable 17-5: SierraJuliett-MikeOne\u2019s Command File Structure\n\nThe first 128 bytes of a command file are encrypted using a private RSA key that presumably only belongs to the Lazarus \nGroup, as the key has not been found disclosed publicly. Underneath the RSA encryption lies the command file header \n(see Table 17-6) which species the type of command, an identifier for the command, the data/parameters of the command \nand the size of that data along with its header, and, optionally, the necessary information to verify the integrity of the \nentire command file along with the command\u2019s data and the data\u2019s associated header. The command ID field (offset 4) \nis particularly important as it allows SJM1 nodes to quickly determine if a particular command file has previously been \nexecuted based on a running counter of the last command ID executed (offset 32 of the node\u2019s configuration data structure). \n\n70\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\fOFFSET\n\nSIZE\n\nFIELD DESCRIPTION\n\n0\n\n4\n\n8\n\n10\n\n12\n\n4 Bytes (DWORD)\n\n4 Bytes (DWORD)\n\nMagic value (0xB4F4)\nCommand ID\n\n2 Bytes (WORD)\n\nCommand type\n\n2 Bytes (WORD)\n\nVerify file flag\n\n4 Bytes (DWORD)\n\nData header size\n\nTable 17-6: SierraJuliett-MikeOne\u2019s Command File Header\n\nInterestingly, the data header, the size of the data portion, and the data portions of the command file are in cleartext. The \ndata header contains three byte fields followed by an optional NULL-terminated string. The data that follows the data \nheader contains the command specific data and varies in structure based on the command type.\n\nOFFSET\n\nSIZE\n\nFIELD DESCRIPTION\n\n0\n\n1\n\n2\n\n3\n\n1 Byte\n\n1 Byte\n\n1 Byte\n\nVariable (NULL-terminated string)\n\nUnknown field, seemingly unused\n\nActivate command for node types less than 0x1000000\nActivate command for node types greater than or equal to 0x1000000\nParameter string for command\n\nTable 17-7: SierraJuliett-MikeOne\u2019s Command File\u2019s Data Header\n\nIf the verify file flag (offset 10 of the command file header) is non-zero, the last 128 bytes of the command file contains \nanother RSA private key encrypted data blob containing the MD5 hash of all of the bytes in the command up to, but not \nincluding, the last 128 bytes, which the client node can use to verify the integrity of the command file upon reception.\n\nTo perform the synchronization of command files from the server node to the client node, the client node transmits a \n4-byte (DWORD) value to the server node representing the last command ID that the client executed. The server node \nresponds with a 4-byte (DWORD) value containing its last command ID executed. The server node then enters a loop \npunctuated by calls to FindFirstFile/FindNextFile in order to enumerate all of the server\u2019s stored command files \nfrom the %SYSDIR%\\1008 directory. \n\nFor each command file that the server node finds, the server node decrypts the command file\u2019s header, verifies that the \ndecryption was successful by ensuring that offset 0 of the command file header is equal to 0xB4F4, and then compares \nthe command ID (offset 4) against the client\u2019s last command ID. For any file that successfully decodes and has a value \ngreater than the last command ID reported by the client node, the server node sends a 4-byte value (DWORD) of \n0x00000010 to the client to indicate that a command file is inbound. The server then sends the command file to the \nclient using a sequence of datagrams. The protocol for sending a file to or from a node is as follows:\n\n1.  Transmit the entirety of the file in sequence of 4KB datagrams with the data type field set to 0x1111\n2.  Conclude the transfer by sending a datagram with the data type field set to 0xFFFF.\n\nOnce all necessary command files, if any, have been sent to the client, the server terminates the synchronization operation \nby transmitting 4-bytes (DWORD) of 0x00000002 to the client, and the client acknowledges the synchronizations \nconclusion by replying with 4-bytes (DWORD) of 0x00000001. The server node terminates the communication channel \nwith the client. \n\nVisually, the sequence of events that make up the sync channel operations as viewed from the network perspective is \nillustrated in Figure 17-4.\n\n71\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\fClient Node\n\nServer Node\n\nCrawler Channel Activities\n\nSystemInfo Datagram\n\nSystemInfoEx Datagram\n\nClient\u2019s Last Command ID (DWORD)\n\nServer\u2019s Last Command ID (DWORD)\n\nIncoming File Tag (0x00000010)\n\nCommand File Datagram\n\nIncoming File Tag (0x00000010)\n\nEnd of Command Files Tag (0x00000002)\n\nBACK to End of Command Files (0x00000001)\n\nFigure 17-4: Sync Channel Communication Activities\n\ne\n\nl\ni\nf\nd\nn\na\nm\nm\no\nc\nr\ne\np\ne\nc\nn\nO\n\n72\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report \n \n \n\f17.2 Client Mode Thread\n\nThe client mode thread, as one would expect, is largely the reciprocal of the server mode thread. Effectively an endless \nloop of constantly connection to neighboring nodes, the client mode thread is responsible for synchronizing command \nfiles from the larger SJM1 botnet along with ensuring that the commands are bring properly executed. \n\nThe top of the endless loop begins with the client mode thread attempting to connect to a peer node. The client mode \nthread randomly selects a node from the seed nodes list and attempts to connect to the selected peer. If the connection is \nunsuccessful, a node from the known nodes list is randomly selected, and a connection is attempted. In the event that the \nconnection is also unsuccessful, the client mode thread sleeps for one minute before repeating the process again.\n\nWhen the client mode thread (in this context, making the SJM1 node the client node) attempts to locate a remote peer, it \ndoes so by connecting to the node to determine the validity of the IP and port information, as it immediately terminates \nthe connection if the connection is successful. Only after a node is validated as having an open port at the specified port \nnumber does the client node attempt to establish a lasting connection to the peer node. Once a connection has been \nestablished, the client initiates the authentication handshake. If the handshake fails, the connection is terminated, and \ncontrol returns to the top of the endless loop in order to find a new peer node.\n\nAfter the connection and authentication phase concludes, the client mode thread selects the appropriate channel based on \nits node type. If the node type, specified in the configuration file at offset 0, is greater than or equal to 0x1000000, then \nthe crawl channel (0x2000) is selected, and the node\u2019s node type is set to 0x1000101. If the node\u2019s node type is less than \n0x1000000, the client node requests the sync channel. \n\nThe node type is adjusted periodically throughout the life span of a SJM1 node. Upon activation, the Initialize \nfunction specifies that the node\u2019s node type is 0x1000101. As will be described later in this section, if during the \nroutability testing the peer node indicates that the client node is Internet-accessible, the node type is upgraded to \n0x101. While other values for the node type have been observed in the wild (most likely due to researchers attempting to \ndistinguish themselves from legitimate SJM1 nodes), the SJM1 code supports only two node types:\n\n\u2022  0x101 for Internet-accessible (routable) nodes\n\u2022  0x1000101 for NAT\u2019d (non-routable) nodes\n\nSince sync channel is built upon crawl channel, regardless of the node\u2019s node type, the client node enters into the \nroutability test as described previously in Section 17.1.1. From the client node\u2019s perspective, the routability test begins with \nthe client node transmitting a 6-byte data structure to the server node containing the 4-byte (DWORD) value and a 2-byte \n(WORD) value. The 4-byte value specifies if the client node knows it is behind a NAT device and thus non-routable, and \nthe 2-byte value defines the client node\u2019s listening port number. If the client node has already identified it is not NAT\u2019d \n(offset 1340 of the configuration file is non-zero), the routability test phase concludes. Otherwise, the client node waits for \nthe peer node to send a 4-byte (DWORD) value indicating if the client node\u2019s listening port is Internet-accessible or not. \nThe response from the peer is recorded directly into the configuration file (at offset 1340). \n\nIn the event that the peer node indicates that the client node\u2019s listening port is inaccessible, the client node terminates \nits server mode thread by shutting down its listening port, randomly selects a new listening port, and starts a new server \nmode thread. With a new server mode thread and listening port, the client node performs the routability test again. The \nprocess of shutting down the server mode thread and generating a new listening port can occur twice before the client \nnode concedes that it is inaccessible. \n\nThe results of the routability test may result in the node changing its node type. If a node is non-routable, its node type is \nset to 0x1000101, otherwise the node\u2019s node type is adjusted to 0x101. After the routability test, the client node resets \nits routability status value (offset 1340 in the configuration file) back to 0, thereby forcing the routability test to commence \neach and every time it connects to a new peer node.\n\n73\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\fThe client node receives the peer\u2019s current time as an 8-byte value (a double) followed immediately by the peer\u2019s \n50 known nodes list. The client node then calculates the difference between its local time and the server\u2019s in order to \ndetermine the bias that must be applied when determining the age of any of the nodes the peer transmitted. Since the \npeer did successfully provide information, the peer is deemed a viable peer node to add to the client node\u2019s seed list if it was \nnot there already by replacing the oldest node within the list. If the peer node is already within the client node\u2019s seed list, \nthe last contact time is updated, thereby refreshing the node.\n\nThe client node scans the 50 nodes received from the peer node to determine which, if any, are newer than the client \nnode\u2019s own seed list nodes. Each node has its timestamp recalculated by applying the bias value before determining if the \noldest node within the client\u2019s seed list is newer than the received node. Should it turn out that the node is newer, the seed \nlist node is replaced. The process repeats for each of the 50 nodes. It is therefore entirely possible for a client node to have \nall but one of its seed list entries replaced in full by a peer\u2019s node list if the client node had lost contact with the SJM1 botnet \nfor a long enough period of time.\n\nIf the client node opens the sync channel instead of the crawl channel, the client node constructs and then transmits \nto the peer node via datagrams both the ClientInfo and ClientInfoEx data structures. The ClientInfo data \nstructure, as defined in Table 17-8, is the product of the client mode thread merging components of the configuration data \nstructure into the ClientInfo form. \n\nOFFSET\n\nSIZE\n\nFIELD DESCRIPTION\n\n0\n\n4\n\n6\n\n8\n\n12\n\n16\n\n20\n\n24\n\n30\n\n32\n\n48\n\n4 Bytes (DWORD)\n\n2 Bytes (WORD)\n\n2 Bytes\n\n4 Bytes (DWORD)\n\n4 Bytes (DWORD)\n\n4 Bytes (DWORD)\n\n4 Bytes\n\n6 Bytes\n\n2 Bytes\n\nIP address of node\n\nListening port of node\n\nUnused\n\nNode\u2019s tracking field 1\n\nNode\u2019s tracking field 2\n\nNode\u2019s type\n\nUnused\n\nMAC address\n\nUnused\n\n16 Bytes (SYSTEMTIME structure)\n\nNode\u2019s activation time\n\n128 Bytes\n\nNode\u2019s actor remarks/campaign ID\n\nTable 17-8: SierraJuliett-MikeOne\u2019s ClientInfo Data Structure\n\nThe ClientInfoEx data structure, Table 17-9, requires more processing to produce than its smaller sibling. The client \nmode thread leverages both Windows API functions such as GetLocaleInfo, GetVersionEx, GetComputerName, \nand GetDiskFreeSpaceEx as well as processor level instructions such as cpuid in order to construct the \nClientInfoEx information. The interesting ports field (offset 280) is the product of determining if specific ports are \nlistening for connections on the local machine, but not as a result of the SJM1 node listening on a given port. For example, \nif port 80 responds to a connect request, the interesting ports bitmask is set to indicate the port is listening. However, if \nthe SJM1 node is configured to listen on port 80, the bitmask field is not set. \n\n74\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\fOFFSET\n\nSIZE\n\nFIELD DESCRIPTION\n\n64 Bytes\n\n6 Bytes\n\n2 Bytes\n\n64 Bytes\n\n16 Bytes\n\n4 Bytes (DWORD)\n\n4 Bytes (DWORD)\n\n4 Bytes (DWORD)\n\n4 Bytes (DWORD)\n\n4 Bytes (DWORD)\n\n4 Bytes (DWORD)\n\n64 Bytes\n\n4 Bytes (DWORD)\n\n4 Bytes (DWORD)\n\n4 Bytes (DWORD)\n\n4 Bytes (DWORD)\n\nComputer name\n\nMAC address\n\nUnused\n\nCPU brand (reported by CPUID)\n\nCPU\u2019s vendor ID (reported by CPUID)\n\nCPU\u2019s model and stepping (reported by CPUID)\n\nCPU\u2019s features bitmask (reported by CPUID)\n\nCPU\u2019s signature\n\nNumber of processors\n\nCPU\u2019s type\n\nCPU\u2019s clock speed\n\nComputer\u2019s locale string\n\nOS\u2019s major version\n\nOS\u2019s minor version\n\nOS\u2019s build number\n\nOS\u2019s platform ID\n\n16 Bytes (SYSTEMTIME structure)\n\nComputer\u2019s uptime\n\n0\n\n64\n\n70\n\n72\n\n136\n\n152\n\n156\n\n160\n\n164\n\n168\n\n172\n\n176\n\n240\n\n244\n\n248\n\n252\n\n256\n\n272\n\n8 Bytes (QWORD)\n\n280\n\n1 Byte\n\nTotal number of free bytes on the computer\u2019s %WINDIR% hard drive\nBitmask of interesting ports in use \n0x01 \u2013 Port 80 \n0x02 \u2013 Port 3389 \n0x04 \u2013 Port 443\n\n281\n\n282\n\n284\n\n286\n\n318\n\n1 Byte\n\n2 Bytes\n\n2 Bytes\n\nUnused\n\nNumber of users on the computer in an idle state\n\nNumber of logged in users on the computer\n\n32 Bytes (16 WORDs)\n\nArray of terminal server sessions\u2019 connection states. \n\n2 Bytes\n\nUnused\n\nTable 17-9: SierraJuliett-MikeOne\u2019s ClientInfoEx Data Structure\n\nThe synchronization process begins by the client node sending its last command ID to the peer node and then receiving \nthe peer node\u2019s last command ID. If the peer node has a last command ID that is larger than the client node\u2019s, the client \nnode expects to receive an unknown number of command files from the peer as described previously in Section 17.1.3. \nImmediately prior to beginning the command file transfer, the client mode thread changes the last command ID in the \nnode\u2019s configuration to match the value specified by the peer node.\n\nFor each command file the client node receives, the client mode thread saves the command file to the %SYSDIR%\\1008 \ndirectory with a filename taking the pattern reg{4 digit value} before parsing the contents of the file. While the order of \nthe command IDs received by a node is indeterminate, the naming scheming has a definite order with each received file \nbeing stored with a file name one digit higher than the previous file. The timestamp of command files, when saved to disk, \nis set to a random date within 1 to 4 years from the current year.\n\n75\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\fThe client mode thread begins the process of parsing a command file immediately after the file is saved to the node\u2019s hard \ndrive. The encrypted command header (offset 0) is read into memory and decrypted using the public RSA key hard coded \nwithin the SJM1 binary. To verify successful decryption, the first field of the decrypted header (offset 0) is compared to \n0xB4F4. A memory buffer of the size specified by the data header size value (offset 12) is allocated and the contents of the \ndata header are read into memory. SJM1 has the capability to selectively run commands based on the node type value. \nOffsets 1 and 2 within the data header specify the node types that will execute the given command within the command \nfile. If the data header specifies that the node\u2019s node type is not to execute the command, the processing of the command \nfile concludes, and the next file, if any, is loaded and parsed. \n\nThe data portion of the command file, if the command type is not 0x4006, is saved to disk within the %SYSDIR%\\1008 \ndirectory with a name of the form rundll{4 digit value}.exe. If the verify file flag (field 10 of the command header) is set, \nthe client thread reads all but the last 128 bytes of the command file into memory, performs a MD5 hash of the content, \ndecrypts the last 128 bytes of the command file to reveal the expected MD5 hash, and then compares the hash values. If \nthey do not match, the command file is considered invalid, and parsing of the file terminates. The client mode thread then \nmoves to the next command file. The fact that invalid command files are not removed from the command file directory \nmeans that invalid command files propagate throughout the SJM1 botnet, potentially leaving a considerable amount of \nnoise. This behavior was observed when the SJM1 botnet was enumerated in June 2015 by Novetta. \n\nThe client mode thread supports only a subset of the commands found within the RAT channel, but the command \nnumbers are identical to the list found in Table 17-4. The client mode supports the commands in Table 17-10.\n\nCOMMAND NUMBER\n\nDESCRIPTION\n\n0x4006\n\n0x4007\n\n0x4008\n\n0x4009\n\n0x400A\n\n0x400B\n\n0x400C\n\n0x400D\n\n0x400E\n\n0x400F\n\n0x4010\n\n0x4011\n\n0x4012\n\n0x4013\n\nDownloads a file from the client node. \n\nNOP\n\nExecutes the file within the data field, then deletes it. \n\nNOP\n\nStarts a process.\n\nSet the actor\u2019s remarks/campaign ID (offset 28) within the configuration data structure. \n\nDeletes a file or directory (if the name specified is a directory). \n\nMoves (or renames) file. \n\nCreates a directory.\n\nTerminates process by name. \n\nResets the last command ID to 0\n\nDeletes all command files under the %SYSDIR%\\1008 directory. \nReplaces the first NodeInfo entry in the seed node list. \nSets three configuration values (offsets 888, 1148, and 1212). \n\nTable 17-10: Client Mode Thread Supported Command Types\n\nAfter the peer node transfers the last of the command files to the client node, the peer node sends a 4-byte (DWORD) \nvalue of 0x00000002 to the client node indicating the completion of the transfer. The client node only reads the \nlast byte (0x02) to determine if the transfer is complete but returns a 4-byte (DWORD) value of 0x00000001 as an \nacknowledgement of the completion of the transfer before disconnecting from the peer node.\n\nThere is no verification that a command\u2019s execution is successful. Coupled with the fact that the node\u2019s last command \nID is updated prior to receiving even the first command file from the peer node, this can lead to schisms within the SJM1 \n\n76\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\fbotnet. Take for example a new node joining the SJM1 botnet. A new node has a last command ID of 0. If the first peer that \nthe new node connects with were to have a last command ID of 65000, then the new node would immediately change its \nlast command ID to 65000 to match. If the transfer of command files is error-prone due to network instability and some \nor all of the command files fail to transfer correctly, the new node would still retain the last command ID value of 65000. \nGoing forward, when a node attempts to synchronize command files with the new node, the new node would report \n65000 as its last command ID but would provide an incomplete set of command files to the requesting node. This error \ncould therefore propagate unchecked throughout large sections of the SJM1 botnet.\n\nRegardless of the validity of command file transfer, once the client mode thread has disconnected from a peer, the thread \nenters a sleep period. The duration of the sleep varies depending on the number of times the client node has repeated the \nendless loop. The first 30 cycles through the loop will result in a sleep period of 30 minutes per cycle while any cycle after \nthe initial 30 will cause a 2-hour sleep.\n\n77\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\f17.3 Known SierraJuliett-MikeOne Command Files\n\nIn mid-2015, the SJM1 botnet was enumerated by Novetta to determine the current state of the command file distribution. \nThe SJM1 botnet appears to be fractured and in disrepair. A large number of nodes have incomplete command file sets, \nextremely old (greater than 90 days) NodeInfo entries, or multiple corrupt command files. No single node appeared to \nhave a complete set of command files. It was possible, however, to reconstruct the majority of the command file set by \nenumerating all command files from all nodes and identify unique, valid command files. All command files contained \ncommands to execute a file contained within their data section. Table 17-11 maps the command ID to the embedded \nexecutable found within the command file\u2019s data field. Table 17-12 maps the command ID to the compile date of and type \nof executable found within the data section.\n\nCOMMAND ID\n\nSHA256 HASH OF COMMAND FILE\u2019S DATA SECTION\n\n2\n\n10\n\n12\n\n200\n\n210\n\n300\n\n1000\n\n1010\n\n1050\n\n1100\n\n1200\n\n1205\n\n3000\n\n3500\n\n3501\n\n8000\n\n8050\n\n10000\n\n10000\n\n10000\n\n10001\n\n10010\n\n10010\n\n10011\n\n30000\n\n30001\n\n50000\n\n50001\n\n60000\n\n60001\n\n62001\n\n9b03695ca0945995ec6e2bc31662c08b0f499998dcbcd51701bf03add19f1000\n\ne8d1d9d6bb13a06fc893323a05063c868ba237b8729c120271384382eb60ed41\n\ne8d1d9d6bb13a06fc893323a05063c868ba237b8729c120271384382eb60ed41\n\n2e20410ce8369572beee811f1898f6bc5c6782083aa1cc8e6dacc07b3fd392c9\n\n3ee8fa11b85ec7a3e1f3cf3cee2553f795c56610091e373d4a7df344a66ae35d\n\n7c55af4675cf0a3d173cb4e1b9282425c6e00b6ccfad1a1bcb0fddf29631461e\n\n7c55af4675cf0a3d173cb4e1b9282425c6e00b6ccfad1a1bcb0fddf29631461e\n\n7c55af4675cf0a3d173cb4e1b9282425c6e00b6ccfad1a1bcb0fddf29631461e\n\n231af2bfa36b6b0d2e892fbba967062eb0b421ee4f7126709c51adb564d0c5a2\n\na64cb2496fb1ef1adf9b5473e664dc1d124634233dd76b4d8fb5aa8d970742b5\n\n191e14e54cae4b33c077065b782a7161f0fd807a550a98fd1dac2db2b622c94c\n\nf340bb3c2d175e027351319573ddc451b632defe9dc47bbc30eabf62f749fb46\n\nf340bb3c2d175e027351319573ddc451b632defe9dc47bbc30eabf62f749fb46\n\n1fd96cc95ec3f48e97cfcd08bb15d4dd30c11a5b582776dfa15f1a2e2b4ed94e\n\n1200c02da0d6505a841f140f6d1947f1ae43a13664ec65b356b273c75f42713b\n\n81c87a5a67963eab5193d342781e6b65604f7af74dd5cf7da960d20074da06b5\n\n2d8e052bb93839dffe77b45be4418f64eeae35a7470a3c20827bae914dc1c7e4\n\n6ce54331e126fd18c94e854a5e7fe3650a125cc83604f1a27a28f383e5193c07\n\nc1820cc86b5cca32d9b09a191a9461552f1f4477d427270e7440bd9d03737a64\n\nd88d27eb6cbc7da8d8c61f42756153f386c7edae7a45b77d7368bfbbf060eddf\n\n1dfe016ae106feb6112fd689faeaa1d61c19a911493a4201fb510551364f7247\n\n5ccfbeba9aa0f05d2dd4006afd7769f2e186dd321b521617a469936de89aa9a7\n\n1b78ffb5e6a6e3a98baf433d1932d8b3e4907acb1fd27501f799cb2966c1395e\n\n1b78ffb5e6a6e3a98baf433d1932d8b3e4907acb1fd27501f799cb2966c1395e\n\nd88d27eb6cbc7da8d8c61f42756153f386c7edae7a45b77d7368bfbbf060eddf\n\nd88d27eb6cbc7da8d8c61f42756153f386c7edae7a45b77d7368bfbbf060eddf\n\nd88d27eb6cbc7da8d8c61f42756153f386c7edae7a45b77d7368bfbbf060eddf\n\nd88d27eb6cbc7da8d8c61f42756153f386c7edae7a45b77d7368bfbbf060eddf\n\nd88d27eb6cbc7da8d8c61f42756153f386c7edae7a45b77d7368bfbbf060eddf\n\nd88d27eb6cbc7da8d8c61f42756153f386c7edae7a45b77d7368bfbbf060eddf\n\nd88d27eb6cbc7da8d8c61f42756153f386c7edae7a45b77d7368bfbbf060eddf\n\nTable 17-11: Command IDs and the SHA256 of Their Dropped Files\n\n78\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\fCOMMAND ID\n\nTYPE\n\nCOMPILATION DATE\n\nNOTES\n\n2\n\n10\n\n12\n\n200\n\n210\n\n300\n\n1000\n\n1010\n\n1050\n\n1100\n\n1200\n\n1205\n\n3000\n\n3500\n\n3501\n\n8000\n\n8050\n\n10000\n\n10000\n\n10000\n\n10001\n\n10010\n\n10010\n\n10011\n\n30000\n\n30001\n\n50000\n\n50001\n\n60000\n\n60001\n\n62001\n\nIndiaWhiskey\n\n7/29/2011 6:29\n\nIndiaJuliett\n\nIndiaJuliett\n\nIndiaJuliett\n\nIndiaJuliett\n\nIndiaJuliett\n\nIndiaJuliett\n\nIndiaJuliett\n\nIndiaJuliett\n\nIndiaJuliett\n\nIndiaJuliett\n\n7/26/2011 1:08\n\n7/26/2011 1:08\n\n8/23/2011 3:13\n\n9/14/2011 5:54\n\n11/30/2011 1:55\n\n11/30/2011 1:55\n\n11/30/2011 1:55\n\nInstalls SierraJuliett-MikeOne\n\nInstalls SierraJuliett-MikeOne\n\nInstalls IndiaJuliett and SierraBravo\n\nInstalls IndiaJuliett\n\nInstalls SierraJulietta-MikeTwo\n\nInstalls SierraJulietta-MikeTwo\n\nInstalls SierraJulietta-MikeTwo\n\n11/30/2011 16:34\n\nInstalls SierraJulietta-MikeTwo\n\n11/30/2011 17:06\n\nInstalls SierraJulietta-MikeTwo\n\n12/1/2011 12:24\n\nInstalls SierraJulietta-MikeTwo\n\nUniformJuliett\n\n12/4/2011 3:48\n\nUniformJuliett\n\n12/4/2011 3:48\n\nIndiaJuliett\n\nIndiaJuliett\n\nIndiaJuliett\n\n12/5/2011 10:42\n\n12/5/2011 12:18\n\n1/5/2012 4:02\n\nTangoCharlie\n\n1/8/2012 1:01\n\nInstalls SierraJulietta-MikeTwo\n\nInstalls SierraJulietta-MikeTwo\n\nInstalls SierraJulietta-MikeTwo\n\nIndiaHotel\n\nIndiaHotel\n\nIndiaHotel\n\nIndiaHotel\n\nIndiaHotel\n\nIndiaHotel\n\nIndiaHotel\n\nIndiaHotel\n\nIndiaHotel\n\nIndiaHotel\n\nIndiaHotel\n\nIndiaHotel\n\nIndiaHotel\n\nIndiaHotel\n\n12/4/2012 7:30\n\n4/3/2013 11:26\n\n12/4/2012 7:30\n\n4/3/2013 11:26\n\nMultiple valid hashes for the same command ID\n\nMultiple valid hashes for the same command ID\n\nMultiple valid hashes for the same command ID\n\n3/29/2012 15:23\n\nMultiple valid hashes for the same ID\n\nMultiple valid hashes for the same ID\n\n4/3/2012 0:29\n\n4/3/2012 0:29\n\n12/4/2012 7:30\n\n12/4/2012 7:30\n\n12/4/2012 7:30\n\n12/4/2012 7:30\n\n12/4/2012 7:30\n\n12/4/2012 7:30\n\n12/4/2012 7:30\n\nTable 17-12: Command File Payload Types and Their Compile Dates\n\nTable 17-12 identifies some interesting irregularities within the command file set. For instance, there are three valid 10000 \ncommand ID numbers and two valid 10010 command ID numbers. This would indicate that the attackers utilizing the \nSJM1 botnet introduced multiple files with the same command ID which would result in potential inconsistency in the \ncommands executed across the botnet. Command IDs 30000 and higher all distribute the same executable (an IndiaHotel \ninstaller). It is unclear why the attackers would continually redistribute the same executable.\n\nThe command file set does reveal a definite shift from SJM1 to SJM2. This is evidenced first by the fact that the IndiaJuliett \nfiles deployed across the botnet switch to the distribution of SJM2 instead of SJM1, and also by the fact that on two \ndifferent occasions the attackers drop and execute UniformJuliett binaries. \n\n79\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\f18. [P2P Staging] SierraJuliett-MikeTwo (Joanap Mk. II)\n\nSierraJuliett-MikeTwo (SJM2) has an incredibly similar structure as SierraJuliett-MikeOne (SJM1) but has no code (at the \nbinary level) overlap. SJM2 is a complete rewrite of the concept seen with SJM1. Novetta observed the SJM2 malware as \nthe payload of several IndiaJuliett samples that were introduced by SJM1 during its operational run. Installed as a svchost-\ndependent service, SJM2\u2019s binary is a DLL with the common ServiceMain function as its only export. \n\nOne of the most notable difference between SJM2 and SJM1 is the location of the configuration and seed list information. \nSJM2 stores its persistent data within the victim\u2019s registry at two different locations: HKLM\\SOFTWARE\\Microsoft\\\nDbgJITDebugLaunchSetting\\00000000 for the configuration data and HKLM\\SOFTWARE\\\\Microsoft\\\nDbgManagedDebugger\\00000000 for the peer list. The second most notable difference between the SierraJuliett \nfamilies is the coding structure. Structurally, SJM2 differs from SJM1 by its heavy use of C++ instead of C. The bulk of the \nfunctionality of SJM2 is encapsulated in a set of C++ classes. While on the one hand the use of C++ classes provides clear \ndelineation between the malware\u2019s various features, the use of C++ requires additional overhead for the developer. The \nimplementation of SJM2 through C++ class objects suggests the malware was written by a developer with a more academic \napproach to coding when compared to SJM1, which has a style suggesting a more task-centric developer. \n\nThe communication protocol of SJM2 is incompatible with the protocol of SJM1. The incompatibility between the two \nindicates that SJM2 is not an evolutionary enhancement of SJM1 but a separate entity that must maintain its own network.\n\n80\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\f19. [Webserver] HotelAlfa\n\nHotelAlfa is a stripped down HTTP server that hosted the Guardians of Peace (GOP) hackers\u2019 webpage announcing their \ndemands against SPE as well as the locations of the data that the GOP attackers stole. Consisting of only 4 functions, \nHotelAlfa is an extremely simple piece of code and is clearly created for a limited purpose. \n\nUpon activation, HotelAlfa attempts to bind a listening socket to port 80 on the victim\u2019s machine. If port 80 is \nunavailable, HotelAlfa attempts to shutdown services (via a call to the API function StopService) in order to free up \nport 80 before attempting another bind operation. HotelAlfa attempts to stop the following services:\n\n\u2022  W3SVC \u2013 IIS service\n\u2022 WMServer \u2013 Windows Media Service\n\u2022 SSIS \u2013 SQL Server Integration Service\n\u2022 SSRS \u2013 SQL Server Reporting Service\n\u2022 MSDEPSVC \u2013 Web Deployment Agent Service\n\nFor each incoming connection, HotelAlfa spins off a new thread to handle the request. The thread reads up to 4096 \nbytes from the client and scans the response for specific keywords. The request from the client does not necessarily need \nto conform or comply with the HTTP request standard. Instead, the request merely must contain the appropriate file \nextension otherwise the default HTML page is returned. HotelAlfa responds to .wav and .jpg file extensions with the \nappropriate file. \n\nHotelAlfa only supplies three files to the client: an HTML page, a WAV sound file, and a JPG image. These files are stored \nwithin the HotelAlfa binary\u2019s resource section under the RC_DATA branch. Each file is encoded with XOR 0x63, requiring \nHotelAlfa to decode each file prior to transmitting the data back to the requesting client. When HotelAlfa sends a \nresponse back to the client, the response does conform to the HTTP 1.1 standard.\n\n81\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\fTable 19-1 describes each of the three files that HotelAlfa returns to the requesting client.\n\nRESOURCE NAME\n\nFILE DETAILS\n\nRSRC_HTML\n\nHTML code for the #GOP webpage. Contains links to a warning to SPE along with URLs to leaked \nSPE data.\n\nBackground image for the #GOP webpage, seen here: \n\nRSRC_JPG\n\nRSRC_WAV\n\nWAV sound file of gun shots that plays on the #GOP webpage in a loop.\n\nTable 19-1: The Locations within the Resource Section of HotelAlfa and the Description of the Various File the Malware Serves to Users\n\n82\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\f20. Conclusion\n\nThe Lazarus Group employs a variety of RATs and staging malware to conduct cyber operations, many of which contain \nsignificant code overlap that points to at least a shared development environment. The development of these families \nalso emphasizes the resources and organization of the Lazarus Group. The SierraJuliett families, for instance, provides \na common operating environment that effectively allows operators of any technical skill to access victim networks. \nAdditionally, the Romeo-CoreOne-based families essentially acts as a modular design platforms and further simplifies the \nprocess for developing custom, targeted, and effective RATs.\n\nWhile some members within the Romeo and Sierra groups may not implement sound authentication strategies, shift their \ndesign focus in abrupt and unusual manners, and fail to understand the pitfalls of distributed command networks, on the \nwhole the families within the Lazarus Group\u2019s collection of RATs and staging malware perform their tasks with surprising \neffectiveness. As the maturity of the code base increases, so too does the effectiveness and design integrity of the malware \nfamilies employed by the Lazarus Group.\n\n83\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\fMcLean, Virginia \u2013 Headquarters \n7921 Jones Branch Drive \n5th Floor \nMcLean, VA 22102 \nPhone: (571) 282-3000 \nwww.novetta.com\n\nwww.OperationBlockbuster.com\n\n\f", "HKLM\\SYSTEM\\CurrentControlSet\\Control\\WMI\\Security\\zc62a465-efff-87cc-47cdcdefa), uses a \nstartup delay, and operates as a thread spawned out of DllMain.\n\nFunctionally, RomeoHotel is nearly identical to RomeoAlfa: RomeoHotel supports the same commands within the R-C1 \nportion of itself, has an identical configuration data structure in both size and field meaning to that of RomeoAlfa-Two, \nand uses fake TLS for communication. RomeoHotel supports the same command set found in RomeoAlfa-Two, but \nsupports all commands fully, while RomeoAlfa-Two does not fully support all of its commands. For example, RomeoHotel \nsupports the RunAs command fully while the RomeoAlfa variants will accept the command but will perform not action as \na result of the instruction from the C2 server. \n\nThe numbering of commands between RomeoAlfa-One and RomeoHotel are exactly one-to-one with a 0x1000 offset, e.g. \nMove File in RomeoAlfa-One is 0x873B and 0x973B in RomeoHotel. It is unclear if the offset between the two is indicative of a \ngenerational shift, a coincidence of versioning, or a conscious decision by the developer(s). But the fact remains that given the \nsimilarities between the RomeoAlfa and RomeoHotel families, the one-to-one (with offset) of commands is eye catching.\n\nTable 10-1 lists RomeoHotel\u2019s supported commands and their command identifiers. \n\nCOMMAND \nIDENTIFIER\n\nCOMMAND\n\n0x973B\n\nMove File\n\n0x973C\n\nDirectory Statistics\n\n0x973D\n\nEnumerate Drives\n\n0x973E\n\nEnumerate Directory\n\n0x973F\n\nWrite File\n\n0x9740\n\nRead File\n\n0x9741\n\nUpload Directory as Archive (Defunct)\n\n0x9743\n\nCreate Process\n\n0x9744\n\nSecure Delete\n\n0x9745\n\nMimic Timestamp\n\n0x9746\n\nExecute Shell Command with Output Upload\n\n0x9747\n\nEnumerate Processes\n\n33\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\fCOMMAND \nIDENTIFIER\n\nCOMMAND\n\n0x9748\n\nTerminate Process\n\n0x9749\n\nSystem Information\n\n0x974A\n\nChange Directory\n\n0x974B\n\nPort Knock\n\n0x974D\n\nSend Status Value\n\n0x974F\n\n(RESPONSE CODE) Relay Status: Failure\n\n0x9750\n\n(RESPONSE CODE) Command Status: Success\n\n0x9751\n\n(RESPONSE CODE) Command Status: Failure\n\n0x9752\n\nDisconnect\n\n0x9753\n\nGet Config\n\n0x9754\n\nSet Config\n\n0x9755\n\nRunAs \n\n0x9756\n\nNOP\n\n0x9757\n\nSuicide \n\nTable 10-1: RomeoHotel\u2019s Supported Commands and Their Identifiers\n\nDespite the similarities between RomeoHotel and other Romeo-CoreOne-based families, there are key differences that \nmake RomeoHotel unique in the Lazarus Group\u2019s collective. After loading the configuration from the registry and prior to \nthe startup sleep delay, the malware performs three tasks specific to RomeoHotel:\n\n1.  Stop a service specified by the configuration and unload its DLL from memory by calling FreeLibrary.\n2.  Run two commands specified by the configuration via CreateProcess calls.\n3.  Spawn a new thread that loads two DLLs specified by the configuration after a 20 second sleep delay.\n\nA viable configuration was not observed in any identified samples, making it difficult to determine the intention of the \nthree tasks. \n\nThe sleep delay, hardcoded in RomeoCharlie-Two, is a configurable item specified by the configuration data structure. \nRomeoHotel enforces a maximum startup delay of 180 minutes (3 hours) by reducing any startup delay value to 180 \nminutes. RomeoHotel also introduces a delay between successive C2 server connection attempts. Prior to attempting a \nconnection to a C2 server, RomeoHotel sleeps for 10 seconds. \n\nRomeoAlfa, RomeoBravo (see Section 4), RomeoCharlie, and RomeoNovember (see Section 12) each call a function that \nintroduces a sleep delay between endpoint connections. Evidence suggests that each of the families is using a neutered \nversion of the function found in RomeoHotel immediately after exiting the MessageThread function (Figure 10-1). \n\n34\n\nOperation Blockbuster:  Remote Administration Tools and Content Staging Malware Report\fvoid __cdecl PostConnectionActivities(int dwMaxDrives)\n{\n  wchar_t wszRootPath[6] = L"], "URLs": ["http://www.codeproject.com/Articles/1380/A-C-Implementation-of-the-Rijndael-Encryption-Decr", "https://www.google.com/index.h", "https://www.netsarang.com/", "https://filezilla-project.org/", "http://read.pudn.com/downloads110/sourcecode/hack/scanner/454581/rBot_041504/crypt.cpp__.htm", "https://www.vandyke.com/products/index.html", "http://www.mremoteng.org/", "https://msdn.microsoft.com/en-us/library/windows/desktop/ms221646(v=vs.85).aspx", "http://www.estsoft.com/altools", "http://www.codeproject.com/Articles/7530/Zip-Utils-clean-elegant-simple-C-Win."], "weight": 0.0}