{"rule_id": 73, "name": "2020.09.11_Talos_-_The_art_and_science_of_detecting_Cobalt_Strike", "description": "-", "references": ["CVE-2013-2460", "CVE-2013-2465", "CVE-2012-4681", "CVE-2011-3544"], "File_Names": ["cross_platformi9.jar", "oracle.com", "AcroPDF.PDF", "Main.java", "MYKEY.SF", "cisco.com", "Sun.awt", "Main.dll", "main64.dll", "beacon.dll", "reserved.The", "Base64.dll", "sun.awt", "com.sun", "MYKEY.RSA", "wininet.dll", "hash.py", "main.dll", "java.lang", "artifact.exe", "check.js", "naming.html", "Statement.acc", "sun.org", "sun.arch"], "MD5_Hashes": [], "SHA1_Hashes": [], "SHA256_Hashes": [], "Registry_Entries": ["HKEY_CURRENT_USER\\Software\\Microsoft\\\nOffice\\<Excel Version>\\Excel\\Security\\AccessVBOM\\`\n\nThis key is a security setting for restricting default \nprogrammatic access to the Office VB project. If it\u2019s \nenabled, Office will trust all macros and run any code \nwithout a security warning or additional permissions from \nthe user. Cobalt Strike attempts to flip that switch and \n\ndisable this protection in the registry.\n\nAfter that, Cobalt Strike once again calls the Windows API \nto execute binary code. Then, it allocates an executable \nsection of memory within the process and runs it by calling \n`kernel32.dll!CreateRemoteThread`.\n\nDetection\n\nThis type of multilayer obfuscation is easy to extract when \nin hand but can be extremely effective against security \nproducts that don\u2019t know it\u2019s coming. But it\u2019s possible to \nwork around this.\n\nFor the executable method, the shellcode was actually the \nsame assembly code as what we discussed earlier in the \nStaged/Stageless Executables. The NOP-based function is \ninterpreted as a hex string, so we can clone those rules to \n\ntalos-external@cisco.com  |  talosintelligence.com\n\npage 15 of 29\n\n\u00a9 2020 Cisco. All rights reserved.The art and science of detecting Cobalt Strike\fmatch a hex string, rather than actual bytes.\n\n\u2022 \n\n\u2022 \n\n\u2022 \n\n\u2022 \n\n1:54110 MALWARE-OTHER Html.Trojan.CobaltStrike \nHTML beacon download attempt\n\n1:54111 MALWARE-OTHER Html.Trojan.CobaltStrike \nHTML beacon download attempt\n\n1:54112 MALWARE-OTHER Html.Trojan.CobaltStrike \nHTML beacon download attempt\n\n1:54113 MALWARE-OTHER Html.Trojan.CobaltStrike \nHTML beacon download attempt\n\nFor the PowerShell method, we have again a ton of \nobfuscated code underneath it, so the coverage should \ntarget generic function calls. For this, we went with the \nPowerShell command arguments, and supplemented that \nwith matching on a Wscript.Shell object being created.\n\n\u2022 \n\n\u2022 \n\n1:54114 MALWARE-OTHER Html.Trojan.CobaltStrike \npowershell payload download attempt\n\n1:54115 MALWARE-OTHER Html.Trojan.CobaltStrike \npowershell payload download attempt\n\nLastly, we have the VBA Method. Our researchers found \nthis easy to cover because HTA files don\u2019t often interface \nwith Excel workbooks, let alone one that tinkers with the \n\u201cAccessVBOM\u201d registry key.\n\n\u2022 \n\n\u2022 \n\n1:54116 MALWARE-OTHER Html.Trojan.CobaltStrike \nVBA payload download attempt\n\n1:54117 MALWARE-OTHER Html.Trojan.CobaltStrike \nVBA payload download attempt\n\nFrom there, we cloned all that to ClamAV coverage to get \nthe following signatures:\n\n\u2022  Html.Trojan.CobaltStrike-7932561-0\n\n\u2022  Html.Trojan.CobaltStrike-7932562-0\n\n\u2022  Html.Trojan.CobaltStrike-7932563-0\n\n\u2022  Html.Trojan.CobaltStrike-7932564-0\n\nTARGET MODULE: SCRIPTED WEB DELIVERY\n\nIn Cobalt Strike, there\u2019s a feature called \u201cscripted web \ndelivery.\u201d Executing a scripted web delivery attack simply \nmeans that you pick one of the Cobalt Strike payloads/\nlisteners and Cobalt Strike will then host that payload at \na user-configured URI. These can be generated in three \ndifferent languages: Bitsadmin, PowerShell and Python.\n\nAfter hosting the payload, Cobalt Strike provides a \n\ncommand that can be executed, in the language of choice, \nthat reaches out and grabs the malicious payload from an \nattacker-controlled web server and executes it.\n\nWe are only going to concentrate on the PowerShell \nimplementation, as it is the most commonly used module. \nThe initial execution is using a web client to download an \nadditional PowerShell payload from the attacker controlled \nweb server and then continue to execute that code.\n\nPayload\n\nAfter reaching out to grab the real payload, we get a huge \nobfuscated PowerShell script from the web server, almost \n200KB in size.\n\nThis script contained code reuse from the HTA module, \nbut we still needed to go one layer deeper and verify the \nshellcode was unique in this module. We base64-decode \nthe data and decrypt it using the same `0x23` default \nXOR key \u2014 and it\u2019s already much larger than the previous \npayload.\n\nIt\u2019s not raw shellcode like we saw in the HTA payloads, \nyou can immediately see that the \u201cMZ\u201d header is present. \nThis seems to be a stageless beacon included in the \npowershell script. You might wonder why it wasn\u2019t \nincluded in the HTA attack. The reason is the HTA module \nis executing a Powershell one-liner and Windows has \na character limit on command line strings, 32767. That \nnumber is even lower when executing a command from \n`cmd.exe`, 8191. The character limit varies across a variety \nof execution methods and these numbers are not always \ngoing to be correct.\n\nSince this payload is downloaded using a small one-liner to \nexecute a string retrieved from the Cobalt Strike controlled \nserver, that limit is bypassed and a more reliable payload \ncan be provided.\n\nDetection\n\nTo detect something, we first have to narrow down what \nwe can actually see in Snort or ClamAV. We are not able \nto deobfuscate a PowerShell script coming across the \nnetwork prior to detection \u2014 it\u2019s simply not feasible without \nintroducing latency for the client in most cases.\n\nSo, for detection, we are left with the initial obfuscated \npayload downloaded. That\u2019s not so bad because Cobalt \nStrike, in its current configuration, once again has a \n\ntalos-external@cisco.com  |  talosintelligence.com\n\npage 16 of 29\n\n\u00a9 2020 Cisco. All rights reserved.The art and science of detecting Cobalt Strike\fFigure 27\n\nFigure 28\n\nstatic format when generating the PowerShell script. \nWe know that in this instance, the code `New-Object \nIO.MemoryStream(,[Convert]:: FromBase64String(` following \nwill always be present in a position relatively close to the \nstart of the file.\n\nThis gives us simple, but efficient, coverage using\n\n\u2022 \n\n\u2022 \n\n1:53973 MALWARE-OTHER CobaltStrike PowerShell \nweb delivery attempt\n\n1:53974 MALWARE-OTHER CobaltStrike PowerShell \nweb delivery attempt\n\nTARGET MODULE: SIGNED JAVA APPLET ATTACK\n\nThe applets in this attack are self-signed, giving users \nlimited options: a listener (per usual), port, local host and \nthe URI it\u2019s hosted on. This will spawn a hosted Java Applet \non a malicious Cobalt Strike web server to infect users. If a \nuser gives an applet permission to run, infection will occur.\n\nLanding Page\n\nUpon visiting the page, the user sees a generic landing \npage that loads a malicious JAR file, \u201ccross_platformi9.jar\u201d \nand applet class loaded is defined by the \u201ccode\u201d parameter, \n\u201cJava.class\u201d (Figure 27).\n\nThe first thing that catches the eye is that two parameters \nare passed \u2014 \u201cid,\u201d which contains a large base64 blob, and \n\u201ctype\u201d which is set to \u201ctheme.\u201d We can confirm this right off \nthe bat by comparing the length of the raw HTTP beacon \npayload against the length of the decoded binary blob, both \na total of 799 bytes.\n\nA second HTTP GET request is made for the JAR file during \nthe process of loading this applet. So that\u2019s the next step.\n\nJava archive (JAR)\n\nFirst, we\u2019ll look at the JAR file (Figure 28).\n\nWe have a few classes, and two DLLs named \u201cmain.dll\u201d \nand \u201cmain64.dll\u201d. You can also see the default signature file \n\ntalos-external@cisco.com  |  talosintelligence.com\n\npage 17 of 29\n\n\u00a9 2020 Cisco. All rights reserved.The art and science of detecting Cobalt Strike\f(MYKEY.SF) and RSA certificate (MYKEY.RSA) used to sign \nthe binary. Figure 29 shows us jusing jadx to decompile the \nsource code.\n\nThe base code called \u201cJava.class\u201d isn\u2019t complicated \u2014 it\u2019s \nan extension of \u201cApplet\u201d designed to spawn a thread. And \nthe Base64.dll class isn\u2019t malicious, it handles base64 as \nexpected.\n\n\u201cMain.class\u201d is fairly basic but shows us that a temporary \nfile is created, named \u201cmain.dll\u201d and writes data to that \nfile from either the main64.dll or main.dll file contained in \nthe JAR file based on the system architecture. The system \nproperty \u201csun.arch.data.model\u201d is a simple method to return \nthe system\u2019s word size, easily determining the architecture. \nFollowing this, the new DLL file path is fed to `System.\nload()`.\n\nCobalt Strike uses the Java Native Interface (JNI) to perform \ninjection. This is essentially the same as creating bindings \nto another program. It allows users to load a library into the \nJava Virtual Machine (JVM) and interact with it.\n\nMain.dll\n\nSince inject() is called from the JNI with the shellcode blob, \nwe can load this into IDA and see an exposed function \u2014 \n`Java_Main_inject()`.\n\nThe handoff to `Java_Main_inject` isn\u2019t as straightforward as \nit would be passing a byte/character array in C/C++. In this \ncase the exported function looks a little like Figure 30:\n\nThe data is extracted from the JNI objects and then passed \nto the real `inject()` function that spawns a new thread and \nresumes execution in the shellcode passed in from the \u201cid\u201d \nparameter.\n\nDetection\n\nWe need to isolate the things we want to cover and \nseparate them from each other when evaluating multiple \n\nFigure 29\n\nlevels of execution. Here, we can identify a few things.\n\n1.  The landing page that spawns the malicious applet\n\n2.  The JAR file\n\n3.  main.dll/main64.dll\n\nThe landing page was fairly simple, as we already identified \nthat the parameter is simply the raw payload from earlier. \nThe JAR files contain the same DLL 32/64 bit and code \nevery time but have a different name. This simplifies things \nas we target what we know is malicious in there.\n\nThe last thing was the extracted DLL, and our prior work \npaid off. We had prior coverage available from various x32/\nx64 download rules we created researching the staged/\nstageless beacons.\n\nTARGET MODULE: SMART JAVA APPLET ATTACK\n\nThe Smart Java Applet Attack is very similar to Signed Applets \nin execution. Instead of just running raw shell code, though, it \nattempts to gain execution through various Java exploits. It is \ndeemed \u201cSmart\u201d as it determines what exploit to use based \non the version of Java the victim host is running.\n\nLanding Page\n\nThe landing page is for the most part the same as Signed \nApplet Attacks. It spawns a malicious page on the default \nURI, \u201c/SiteLoader.\u201d\n\nOnce again, there\u2019s a base64 blob containing the \u201cid\u201d \n\nFigure 30\n\ntalos-external@cisco.com  |  talosintelligence.com\n\npage 18 of 29\n\n\u00a9 2020 Cisco. All rights reserved.The art and science of detecting Cobalt Strike\fparameter and a \u201ctype\u201d parameter \nwith the value \u201cos.\u201d The payload is \nslightly different, however, since it \nuses the same shellcode stub. We \nalready know what this does for \nthe most part, so we\u2019ll skip further \nanalysis.\n\nJava Archive\n\nPer the Cobalt Strike official \ndocumentation, we can get a brief \nunderstanding of this module\u2019s goal.\n\n\u2022 \n\n\u2022 \n\nThe smart applet analyzes its \nenvironment and decides which \nJava exploit to use. If the Java \nversion is vulnerable, the applet \nwill disable the security sandbox, \nand spawn a session using Cobalt \nStrike\u2019s Java injector.\n\nThese exploits in this attack work \nagainst Java 1.7u21 and older. \nJava 1.6u45 and older is also \nvulnerable to this attack.\n\nThe exploits used are not specified \nhowever, we know it affects the Java \nversions shown in Figure 31. Since \nwe don\u2019t know what exploits it\u2019s \nusing already, we must look closer.\n\nThere are a lot more classes shown \nin Figure 32, but we can see that \nmain.dll/main64.dll are still included. \nA quick `sha256sum` reveals that \nthese are the same DLLs included \nin the Signed Applet Attack module. \nWe once again can decompile the jar \nusing `jadx` as we did in the Signed \nApplet Attack. The decompilation \nwas not clean as we receive one \nerror for an unknown instruction, \n\u201cinvoke-polymorphic\u201d. This \ninstruction is not currently supported \nin jadx, so we will just ignore it for \nnow and start looking at `JavaApplet.\nclass` in Figure 31.\n\nThis class directs execution based on \n\nFigure 31\n\nFigure 32\n\nthe version of Java installed, here we can identify how it targets each version. The \ncode polls \u201cjava.version\u201d via a call to System.getProperty to get the JRE version \ninstalled, if any. Following that it is matched against the PCRE `1.(\\d+).0_(\\d+)`. The \nimportant thing with this PCRE is that it has two capture groups that retrieve major \nand minor Java versions for further processing. It\u2019s important to understand the \nstructure of Java version strings. [See https://www.oracle.com/java/technologies/\njavase/versioning-naming.html].  \n\n"], "URLs": ["https://www.oracle.com/java/technologies/"], "weight": 0.0}