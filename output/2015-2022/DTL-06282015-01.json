{"rule_id": 940, "name": "DTL-06282015-01", "description": "-", "references": [], "File_Names": [], "MD5_Hashes": ["6e4e030fbd2ee786e1b6b758d5897316", "548884eabebef0081dd3af9f81159754", "05bc4a9b603c1aa319d799c8fba7a42a", "cdf0e90b0a859ef94be367fdd1dd98c6"], "SHA1_Hashes": [], "SHA256_Hashes": [], "Registry_Entries": ["HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\u201d in the \n\u201cProxyServer\u201d key. It appears that at least one of the samples we analysed (see appendix) has a bug3 \nand will fail to connect to the command and control server unless the system is configured to use a \nproxy server. Failure to connect to the command and control server results in the malware sleeping \nfor 5 minutes before trying again. \n\n3 Thanks to Tillmann Werner for pointing this out \n\nD r a g o n   T h r e a t   L a b s ,   H o n g   K o n g  \n\nPage 5 \n\n \n \n \n \n \n                                                           \n\fUpon connecting to the command and control server several exchanges of information take place. \nDuring the initial \u2018SSL\u2019 connection (described above) certain responses are expected from the \ncommand and control server. These responses are only validated by length and in fact can contain \nany data; the first response should be 3162 bytes in length and the second 59 bytes. \n\nThe encoded MAC address is also sent to the command and control server. It is likely that the \nattacker\u2019s use this value to identify unique victims. Once the connection has been established \ncommand and control can take place. \n\nThe command and control functionality is very simple, however the structure is not. From this very \nhigh-level view we can see that this is not as easy as a simple IF, NOT, THEN structure. \n\nD r a g o n   T h r e a t   L a b s ,   H o n g   K o n g  \n\nPage 6 \n\n \n \n \n \n\fUltimately this breaks to commands and sub-commands, denoted by a specific packet structure. \n\nD r a g o n   T h r e a t   L a b s ,   H o n g   K o n g  \n\nPage 7 \n\n \n \n \n \n \n \n\fThe functionality can be broken down into the following groups: \n\n\uf0b7  0x3: Execute command \n\no  Uses cmd.exe to execute a command, logs the output and sends it back to the c2 \n\nserver \n\n\uf0b7  0x0A: File operations \no  Sub-options: \n\n\uf0a7  0x0B: Create a file (filename specified by in the data packet) in the user\u2019s \n\ntemporary directory \n\n\uf0a7  0x0C: Write data (specified in the data packet) to the currently open file \n\uf0a7  0x0D: Open the file that was created/written to, perform an MD5 hash on \n\nthe contents and compare it to the attacker specified MD5 (contained within \nthe data packet) \n\nThe structure behind the protocol is fairly simple and involves packet data being passed through a \ndecoding routine before being processed. For example, a decoded packet executing C2 command \n0x0A, sub-command 0x0D looks like the following: \n\nThe data decoding routine begins by taking a series hardcoded values and appending it to the \nbeginning of the data, it then proceeds to run an XOR operation against each byte of the packet in \nreverse order, for example: \n\nClearly at this stage we can see that this implant does not use SSL. \nServer-side protocol analysis has unfortunately been thwarted by a lack of response from the \ncommand and control servers so the examples are above are just that: examples. In any case we are \n\nD r a g o n   T h r e a t   L a b s ,   H o n g   K o n g  \n\nPage 8 \n\n \n \n \n \n \n \n\fconfident in saying that responses from live command and control servers are unlikely to be fully \nstatic and thus creating a reliable IDS signature or detection heuristic would be challenging at best. \n\nDuring the process of analysing the malware samples we created a fully functioning command and \ncontrol server module. After careful consideration we have decided not to release the code for this. \n\nUltimately Mocelpa is a simple downloader with basic functionality. Given the seemingly \nunnecessary amount of complexity involved and the obscure method of verifying file download \nsuccess we would be quick to assume that this was written by an inexperienced programmer, but \nthere are in fact a number of reasons why such methods were used in the development of this \nimplant. Taking into consideration things like reverse engineering, network detection devices, anti-\nvirus and human \u2018hunter\u2019 teams it does not take much thought to theorise why the codebase and \nfunctionality are somewhat creative. \n\nStill, through this extra code it does not make Mocelpa less detectable \u2013 in fact quite the opposite. \n\nD r a g o n   T h r e a t   L a b s ,   H o n g   K o n g  \n\nPage 9 \n\n \n \n \n \n \n \n \n\fDetection & mitigation \nThis implant can be detected at both disk and network level. In order to help organisations protect \nthemselves we have created a number of network IDS rules and disk-scan rules that can be used \nwith Snort and Yara. Rules are provided in a best-effort basis and we cannot vouch for their \nefficiency in your environment. \n\nMocelpa YARA disk signature \nrule apt_win_mocelpa { \nmeta: \n\nauthor = "], "URLs": [], "weight": 0.0}