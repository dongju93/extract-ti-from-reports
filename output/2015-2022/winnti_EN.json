{"rule_id": 685, "name": "winnti_EN", "description": "-", "references": [], "File_Names": ["stefan.le", "phism.pdf", "rootkit.sys", "NULL.SYS", "hitcon.org", "NdisRerouteD.pdb", "exatrack.com", "workdll64.dll", "rasppp.dll"], "MD5_Hashes": [], "SHA1_Hashes": ["117F5C5B276C2805D69A48F8B23C25883FCF5BE6"], "SHA256_Hashes": ["a5d6139921576c3aedfc64e2b37ae1a64f3160bd1bb70d4fc7fce956029e7d55"], "Registry_Entries": ["HKLM\\SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002BE10318} \nto identify the subkey Linkage with the associated RootDevice. \n\nthe  DLL \n\nchecks \n\nfound, \n\nthe \n\nThe goal here is to validate the network configuration associated with the ethernet device. \n\nSigned driver extraction \nDuring the module initialization steps, it loads a driver based on the current Windows version. \n\nThe  value  \u00ab 4 \u00bb  represent  Windows  kernel  6.0  (Windows  Vista).  We  were  interested  by  the  driver \nloaded on OS version 6.0 and upper. \n\nTo load the driver, the required registry keys are created by the malware and loading is triggered by a \ncall to NtLoadDriver (dynamically loaded). \n\n@ExaTrack \n\nhttp://www.exatrack.com \n\nPage 4 \n\n \n \n \n \n \n\fDriver \n\nSignature \nThe driver is signed by what is probably a stolen certificate used to load the rootkit on 64b Windows.  \n\nA  required  certificate  is  not  within  its  validity  period  when \n\n       Verified: \nverifying against the current system clock or the timestamp in the signed file. \n       Link date:      06:10 11/04/2016 \n        Signing date:   n/a \n        Catalog:        C:\\rootkit.sys \n        Signers: \n           ***** \n                Cert  Status:        This  certificate  or  one  of  the  certificates  in  the \ncertificate chain is not time valid. \n                Valid Usage:    Code Signing \n                Cert Issuer:    VeriSign Class 3 Code Signing 2010 CA \n                Serial Number:  F0 87 74 64 EC F2 AA 94 E0 4B 84 25 4D ED B5 4E \n                Thumbprint:     117F5C5B276C2805D69A48F8B23C25883FCF5BE6 \n                Algorithm:      sha1RSA \n                Valid from:     02:00 28/03/2012 \n                Valid to:       01:59 14/04/2015 \n\nHook of driver NULL.SYS \nDuring  the  rootkit\u2019s  initialization  it  sets  up  a  hook  on  the  device  \\Device\\Null.  To  do  so,  it  must \nfirstly get the DEVICE_OBJECT and its associated DRIVER_OBJECT. With this it can directly modify the \nIRP \nfor \nIRP_MJ_DEVICE_CONTROL. \n\ntable.  The  0xe  entry  of \n\nthe  MajorFunction  array \n\nthe  handler \n\ncontains \n\nThis action is a little risky for the rootkit, as it is common to see rootkits modifying the \\Device\\Null \nDRIVER_OBJECT . \n\nOnce its hook is setup, we can open a handle on \\\\.\\NUL to communicate with the rootkit by IoCtl. \n\n@ExaTrack \n\nhttp://www.exatrack.com \n\nPage 5 \n\n \n \n \n \n \n\fIoCtl Communication \nAs almost all rootkits, a communication channel is established with the userland DLL using IoCtl: \n\nioctl_code != 0x156003 && (ioctl_code != 0x15e007) \n\n The driver expects commands to be passed through the IoCtl buffer in the following format: \n\nstruct ioclt_buffer_struct { \n    uint CodeId; \n    uint DataSize; \n    char Datas[]; \n}; \n\nWe\u2019ll describe some commands that can be called from the userland. \n\ngetMagicNumber  (0x200) \nThe simplest function. \n\nIt is probably a tag to check the version number. \n\nhideDriver (0x100) \nThis command takes one more argument to identify the sub-action to perform: \n\n\uf0b7  1: Hide the driver \n\uf0b7  2: Know state of the driver (hidden or visible) \n\nThe  driver  is  hidden  with  multiple  methods;  its  headers  are  overwritten  with  null  bytes  to  avoid \ndetection by simple search of the MZ and PE headers. \n\nAfterward, the driver will enumerate the  \\Driver directory entries to find its own  DRIVER_OBJECT. \nOnce  found,  it  will  remove  it  from  the  list  by  replacing  the  previous  object\u2019s  FLINK  pointer  (next \nobject) by the next driver. \n\n@ExaTrack \n\nhttp://www.exatrack.com \n\nPage 6 \n\n \n \n \n\fThe  same  operation  is  performed  in  \\Device  with  the  driver\u2019s  associated  DEVICE_OBJECT  (but  our \ndriver has no associated DEVICE_OBJECT in this version). \n\nAlthough the driver is deleted from the \u00ab Directory Object \u00bb\u2019s list it also destroys some information \nthat may revealed it by memory forensic analysis. \n\nThis action is also done with the DEVICE_OBJECT, whereas no \u00ab device \u00bb was affected to the driver. \n\n@ExaTrack \n\nhttp://www.exatrack.com \n\nPage 7 \n\n \n \n \n \n\fSetIpAndPort (0x600) \nThis command setup the server remote server to validate usage of network injections by NDIS. We \nwill go back to its usage later in the paper. \n\nsend_packet (0x400) \nUnder  some  conditions  the  driver  may  allow  to  send  Ethernet  packets  directly  on  the  network \ninterface.  Sent  datas  are  located in the  buffer  transferred  to the kernel. Conditions of this delivery \nare described in the next part.  \n\nNDIS hooks and network injections \nThe  rootkit  have  some  interesting  network  capabilities,  it  position  itself  at  the  NDIS  level  to \ncommunicate  directly with the  network card. Globally, the references to  NDIS  functions and  hooks \nfrom the driver\u2019s EntryPoint are the following: \n\n@ExaTrack \n\nhttp://www.exatrack.com \n\nPage 8 \n\n \n \n \n \n \n\fThe  registerNdisProtocolDriver  function  will  firstly  search  the  TCPIP  instance  in  the  NDIS \nprotocols. This process is done with a simple linked list. \n\nThis code walks the registered protocols, once TCPIP (here tcp_ip_ustr) is found, two functions will \nbe  hooked,  ReceiveNetBufferLists  and  ProtSendNetBufferListsComplete.  Those  functions  are \nused to receive and send packets of the associated protocol. \n\nThe  hook_ReceiveNetBufferLists  function  receives  packets  from  the  network  adapter.  Each \npacket\u2019s  content  will  be  analyzed  and  verified  against  the  configuration  of  the  driver,  if  a  precise \nformat is respected some of the rootkit abilities will be enabled. \n\nIt\u2019s interesting to note that the rootkit have his own network packet parser. \n\nFirstly it checks if packet\u2019s size is greater than 0x35 bytes: all TCP packets are larger this size. Next, \nthe protocol type must be 0x800, this value represent the IP protocol. Then, the rootkit checks if the \nIP version is 4 (for IPv4) and that the next protocol is TCP. \n\nThen, the IP source address (so the remote server) is compared with a gobal variable. This variable \ncan  be  setup  with  the  IoCtl  command  SetIpAndPort.  It  is  mandatory  to  announce  the  C&C\u2018s  IP \naddress  to trigger the whole parsing of the packet. \n\n@ExaTrack \n\nhttp://www.exatrack.com \n\nPage 9 \n\n \n \n \n \n \n \n \n\fRegistering the IP address through an IoCtl command is operated like this: \n\nAnd checks of the source\u2019s IP address: \n\nLastly, a checksum is operated on the packet\u2019s data: \n\nThis \u00ab checksum \u00bb is a simple XOR operation between the first DWORD and the third DWORD of the \ndata, followed by a rotation of 0x10 and the result is stored in the fourth DWORD. \n\nD1 \n\nD2 \n\nD3 \n\nD4 \n\nROL \n\nIf  this  check  is  validated,  the  rootkit  will  reference  the  current  handle  (OpenQueue)  in  a  global \nvariable. This variable will be used to send raw packets on the network. \n\nWe  think  those  checks  aims  to  probe  if  the  remote  server  can  be  contacted and  to  identify  which \ninterface need to be used to send raw packets on the network. \n\nOnce all the conditions are met we can send raw packets directly on the identified network interface.  \nThis can be achieve by using the IoCtl command send_packet (0x400) containing the data to send. As \nyou can see, we were able to use the driver to send an arbitrary packet on the network.  \n\n@ExaTrack \n\nhttp://www.exatrack.com \n\nPage 10 \n\n \n \n \n \n \n \n \n \n \n \n \n \n\fTo summarize, if we want to send raw packets on the network we need: \n\n1.  To load the driver \n2.  To communicate with \\Device\\Null \n3.  Send an IOCTL to configure the IP address/port of C&C \n4.  Exchange with the C&C to grab a checksum who validate the network interface to use \n5.  Send an IOCTL to emit raw packets \n\nThe steps to send this raw packet can be summed up by the following schema: \n\nConclusion \nThe  attacker  behind  this  driver  is  a  skilled  one,  the  signed  driver  prove  that  it  has  the  time  and \nresources to implement complex attacks. Furthermore, the inner working of the driver demonstrates \na good technical level as NDIS injection are not an easy thing. The rootkit also has stealth capacities \nthat may not be used anymore because of PatchGuard. \n\n@ExaTrack \n\nhttp://www.exatrack.com \n\nPage 11 \n\n \n \n \n \n \n\fReferences \n\n[1] Tweet of Florian Roth: \nhttps://twitter.com/cyb3rops/status/1153983440871669761 \n\n[2] Takahiro Haruyama slide with evocation of the rootkit: \nhttps://hitcon.org/2016/pacific/0composition/pdf/1201/1201%20R2%201610%20winnti%20polymor\nphism.pdf  \n\n@ExaTrack \n\nhttp://www.exatrack.com \n\nPage 12 \n\n \n \n \n \n\f"], "URLs": ["http://ww.hybrid-", "https://www.virustotal.com/gui/file/92c37c829dac8f6d277ae4b72b926e82f54ed8fc1b61885d7d7d9", "https://j00ru.vexillium.org/2009/07/dllmain-and-its-", "https://twitter.com/cyb3rops/status/1153983440871669761", "http://www.exatrack.com"], "weight": 0.0}