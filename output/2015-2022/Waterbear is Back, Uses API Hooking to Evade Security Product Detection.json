{"rule_id": 509, "name": "Waterbear is Back, Uses API Hooking to Evade Security Product Detection", "description": "-", "references": [], "File_Names": ["BKDR_WATERBEARENC.ZTGH", "TROJ_WATERBEAR.ZTGD", "KERNELBASE.dll", "ociw32.dll", "BKDR64_WATERBEARENC.ZTGJ", "BKDR_WATERBEAR.ZTGF", "BKDR_WATERBEARENC.ZTGI", "TROJ_WATERBEAR.ZTGH", "BKDR_WATERBEARENC.ZTGF", "BKDR_WATERBEARENC.ZTGD", "BKDR_WATERBEAR.ZTGD", "TROJ_WATERBEAR.ZTGJ", "mtxoci.dll", "BKDR64_WATERBEAR.ZTGD", "TROJ_WATERBEAR.ZTGI", "TROJ64_WATERBEAR.ZTGI"], "MD5_Hashes": [], "SHA1_Hashes": [], "SHA256_Hashes": ["fcfdd079b5861c0192e559c80e8f393b16ba419186066a21aab0294327ea9e58", "3909e837f3a96736947e387a84bb57e57974db9b77fb1d8fa5d808a89f9a401b", "abb91dfd95d11a232375d6b5cdf94b0f7afb9683fb7af3e50bcecdb2bd6cb035", "b9f3a3b9452a396c3ba0ce4a644dd2b7f494905e820e7b1c6dca2fdcce069361", "53402b662679f0bfd08de3abb064930af40ff6c9ec95469ce8489f65796e36c3", "3442c076c8824d5da065616063a6520ee1d9385d327779b5465292ac978dec26", "7532fe7a16ba1db4d5e8d47de04b292d94882920cb672e89a48d07e77ddd0138", "7858171120792e5c98cfa75ccde7cba49e62a2aeb32ed62322aae0a80a50f1ea", "649675baef92381ffcdfa42e8959015e83c1ab1c7bbfd64635ce5f6f65efd651", "3f26a971e393d7f6ce7bf4416abdbfa1def843a0cf74d8b7bb841ca90f5c9ed9", "7c0d2782a33debb65b488893705e71a001ea06c4eb4fe88571639ed71ac85cdd", "39668008deb49a9b9a033fd01e0ea7c5243ad958afd82f79c1665fb73c7cfadf", "bda6812c3bbba3c885584d234be353b0a2d1b1cbd29161deab0ef8814ac1e8e1", "05d0ab2fbeb7e0ba7547afb013d307d32588704daac9c12002a690e5c1cde3a4", "f9f6bc637f59ef843bc939cb6be5000da5b9277b972904bf84586ea0a17a6000", "c7c7b2270767aaa2d66018894a7425ba6192730b4fe2130d290cd46af5cc0b7b", "dea5c564c9d961ccf2ed535139fbfca4f1727373504f2972ac92acfaf21da831", "acb2abc7fb44c2fdea0b65706d1e8b4c0bfb20e4bd4dcee5b95b346a60c6bd31"], "Registry_Entries": ["HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\MSDTC\\MTxOCI\u201d to see if the value \u201cOracleOciLib\u201d exists. If so, it retrieves the data inside it and\nloads the corresponding library. If the value doesn\u2019t exist, \u201cmtxoci.dll\u201d tries to load \u201cociw32.dll\u201d instead. During our investigation, we noticed that the value\n\u201cOracleOciLib\u201d was deleted from the victim\u2019s machine, as shown in Figure 2. Hence, the malicious loader \u201cociw32.dll\u201d was loaded and successfully executed on\nthe host.\n\nFigure 2. The deleted value \u201cOracleOciLib\u201d on the victim\u2019s host\n\nNote: The image on the left \u00a0shows how \u00a0the DLL on a normal machine normally looks. The image on the right showcases how the DLL on a victim\u2019s machine\nappears. Because there is no \u201cOracleOciLib\u201d value, it loads the hardcoded DLL \u201cociw32.dll\u201d instead, which triggers the malicious Waterbear DLL loader.\n\nAfter the Waterbear DLL loader is executed, it searches for a hardcoded path and tries to decrypt the corresponding payload, which is a piece of encrypted shellcode.\nThe decryption algorithm is RC4, which takes the hardcoded path to form the decryption key. If the decrypted payload is valid, it picks a speci\ufb01c existing Windows\nService \u2014 LanmanServer, which is run by svchost.exe \u2014 and injects the decrypted shellcode into the legitimate service. In most cases, the payload is a \ufb01rst-stage\nbackdoor, and its main purpose is to retrieve second-stage payloads\u00a0\u2014 either by connecting to a C&C server or opening a port to wait for external connections and\nload incoming executables.\n\nCon\ufb01guration of the \ufb01rst-stage backdoor\n\nWaterbear\u2019s \ufb01rst-stage backdoor con\ufb01guration contains the information required for the proper execution of and communication with external entities.\n\nOffset\u00a00x00, Size 0x10: Encryption / decryption key for the functions\nOffset\u00a00x10, Size 0x04: 0x0BB8\u00a0(reserved)\n\nhttps://blog.trendmicro.com/trendlabs-security-intelligence/waterbear-is-back-uses-api-hooking-to-evade-security-product-detection/\n\n2/9\n\n\f12/12/2019\n\nWaterbear is Back, Uses API Hooking to Evade Security Product Detection - TrendLabs Security Intelligence Blog\n\nOffset\u00a00x14, Size 0x10: Version (e.g., 0.13, 0.14, 0.16, and so on)\nOffset\u00a00x24, Size 0x10: Mutex or reserved bytes\nOffset\u00a00x34, Size 0x78: C&C server address which is XOR-encrypted by key 0xFF. If the backdoor is intended to listen in on a speci\ufb01c port, this section will\nbe \ufb01lled with 0x00.\nOffset 0xAC, Size 0x02: Port\nOffset 0xAE, Size 0x5A: Reserved bytes\nTable: The function address table of the payload. The block is initially \ufb01lled with 0x00 and will be propagated during runtime.\nTable: The sizes of functions\nTable: The API address table.\u00a0The block is initially \ufb01lled with 0x00 and will be \ufb01lled with loaded API addresses during runtime.\nTable: The API hashes for dynamic API loading\nA list of DLL names and the number of APIs to be loaded\n\nAnti-memory scanning of shellcode payload\n\nFigure 3. The \ufb01rst-stage backdoor\u2019s con\ufb01guration structure\n\nIn order to avoid in-memory scanning during runtime, the payload encrypts all of the function blocks before executing the actual malicious routine. Afterwards,\nwhenever it needs to use a function, it will decrypt the function, execute it, and encrypt the function back again, as can be seen in Figure 4. If a function will not be\n\nhttps://blog.trendmicro.com/trendlabs-security-intelligence/waterbear-is-back-uses-api-hooking-to-evade-security-product-detection/\n\n3/9\n\n\f12/12/2019\n\nWaterbear is Back, Uses API Hooking to Evade Security Product Detection - TrendLabs Security Intelligence Blog\n\nused on the rest of the execution, it will be scrambled by another mess-up function, as illustrated in Figure 6. The mess-up function muddles up the bytes with\nrandom values and makes the input blocks unrecoverable. The purpose of this is to further avoid being detected by a certain cybersecurity solution.\n\nFigure 4. The decryption-execution-encryption \ufb02ow in the shellcode execution routine\n\nFigure 5. The function for the function block encryption and decryption\n\nSame Waterbear, different story\n\nFigure 6. The payload\u2019s mess-up function\n\nDuring our investigation, we found a peculiar incident that stands out from most of the Waterbear infections we\u2019ve previously seen. This time, the DLL loader loaded\ntwo payloads \u2013 the \ufb01rst payload performed functionalities we have not seen before: It injected codes into a speci\ufb01c security product to do API hooking in order to\nhide the backdoor from the product. Meanwhile, the second payload is a typical Waterbear \ufb01rst-stage backdoor.\n\nhttps://blog.trendmicro.com/trendlabs-security-intelligence/waterbear-is-back-uses-api-hooking-to-evade-security-product-detection/\n\n4/9\n\n\f12/12/2019\n\nWaterbear is Back, Uses API Hooking to Evade Security Product Detection - TrendLabs Security Intelligence Blog\n\nFigure 7. An unusual Waterbear infection chain\n\nBoth payloads were encrypted and stored on the victim\u2019s disk and were injected into the same service, which was, in this case, LanmanServer. We have observed that\nthe loader tried to read the payloads from the \ufb01les, decrypted them, and performed thread injections with the following conditions:\n\n1. If the \ufb01rst payload could not be found on the disk, the loader would be terminated without loading the second one.\n2. If the \ufb01rst payload was successfully decrypted and injected into the service, the second piece would also be loaded and injected regardless of what happened to\n\nthe \ufb01rst thread.\n\n3. In the \ufb01rst injected thread, if the necessary executable from the security product was not found, the thread would be terminated without performing other\n\nmalicious routines. Note that only the thread would be terminated, but the service would still be running.\n\nRegardless if the API hooking was performed or otherwise, the second backdoor would still be executed after having been successfully loaded.\n\nAPI hooking to evade detection\n\nIn order to hide the behaviors of the \ufb01rst-stage backdoor (which is the second payload), the \ufb01rst payload uses API hooking techniques to avoid being detected by a\nspeci\ufb01c security product and to make an\u00a0interference in the result of the function execution. It hooks two different APIs, namely \u201cZwOpenProcess\u201d and\n\u201cGetExtendedTcpTable\u201d, to hide its speci\ufb01c processes. The payload only modi\ufb01es the functions in the memory of the security product process, hence the original\nsystem DLL \ufb01les remain unchanged.\n\nThe payload is composed of a two-stage shellcode. The \ufb01rst-stage shellcode \ufb01nds a speci\ufb01c security product\u2019s process with a hardcoded name and injects the second-\nstage shellcode into \u00a0that process. The second-stage shellcode then performs API hooking inside the targeted process.\n\nHiding process identi\ufb01ers (PIDs)\n\nThe process identi\ufb01ers or PIDs to be hidden are stored in the shared memory \u201cGlobal\\<computer_name>.\u201d If the shared memory doesn\u2019t exist, it takes the PID\nembedded by the \ufb01rst-stage shellcode. In this case, the intention of the malicious code is to hide Waterbear\u2019s \u00a0backdoor activities from the security product.\nTherefore, the \ufb01rst-stage shellcode takes the PID of the Windows Service \u2014 which the \ufb01rst-stage shellcode and the succeeding backdoor both inject into \u2014 hides the\ntarget process, and embeds that PID into the second-stage shellcode.\n\nHooking \u201cZwOpenProcess\u201d in ntdll.dll\n\nFigure 8. Code that injects current PID into the second-stage shellcode\n\nThe purpose of hooking \u201cZwOpenProcess\u201d is to protect the speci\ufb01c process from being accessed by the security product. Whenever \u201cZwOpenProcess\u201d is called,\nthe injected code will \ufb01rst check if the opened process hits any PIDs in the protected process ID list. If yes, it modi\ufb01es the process ID, which should open on another\nWindows Service PID.\n\nFirst, it builds the hooked function and writes the function at the end of \u201cntdll.dll\u201d. This function includes two parts, as shown in Figure 9:\n\n1. The PID checking procedure. It recursively checks if the PID to be opened by \u201cZwOpenProcess\u201d is in the list of the protected process IDs. If yes, it replaces\n\nthe PID to be opened with another Windows Service PID that has been written by the Waterbear loader in the beginning.\n\n2. After the PID checking procedure, it executes the original \u201cZwOpenProcess\u201d and returns the result.\n\nhttps://blog.trendmicro.com/trendlabs-security-intelligence/waterbear-is-back-uses-api-hooking-to-evade-security-product-detection/\n\n5/9\n\n\u00a0\n\f12/12/2019\n\nWaterbear is Back, Uses API Hooking to Evade Security Product Detection - TrendLabs Security Intelligence Blog\n\nFigure 9. The function hook of \u201cZwOpenProcess\u201d to check and modify the output of the function\n\nSecondly, it writes \u201cpush <ADDRESS> ret\u201d at the beginning of the original \u201cZwOpenProcess\u201d address. Hence, when \u201cZwOpenProcess\u201d is called, the modi\ufb01ed\nversion of \u201cZwOpenProcess\u201d will be executed.\n\nThe API hooking on \u201cZwOpenProcess\u201d will only be triggered if \u201c%temp%\\KERNELBASE.dll\u201d exists on the host. It is possible that this check is designed\naccording to the nature of the security product it targets.\n\nFigure 10. \u201cZwOpenProcess\u201d after modi\ufb01cation\n\n\u201cGetExtendedTcpTable\u201d and\u00a0\u201cGetRTTAndHopCount\u201d hooks in iphlpapi.dll\n\nThe second part of API hooking hooks on \u201cGetExtendedTcpTable.\u201d \u201cGetExtendedTcpTable\u201d is used for retrieving a table that contains a list of TCP endpoints\navailable to the application, and it is frequently used in some network-related commands, such as netstat. The purpose of the hook is to remove TCP endpoint records\nof certain PIDs. In order to achieve that, it modi\ufb01es two functions: \u201cGetExtendedTcpTable\u201d and\u00a0\u201cGetRTTAndHopCount.\u201d The second function,\n\u201cGetRTTAndHopCount,\u201d acts as the place to put the injected hooking code.\n\n\u201cGetExtendedTcpTable\u201d only writes a jump to \u201cGetRTTAndHopCount\u201d in the beginning of the function. Only the \ufb01rst 5 bytes of the code of the API\n\u201cGetExtendedTcpTable\u201d are changed, as shown in Figure 11.\n\nThe rest of the routine is all placed in \u201cGetRTTAndHopCount.\u201d In the \ufb01rst part of the code, it pushes [\u201cGetRTTAndHopCount\u201d+0x3E] as the return address and\nthen executes the \ufb01rst four instructions of the original \u201cGetExtendedTcpTable\u201d function (which has already been replaced by the jump instruction in Figure 11).\nAfter that, it jumps to \u201cGetExtendedTcpTable\u201d to execute the function normally and to catch its return values. The code is shown in Figure 12.\n\nFigure 11. Only 5 bytes changed in the \u201cGetExtendedTcpTable\u201d\n\nFigure 12. The \ufb01rst part of injected code in \u201cGetRTTAndHopCount,\u201d which executes \u201cGetExtendedTcpTable\u201d and returns back to the next instruction\n\nAfter \u201cGetExtendedTcpTable\u201d is executed and the process returns back to the second part of the code, it iteratively checks every record in the returned Tcp table. If\nany record contains the PID Waterbear wants to hide, it will remove the corresponding record, modify the record number inside the table, and continue to check the\nsucceeding records. In the end, it returns the modi\ufb01ed table.\n\nhttps://blog.trendmicro.com/trendlabs-security-intelligence/waterbear-is-back-uses-api-hooking-to-evade-security-product-detection/\n\n6/9\n\n\f12/12/2019\n\nWaterbear is Back, Uses API Hooking to Evade Security Product Detection - TrendLabs Security Intelligence Blog\n\nFigure 13. The \ufb01rst part of injected code in \u201cGetRTTAndHopCount,\u201d which executes \u201cGetExtendedTcpTable\u201d and returns back to the next instruction\n\nRather than directly disabling these two functions, this method of using API hooking makes noticing malicious behaviors more dif\ufb01cult, especially since both\nfunctions still work and return results normally. Although in this case, the affected process is speci\ufb01ed in the \ufb01rst-stage shellcode, the API hooking logic is quite\ngeneric that the same piece of shellcode can be used to hook other vendors\u2019 products.\n\nConclusion\n\nThis is the \ufb01rst time we\u2019ve seen Waterbear attempting to hide its backdoor activities. By the hardcoded product name, we infer that the attackers are knowledgeable\nof the victims\u2019 environment and which security product(s) they use. The attackers might also be familiar with how security products gather information on their\nclients\u2019 endpoints and networks,\u00a0so that they know which APIs to hook. Since the API hooking shellcode adopts a generic approach, the similar code snippet might\nbe used to target other products in the future and make the activities of Waterbear harder to detect.\n\nTactic\n\nTechnique\n\nExecution through Module Load\n\nExecution\n\nExecution through API\n\nPersistence\n\nHooking\n\nPrivilege\nEscalation\n\nProcess Injection\n\nHooking\n\nDefense\nEvasion\n\nBinary Padding\n\nDisabling Security Tools\n\nID\n\nT1129\n\nT1106\n\nT1179\n\nT1055\n\nT1179\n\nT1009\n\nT1089\n\nDescription\n\nDynamically loads the DLLs\nthrough the shellcode\n\nDynamically loads the APIs\nthrough the shellcode\n\nHooks security product\u2019s\ncommonly used APIs\n\nInjects the decrypts payload\ninto svchost.exe process\n\nHooks security products\u2019\ncommonly used APIs\n\nAdds junk data to evade anti-\nvirus scan\nTargets a speci\ufb01c security\nproduct\u2019s process for injection\npurposes\n\nhttps://blog.trendmicro.com/trendlabs-security-intelligence/waterbear-is-back-uses-api-hooking-to-evade-security-product-detection/\n\n7/9\n\n\u00a0\n\u00a0\n\u00a0\n\u00a0\n\u00a0\n\u00a0\n\f12/12/2019\n\nWaterbear is Back, Uses API Hooking to Evade Security Product Detection - TrendLabs Security Intelligence Blog\n\nDeobfuscate/Decode Files or\nInformation\n\nExecution Guardrails\n\nDLL Side-Loading\n\nProcess Injection\n\nEx\ufb01ltration\n\nEx\ufb01ltration Over Command and\nControl Channel\n\nIndicators of Compromise (IoCs)\n\nT1140 Uses TROJ_WATERBEAR to\n\nT1480\n\nT1073\n\ndecrypt encrypted payload\nTargets speci\ufb01c software in the\nvictim\u2019s environment\n\nUses modi\ufb01ed legitimate DLL\nto load the malicious DLL\n\nT1055\n\nT1041\n\nInjects the decrypted payload\ninto svchost.exe process\nPossibly sends collected data to\nattackers via C&C channel\n\nSHA256\n\nDetection Name\n\n649675baef92381ffcdfa42e8959015e83c1ab1c7bbfd64635ce5f6f65efd651\nBKDR_WATERBEAR.ZTGF\n3909e837f3a96736947e387a84bb57e57974db9b77fb1d8fa5d808a89f9a401b TROJ_WATERBEAR.ZTGD\nfcfdd079b5861c0192e559c80e8f393b16ba419186066a21aab0294327ea9e58 TROJ_WATERBEAR.ZTGJ\nTROJ_WATERBEAR.ZTGH\n3f26a971e393d7f6ce7bf4416abdbfa1def843a0cf74d8b7bb841ca90f5c9ed9\nabb91dfd95d11a232375d6b5cdf94b0f7afb9683fb7af3e50bcecdb2bd6cb035\nTROJ_WATERBEAR.ZTGH\nbda6812c3bbba3c885584d234be353b0a2d1b1cbd29161deab0ef8814ac1e8e1 TROJ_WATERBEAR.ZTGI\n53402b662679f0bfd08de3abb064930af40ff6c9ec95469ce8489f65796e36c3\nTROJ_WATERBEAR.ZTGH\nf9f6bc637f59ef843bc939cb6be5000da5b9277b972904bf84586ea0a17a6000 TROJ_WATERBEAR.ZTGI\n3442c076c8824d5da065616063a6520ee1d9385d327779b5465292ac978dec26 BKDR_WATERBEAR.ZTGD\n7858171120792e5c98cfa75ccde7cba49e62a2aeb32ed62322aae0a80a50f1ea\nTROJ64_WATERBEAR.ZTGI\nacb2abc7fb44c2fdea0b65706d1e8b4c0bfb20e4bd4dcee5b95b346a60c6bd31 BKDR_WATERBEARENC.ZTGF\nb9f3a3b9452a396c3ba0ce4a644dd2b7f494905e820e7b1c6dca2fdcce069361 BKDR64_WATERBEAR.ZTGD\n7c0d2782a33debb65b488893705e71a001ea06c4eb4fe88571639ed71ac85cdd BKDR_WATERBEARENC.ZTGH\nc7c7b2270767aaa2d66018894a7425ba6192730b4fe2130d290cd46af5cc0b7b BKDR_WATERBEARENC.ZTGI\n7532fe7a16ba1db4d5e8d47de04b292d94882920cb672e89a48d07e77ddd0138 BKDR_WATERBEARENC.ZTGI\ndea5c564c9d961ccf2ed535139fbfca4f1727373504f2972ac92acfaf21da831\nBKDR_WATERBEARENC.ZTGI\n05d0ab2fbeb7e0ba7547afb013d307d32588704daac9c12002a690e5c1cde3a4 BKDR64_WATERBEARENC.ZTGJ\n39668008deb49a9b9a033fd01e0ea7c5243ad958afd82f79c1665fb73c7cfadf\n\nBKDR_WATERBEARENC.ZTGD\n\nLearn how to protect Enterprises, Small Businesses, and Home Users from ransomware:\n\nENTERPRISE\n\n\u00bb\n\nSMALL BUSINESS\n\n\u00bb\n\nHOME\n\n\u00bb\n\nTags: API HookingBlackTechWaterbear\n\n0 Comments\n\nTrendLabs\n\n\uf108\n\n Recommend\n\nt Tweet f Share\n\nLogin\ue6031\n\nSort by Best\n\nStart the discussion\u2026\n\nLOG IN WITH\n\nOR SIGN UP WITH DISQUS \n\n?\n\nName\n\nBe the \ufb01rst to comment.\n\n\u2709\n\nSubscribe\n\nd\n\nAdd Disqus to your siteAdd DisqusAdd\n\nFeatured Stories\n\nhttps://blog.trendmicro.com/trendlabs-security-intelligence/waterbear-is-back-uses-api-hooking-to-evade-security-product-detection/\n\n8/9\n\n\u00a0\n\u00a0\n\u00a0\n\u00a0\n\f12/12/2019\n\nWaterbear is Back, Uses API Hooking to Evade Security Product Detection - TrendLabs Security Intelligence Blog\n\nsystemd Vulnerability Leads to Denial of Service on Linux\nqkG Filecoder: Self-Replicating, Document-Encrypting Ransomware\nMitigating CVE-2017-5689, an Intel Management Engine Vulnerability\nA Closer Look at North Korea\u2019s Internet\nFrom Cybercrime to Cyberpropaganda\n\nSecurity Predictions for 2019\n\nOur security predictions for 2019 are based on our experts\u2019 analysis of the progress of current and emerging technologies, user behavior, and market trends, and\ntheir impact on the threat landscape. We have categorized them according to the main areas that are likely to be affected, given the sprawling nature of the\ntechnological and sociopolitical changes under consideration.\nRead our security predictions for 2019.\n\nBusiness Process Compromise\n\nAttackers are starting to invest in long-term operations that target speci\ufb01c processes enterprises rely on. They scout for vulnerable practices, susceptible\nsystems and operational loopholes that they can leverage or abuse. To learn more, read our Security 101: Business Process Compromise.\n\nRecent Posts\n\nWaterbear is Back, Uses API Hooking to Evade Security Product Detection\nDecember Patch Tuesday: Vulnerabilities in Windows components, RDP, and PowerPoint Get Fixes\nObfuscation Tools Found in the Capesand Exploit Kit Possibly Used in \u201cKurdishCoder\u201d Campaign\nMobile Cyberespionage Campaign Distributed Through CallerSpy Mounts Initial Phase of a Targeted Attack\nOperation ENDTRADE: Finding Multi-Stage Backdoors that TICK\n\nPopular Posts\n\nMac Backdoor Linked to Lazarus Targets Korean Users\n\nNew Magecart Attack Delivered Through Compromised Advertising Supply Chain\n\nSeptember Patch Tuesday Bears More Remote Desktop Vulnerability Fixes and Two Zero-Days\n\nMicrosoft November 2019 Patch Tuesday Reveals 74 Patches Before Major Windows Update\n\nBanking Trojan DRIDEX Uses Macros for Infection\n\nStay Updated\n\nEmail Subscription\nYour email here\n\nSubscribe\n\nHome and Home Of\ufb01ce\n|\nFor Business\n|\nSecurity Intelligence\n|\nAbout Trend Micro\n\nAsia Paci\ufb01c Region (APAC): Australia / New Zealand, \u4e2d\u56fd, \u2f47\u672c, \ub300\ud55c\ubbfc\uad6d, \u53f0\u7063\nLatin America Region (LAR): Brasil, M\u00e9xico\nNorth America Region (NABU): United States, Canada \nEurope, Middle East, & Africa Region (EMEA): France, Deutschland / \u00d6sterreich / Schweiz, Italia, \u0420\u043e\u0441\u0441\u0438\u044f, Espa\u00f1a, United Kingdom / Ireland\n\nPrivacy Statement\nLegal Policies\n\nCopyright \u00a9 2019 Trend Micro Incorporated. All rights reserved.\n\nhttps://blog.trendmicro.com/trendlabs-security-intelligence/waterbear-is-back-uses-api-hooking-to-evade-security-product-detection/\n\n9/9\n\n\f"], "URLs": ["https://blog.trendmicro.com/trendlabs-security-intelligence/waterbear-is-back-uses-api-hooking-to-evade-security-product-detection/"], "weight": 0.0}