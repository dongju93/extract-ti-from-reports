{"rule_id": 351, "name": "bookworm-trojan-a-model-of-modular-architecture", "description": "-", "references": [], "File_Names": ["ushata.dll", "Leader.dll", "thailandbbs.ddns", "HTTP.dll", "sgkey.data", "ushata.exe", "Resolver.dll", "Coder.dll", "KBLogger.dll", "gotdns.ch", "Loader.dll", "Network.dll", "WinINetwork.dll", "Mover.dll", "Digest.dll", "AES.dll"], "MD5_Hashes": ["5e4852c8e5ef3cbceb69a9bc3d554d6c", "f8c8c6683d6ca880293f7c1a78d7f8ce", "04d63e2a3da0a171e5c15d8e904387b9", "4389fc820d0edd96bac26fa0b7448aee", "5282b503b061eaa843c0bcda1c74b14f", "b030c619bb24804cbcc05065530fcf2e", "599b6e05a38329081b80a461b57cec37", "499ccc8d6d7c08e135a91928ccc2fd7a", "9df45e8d8619e234d0449daf2f617ba3", "0f41c853a2d522e326f2c30b4b951b04", "3e69c34298a8fd5169259a2fef506d63", "fcd68032c39cca3385c539ea38914735", "210816c8bde338bf206f13bb923327a1", "35755a6839f3c54e602d777cd11ef557", "ba1aea40182861e1d1de8c0c2ae78cb7", "de1595a7585219967a87a909f38acaa2", "0b4ad1bd093e0a2eb8968e308e900180", "cba74e507e9741740d251b1fb34a1874", "40f1b160b88ff98934017f3f1e7879a5", "74c293acdda0d2c3b5087763dae27ec6", "0d57d2bef1296be62a3e791bfad33bcd", "29df124f370752a87b3426dcad539ec6", "187cdb58fbc30046a35793818229c573", "87d71401e2b8978c2084eb9a1d59c172", "8ae2468d3f208d07fb47ebb1e0e297d7"], "SHA1_Hashes": [], "SHA256_Hashes": [], "Registry_Entries": ["HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Internet Explorer\\Registration\\ProductID\n\nThe decrypted contents of this new file contain a path to the following file:\n\n%AllUsersProfile%\\Application Data\\Microsoft\\Crypto\\RSA\\MachineKeys\\sgkey.data\n\nThe sgkey.data file contains the shellcode from readme.txt that loads the Bookworm modules,\n\nbut instead of being encrypted with the three byte XOR algorithm like readme.txt, sgkey.data is\n\nencrypted with RC4 using the \u201cProductID\u201d value as the key. The installation process finishes\n\nwith the creation of a service named \u201cMicrosoft Windows DeviceSync Service\u201d, which results in\n\nthe addition of registry keys listed in Figure 4, which will run Bookworm when the system starts.\n\nHKLM\\SYSTEM\\CurrentControlSet\\Services\\DeviceSync\\Type: 0x00000120\n\nHKLM\\SYSTEM\\CurrentControlSet\\Services\\DeviceSync\\Start: 0x00000002\n\nHKLM\\SYSTEM\\CurrentControlSet\\Services\\DeviceSync\\ErrorControl: 0x00000001\n\nHKLM\\SYSTEM\\CurrentControlSet\\Services\\DeviceSync\\ImagePath: \u201cC:\\Documents and\n\nSettings\\All Users\\Application Data\\Microsoft\\DeviceSync\\MsMpEng.exe\u201d\n\nHKLM\\SYSTEM\\CurrentControlSet\\Services\\DeviceSync\\DisplayName: \u201cMicrosoft Windows\n\nDeviceSync Service\u201d\n\nHKLM\\SYSTEM\\CurrentControlSet\\Services\\DeviceSync\\ObjectName: \u201cLocalSystem\u201d\n\nHKLM\\SYSTEM\\CurrentControlSet\\Services\\DeviceSync\\Description: \u201cAllows USB devices to\n\nbe hosted on this computer. If this service is stopped, any hosted USB devices will\n\nstop functioning and no additional hosted devices can be added. If this service is disabled, any\n\nservices that explicitly depend on it will fail to start.\u201d\n\nFigure 4 Registry Keys Resulting from the Creation of the Bookworm Service\n\nLeader is Bookworm\u2019s main module and controls all of the activities of the Trojan, but relies on\n\nthe additional DLLs to provide specific functionality. The developers of Bookworm use these\n\nmodules in a rather unique way, as the other embedded DLLs provide API functions for Leader\n\nto carry out its tasks. To load additional modules, Leader parses the buffer passed to it by the\n\nshellcode in readme.txt for the other DLLs, which exist in the following structure:\n\nstruct embedded_dll {\n\nDWORD dll_identifier;\n\nDWORD length_of_dll;\n\nchar[length_of_dll] embedded_dll;\n\n};\n\nTable 1 contains all of the embedded DLLs in each Bookworm sample, their ID numbers, and a\n\ndescription of the functionality of each DLL\u2019s API functions provided to Leader. It should be noted\n\nthat Bookworm does not write any of these DLLs to the filesystem, as the Trojan operates\n\nentirely in memory.\n\nName\n\nDLL ID #\n\nDescription\n\nLeader.dll\n\n0x5\n\nMain module. Communicates with the C2\n\nserver and other activities by interacting with\n\nother modules in this table.\n\nResolver.dll\n\nMover.dll\n\n0x1\n\n0x2\n\nUsed to resolve C2 server locations.\n\nMoves the Bookworm files from the RAR\n\narchive to a new folder and runs it from the new\n\nlocation. Only used on initial infection during\n\ninstallation.\n\n\fCoder.dll\n\n0xA\n\nUsed to carry out RC4 encryption and\n\nDigest.dll\n\nAES.dll\n\nNetwork.dll\n\n0xB\n\n0xC\n\n0xE\n\ndecryption, base64 encoding and decoding and\n\nthe generation of CRC32 hashes of data.\n\nUsed to generate MD5 hashes of data.\n\nUsed to encrypt and decrypt data using AES.\n\nSets the network interface into promiscuous\n\nmode and gathers network traffic for traffic\n\ndestined to the system to receive data from C2\n\nresponses. Also provides the ability to send\n\ndata to the C2 as well.\n\nHTTP.dll\n\n0x13\n\nUsed to create HTTP Requests to send to the\n\nC2.\n\nWinINetwork.dll\n\n0x17\n\nUsed to interact with the C2 server, specifically\n\nby sending HTTP GET and POST requests.\n\nKBLogger.dll\n\nN\\A\n\nKey logger that records keystrokes and the\n\ncontents saved to the clipboard.\n\nTable 1 Bookworm\u2019s Embedded Modules with their Corresponding Identification Number\n\nand a Brief Description\n\nLeader loads each DLL into memory and then resolves an exported function named\n\n\u201cProgramStartup\u201d within the loaded DLL. Leader then uses the \u201cdll_identifier\u201d (DLL ID # in Table\n\n1) value to determine the appropriate arguments to send to the DLL when calling the\n\nProgramStartup function. Leader then passes a pointer to a structure to each loaded DLL with\n\neach DLL receiving a different offset that it will set with addresses of its internal functions. The\n\npurpose of passing a structure to each DLL is to populate one large structure that allows Leader\n\nto call specific functions within each DLL, which is very similar conceptually to the import\n\naddress table of a portable executable. Figure 5 below visualizes this concept, showing Leader\n\ncalling example functions in the Bookworm modules to carry out various tasks.\n\nFigure 5 Visualization of Leader using other Bookworm Modules\u2019 API Functions to Carry\n\nout Tasks\n\nBy using this type of modular framework, the developers of Bookworm have made static\n\nanalysis of the Trojan quite challenging. To perform static analysis of Bookworm, an analyst\n\nmust recreate the structure used by Leader to store the API functions of each DLL and apply\n\nthem throughout the entire Trojan. Without performing this task, an analyst would be unable to\n\ndetermine which API function Leader calls within the supporting DLLs. For example, Figure 6\n\nbelow shows a code block within Leader that is responsible for encrypting a buffer using\n\nfunctions within the AES module; however, the red, blue, and green boxes show calls to\n\nfunctions based on an offset in a structure.\n\n\fFigure 6 Bookworm Calling API Functions using an Offset to its Structure\n\nAt first glance, an analyst would be unable to determine the purpose of the code block displayed\n\nin Figure 6, as the functions called are not readily apparent. By creating a structure and\n\npopulating it with the correct API functions however, an analyst can determine the API functions\n\ncalled in this code block. In Figure 7 below, the red, blue and green boxes show calls to three\n\nfunctions within the AES module that allow Leader to encrypt data using the AES algorithm.\n\nFigure 7 Applying Bookworm\u2019s API Structure Exposes the API Functions Called\n\nNot only does this modular approach require an analyst to create a structure, but it also takes\n\naway an analyst\u2019s ability to use cross references (XREFs) on the API functions within the\n\nsupporting modules. Using XREFs during static analysis is a common technique to quickly find\n\nwhere functions of interest are called. An analyst cannot use this method to find where Leader is\n\ncalling specific Bookworm APIs because the functions are not called directly; rather they are\n\ncalled based on the structure offset. We are unsure if the developers of Bookworm created this\n\nas an analysis hurdle, but it certainly contributes to anti-analysis tactics.\n\nAlthough the developers of Bookworm have included only keylogging functionality in Bookworm\n\nas a core ability, as suggested in Table 1, several of the embedded DLLs provide Leader with\n\ncryptographic and hashing functions, while others support Leader\u2019s ability to communicate with\n\nits C2 server. The developers designed Bookworm to be a modular Trojan not limited to just the\n\ninitial architecture of the Trojan, as Bookworm can also load additional modules provided by the\n\nC2 server. The ability to load additional modules from the C2 extends the capabilities of the\n\nTrojan to accommodate any activities the threat actors need to carry out on the compromised\n\nsystem.\n\nThe KBLogger.dll module, which we will refer to as KBLogger, provides key logging and\n\nclipboard grabbing functionality and is the only Bookworm module that does not provide Leader\n\nwith API functions. Instead, Leader creates a new process \u201cC:\\WINDOWS\\System32\\dllhost.exe\n\n\u2013user\u201d that it injects itself into and uses to execute the KBLogger functionality.\n\nKBLogger runs on its own by creating a new window called \u201cDolefulClass<username><PID>\u201d,\n\nwhich is hidden so it is invisible to the user. The new window executes code that will create the\n\nfollowing folder to store files that contain logged keystrokes and stolen clipboard contents:\n\n%AllUsersProfile%\\Application Data\\Microsoft\\Crypto\\RSA\\MachineKeys\\<crc32 hash>bk\n\nKBLogger captures keystrokes typed by the user and saves them to a file in the folder above.\n\n\fKBLogger also specifically monitors for the keystroke combinations \u201cControl + C\u201d, \u201cControl + V\u201d\n\nand \u201cControl + X\u201d that it uses as triggers to copy the contents of the clipboard to a file. The\n\nkeystrokes and clipboard contents are encrypted before KBlogger saves them to the file system\n\nusing the RC4 algorithm using a key derived from the value at the following registry key:\n\nHKLM\\SOFTWARE\\Microsoft\\Internet Explorer\\Registration\\ProductID\n\nKBLogger will generate the key for the RC4 algorithm by using XOR and an eight-byte key\n\n(specifically 0x6E, 0x30, 0xD0, 0x30, 0xB9, 0x30, 0xB1, 0x30) on the value of the above\n\nregistry key. KBLogger creates files with the naming format \u201c<username XOR with 2 byte key\n\n0x5878>_<seconds since EPOCH>\u201d to store the captured keystrokes and clipboard. For\n\nexample, on November 3, 2015, we saw the following file created during by KBLogger on an\n\nanalysis system with a username of \u201cadministrator\u201d:\n\n191c351136112b0c2a192c172a_56391E90\n\nBookworm uses a state machine to keep track of and carry out communications between the\n\ncompromised system and the C2 server. Also, Bookworm uses a combination of encryption and\n\ncompression algorithms to obfuscate the traffic between the system and C2 server. We have\n\nseen the following encryption and compression methods used at various stages and in differing\n\ncombinations in the C2 communications:\n\nRC4\n\nAES\n\nXOR with 0x5a\n\nLZO\n\nBookworm first creates an HTTP request that acts as a network beacon to notify the C2 of the\n\ncompromised system. The initial network beacon is either an HTTP GET or POST request,\n\nwhich varies between Bookworm samples. Unit 42 analyzed the contents of a beacon seen in\n\nFigure 8, which was sent to a URL that follows a structure of \u201chttp://<c2 server>:<port>/0<crc32\n\nhash of tick count><tick count><encrypted data>\u201d. The encrypted data in the URL is a 32\n\ncharacter string (16 hexadecimal bytes) created by RC4 and AES encrypting an empty data\n\nbuffer using the tick count and crc32 hash of the tick count as a key.\n\nFigure 8 Initial C2 Beacon from Bookworm sample 8ae2468d3f208d07fb47ebb1e0e297d7\n\nSubsequent HTTP POST requests from Bookworm to the C2 server include campaign identifier\n\nand system uptime. The data in the HTTP POST has a structure of \u201c\\x03\\x04<campaign\n\ncode>\\x00<system uptime>\u201d. Leader then compresses this string using the LZO compression\n\nalgorithm and compares the compressed length to the original string length. Leader uses the\n\nshorter of the two strings and appends it to a DWORD that is the size of the data and encrypts\n\nthe combined string using AES with a key of \u201c0123456789\u201d and XOR with a key of 0x5a. We\n\nbelieve the threat actors use the data in these POST requests to map the compromised system\n\nto the appropriate campaign and to filter out analysis systems. In our follow-up blog we will\n\nfurther discuss the campaign codes identified in our analysis.\n\nThe threat actors also deliver additional modules to Bookworm via C2 communications. To load\n\nadditional modules into Bookworm, Leader parses C2 responses for data that have the following\n\nstructure:\n\n<MD5 of cleartext of module><encrypted module>\n\nLeader skips the first 16 bytes and RC4 decrypts the remaining data with the key \u201c0123456789\u201d.\n\nIt then computes the MD5 hash of the resulting cleartext and checks this hash with the MD5 in\n\nthe first 16 bytes of the C2 response data to see if it is the same. If the MD5 hashes match, then\n\nthe code will carry out further checks on the decrypted data to determine if the data is a new\n\nDLL for Leader to load as an additional module. At this time, Unit 42 has not seen a Bookworm\n\nC2 server provide additional modules via network communications. By performing static\n\nanalysis on Leader.dll, we know that Leader will load the additional modules and attempt to call\n\n\u201cProgramStartup\u201d and \u201cQueryBuffer\u201d functions exported by the DLLs.\n\nWhile we did not discuss the surrounding attacks using Bookworm in detail, we have observed\n\nthreat actors deploying Bookworm primarily in attacks on targets in Thailand. The developers of\n\nBookworm have gone to great lengths to create a modular framework that is very flexible\n\nthrough its ability to run additional modules directly from its C2 server. Not only is this tool highly\n\n\fcapable, but it also requires a very high level of effort to analyze due to its modular architecture\n\nand its use of API functions within the additional modules. We believe that it is likely threat\n\nactors will continue development Bookworm, and will continue to use it for the foreseeable\n\nfuture.\n\nsgkey.data\n\nbkmail.blogdns[.]com\n\ndebain.servehttp[.]com\n\nlinuxdns.sytes[.]net\n\nnews.nhknews[.]hk\n\nsswmail.gotdns[.]com\n\nsswwmail.gotdns[.]com\n\nsysnc.sytes[.]net\n\nsysteminfothai[.]gotdns.ch\n\nthailandbbs.ddns[.]net\n\nubuntudns.sytes[.]net\n\nweb12.nhknews[.]hk\n\n0f41c853a2d522e326f2c30b4b951b04\n\n8ae2468d3f208d07fb47ebb1e0e297d7\n\n35755a6839f3c54e602d777cd11ef557\n\n87d71401e2b8978c2084eb9a1d59c172\n\n599b6e05a38329081b80a461b57cec37\n\nba1aea40182861e1d1de8c0c2ae78cb7\n\nde1595a7585219967a87a909f38acaa2\n\nf8c8c6683d6ca880293f7c1a78d7f8ce\n\n0b4ad1bd093e0a2eb8968e308e900180\n\ncba74e507e9741740d251b1fb34a1874\n\nfcd68032c39cca3385c539ea38914735\n\n3e69c34298a8fd5169259a2fef506d63\n\n04d63e2a3da0a171e5c15d8e904387b9\n\n0d57d2bef1296be62a3e791bfad33bcd\n\n4389fc820d0edd96bac26fa0b7448aee\n\n74c293acdda0d2c3b5087763dae27ec6\n\nb030c619bb24804cbcc05065530fcf2e\n\n29df124f370752a87b3426dcad539ec6\n\n9df45e8d8619e234d0449daf2f617ba3\n\n40f1b160b88ff98934017f3f1e7879a5\n\n210816c8bde338bf206f13bb923327a1\n\n187cdb58fbc30046a35793818229c573\n\n0b4ad1bd093e0a2eb8968e308e900180\n\n499ccc8d6d7c08e135a91928ccc2fd7a\n\n5e4852c8e5ef3cbceb69a9bc3d554d6c\n\n5282b503b061eaa843c0bcda1c74b14f\n\n\fNovember 10, 2015 4:34 PM\nKaspersky and Microsoft Security Products Abused to Install Spying Trojan | Wolf\nHalton, Open-Source Security\n\nNovember 11, 2015 5:37 AM\nAttackers Abuse Security Products to Install "], "URLs": ["http://<c2"], "weight": 0.0}