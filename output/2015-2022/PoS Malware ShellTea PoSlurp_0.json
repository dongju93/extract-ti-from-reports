{"rule_id": 992, "name": "PoS Malware ShellTea PoSlurp_0", "description": "-", "references": [], "File_Names": ["inp.read", "menoograskilllev.net", "TARGET2.exe", "zeroaccess_indepth.pdf", "make_sc_hash_db.py", "l.nil", "neofilgestunin.org", "crypted.map", "ROOT9B.COM", "verfgainling.net", "vortexclothings.biz", "straubeoldscles.org", "asojinoviesder.org", "unkerdubsonics.org", "vseflijkoindex.net", "targets.txt", "koolLondon.com", "TARGET1.EXE", "olohvikoend.org", "plain.pack", "popskentown.com", "decrypt.rb"], "MD5_Hashes": ["24b9b25f3b0b06a6939881e68d0bd2d0"], "SHA1_Hashes": [], "SHA256_Hashes": [], "Registry_Entries": ["HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings) and can communicate through proxies \n\nvia the CONNECT method as well. The implant\u2019s protocol uses the XTEA encryption algorithm in CBC mode.\n\nThe  implant  developers  have  a  distinct  preference  for  using  low-level  native  API  functions,  presumably  to \n\navoid detection by standard analysis and HIPS tools. They also make extensive use of CRC32 by calling the \n\nundocumented RtlComputeCrc32 function. This function is uncommon, but was used most prominently by the \nZeroAccess rootkit4 and the Andromeda malware5, although neither in the same manner as is found in \nour sample. \n\nFor example, the implant applies CRC32 to the computer and username and XORs with the SID subauthority \n\nvalues  taken  directly  from  the  SID  structure  to  assemble  a  mutex  name.  It  uniquely  identifies  an  implant \n\nand prevents duplicate infection against the same host under the same user account. This is likely done to \n\ndifferentiate hosts for tasking. \n\nExcerpt from ShellTea\u2019s mutex name derivation\n\n4http://www.symantec.com/content/en/us/enterprise/media/security_response/whitepapers/zeroaccess_indepth.pdf\n5https://blog.avast.com/andromeda-under-the-microscope\n\n13\n\n\fThe  implant  injects  its  code  into  explorer.exe.  First,  it  finds  the  process  ID.  Second,  it  uses  the  low-level \n\nRtlAdjustPrivilege call with the ID of the SE_DEBUG access right to enable the right to inject into nearly any \n\nprocess. Third, it opens the process, allocates memory in the process, copies its code into the allocated space, \n\nand uses the low level RtlCreateUserThread API to create a thread in the target process that will start executing \n\nits code. It then completes the process injection. It can find explorer by finding the process ID owning the shell's \n\ndesktop window by comparing process names or by using GetShellWindow. This is a function to return a handle \n\nto the Windows desktop which would be owned by explorer.exe.\n\nIn addition to the API obfuscation, the implant uses extensive string obfuscation. It creates most strings on the \n\nstack directly before use, character by character, by adding and subtracting various values from a fixed start \n\nbyte. Fortunately, a good decompiler will see through these. Below is a before-and-after comparison of the code \n\nthat creates the format string used for the implant\u2019s mutex:\n\nShellTea mutex format string\n\n14                           \n\n\fThe  implant  is  built  in  a  modular  manner  and  implements  several  capabilities. The  command  dispatcher  is \n\nshown below:\n\nShellTea command dispatcher\n\nIt has built-in routines to:\n\n\u2022  Drop an executable in a temporary directory, run it, and queue it for deletion at next reboot. It does \n\nso by using the Windows MoveFileEx API with the MOVEFILE_DELAY_UNTIL_REBOOT flag. Internally, \n\nthis  API  writes  to  the  PendingFileRenameOperations  value  of  the  registry  key  HKLM\\SYSTEM\\\n\nCurrentControlSet\\Control\\Session Manager.\n\n\u2022  Drop a DLL in a temporary directory and to load it, queuing it for deletion at next reboot via the \n\nsame mechanism.\n\n\u2022  Load an extension DLL directly into memory. It includes a separate routine that will finish mapping the \n\nDLL into memory and link up its imports without touching disk. \n\n\u2022  Run an operator-provided PowerShell command and receive results back. \n\n\u2022  Run raw shellcode directly in memory.\n\n\u2022  Install persistence by writing to the current user\u2019s Run key in the registry.\n\n15\n\n\fThe  implant  implements  sandbox  and  analysis  detection  with  numerous  techniques  reminiscent  of  the \n\nanalyzed PowerSniff variant. It has improvements in algorithms used, number of analysis processes detected, \n\nand employs the just-in-time API function hash resolution:\n\n\u2022  Querying the SystemFirmwareTableInformation from the system and looking for common hypervisors.\n\n\u2022  Obtaining the name of the system volume, hashing it, and comparing to a known hypervisor hash. In \n\nthis case, in contrast with our PowerSniff variant, ShellTea uses SHA1 as a hashing algorithm.\n\n\u2022  Enumerating  processes  with  a  low-level  API  (querying  SystemProcessInformation),  computing  a \n\nCRC32  checksum  of  the  upper-cased  version  of  process  names  and  comparing  against  a  table  of \n\nknown monitoring or analysis processes. This includes the default process names of Process Monitor, \n\nWireshark, and IDA. Again, this uses a new checksum algorithm.\n\nShellTea\u2019s process name CRC32 comparison\n\n16                           \n\n\fOnce again, as in the PowerSniff variant, it appears the malware developers made the same mistake. There \n\nare now 27 CRC32s to check against in the array, but the loop comparing the process name CRC32 to the list \n\nof hashes runs 108 times. It reads off the end of the array and into other data. This is most likely because the \n\nmalware developers wrote a loop that runs once for each byte in the checksum array instead of once for each \n\nchecksum (each checksum takes 4 bytes.)\n\nWhen the malware exits, it cleans itself up from memory using a clever technique. The exit function replaces \n\nits own return address with the address of RtlExitUserThread, then sets up the arguments for the VirtualFree \n\nfunction to free its own code and jumps directly to VirtualFree. This function deallocates all the binary\u2019s memory. \n\nThen, when the Windows API function returns, rather than returning to the implant code (which no longer exists \n\nin memory), it returns directly to the RtlExitUserThread function. This kills the thread and cleans up nearly all \n\ntraces of the malware from the injected process.\n\nAt this point, the adversaries have a foothold which they can use to explore the network environment further. \n\nroot9B observed the use of  common lateral movement techniques, such as dumping passwords, password \n\nhashes,  and  Kerberos  tickets  with  tools  like mimikatz  or  similar.  We also  observed the adversaries  stealing \n\ntokens, then using those credentials or creating forged Kerberos tickets (\u201cGolden Tickets\u201d) to maneuver laterally \n\nand  gain  access  to  network  servers  on  the  PoS  network  which  would  become  the  staging  points  for  the \n\nremainder of the attack.\n\nAfter obtaining the appropriate access to a server, they use that server to conduct basic network discovery to \n\nlocate PoS endpoints and create target lists stored in flat text files. Then they have been observed to launch \n\nshell commands, including wmic.exe, to push the PoS software, which we dubbed PoSlurp, to the PoS machines \n\nto launch it. Upon successful collection and exfil of payment card data using PoSlurp, the adversaries then \n\nclean-up after themselves to eliminate on-disk artifacts.\n\nPOSLURP MALWARE\n\nPoSlurp is a highly-obfuscated malicious RAM scraper that gets remotely deployed to PoS systems and can be \n\nlaunched via local or remote commands. \n\nThe file can be launched in any number of ways, but root9B observed it with both local and remote execution \n\nwith command-line arguments matching the following pattern: \n\nLocal Execution:\n\n[PoSlurp_filename].exe\tTARGET1.EXE#TARGET2.exe*1234*winlogon.exe\n\nRemote Execution: \n\nThis  command  uses  the  file  targets.txt  as  target  list  to  direct  the  execution  of  PoSlurp  to  specific  PoS \nend-points.\n\n17\n\n\fwmic\t\t/node:", "HKCU\\Software, one of which is reproduced below. This registry value \n\nheld a PowerShell command that was loaded and invoked in memory by a separate PowerShell launcher. We \n\nhave reproduced the registry command below, sanitized and formatted slightly for clarity. It acts as a stager to \n\nload and execute a shellcode-style implant into memory. It does so by first loading up a binary registry value \n\nunder the same key with Get-ItemProperty into variable $s.\n\n$s=(Get-ItemProperty\t-Path\tHKCU:Software\\Random_Generated_RegistryName\t\n\n\u2013Name\tRandom_KeyName).Random_KeyName_;\t\n\n$l=$s.Length;\n\nNext  it  uses  Add-Type  to  enable  the  PowerShell  script  to  directly  call  the  Win32  functions  VirtualAlloc, \n\nCreateThread, and WaitForSingleObject:\n\n$c=", "HKLM\\\n\nSystem\\CurrentControlSet\\Control\\Session Manager\\AppCertDlls"], "URLs": ["https://docs.microsoft.com/en-us/windows-server/identity/securing-privileged-access/", "https://blog.avast.com/andromeda-under-the-microscope", "https://researchcenter.paloaltonetworks.com/2016/03/powersniff-malware-used-in-macro-based-attacks/", "https://github.com/mandiant/Reversing/blob/master/shellcode_hashes/make_sc_hash_db.py", "https://blogs.technet.", "http://koolLondon.com/)", "http://www.symantec.com/content/en/us/enterprise/media/security_response/whitepapers/zeroaccess_indepth.pdf", "http://blog.trendmicro.com/trendlabs-security-intelligence/angler-exploit-kit-used-to-find-and-infect-pos-systems/", "https://gist.github.com/"], "weight": 0.0}