{"rule_id": 794, "name": "fireeye.com-Highly Evasive Attacker Leverages SolarWinds Supply Chain to Compromise Multiple Global Victims With ", "description": "-", "references": [], "File_Names": ["Hotfix5.msp", "BusinessLayer.dll", "api.eu", "NetSetupSvc.dll", "gracious_truth.jpg", "backdoor.html", "Orion.Core", "BusinessLayerHostx64.exe", "api.us", "netsetupsvc.dll", "businesslayerhost.exe", "BusinessLayerHost.exe", "solarwinds.com"], "MD5_Hashes": ["02af7cec58b9a5da1c542b5a32151ba1", "b91ce2fa41029f6955bff20079468448"], "SHA1_Hashes": [], "SHA256_Hashes": [], "Registry_Entries": ["HKU\\SOFTWARE\\Microsoft\\CTF exists,\ndecodes an embedded payload using a custom rolling XOR algorithm and manually loads into memory an embedded\npayload using a custom PE-like file format. TEARDROP does not have code overlap with any previously seen malware.\nWe believe that this was used to execute a customized Cobalt Strike BEACON.\n\nMitigation: FireEye has provided two Yara rules to detect TEARDROP available on our  GitHub. Defenders should look\nfor the following alerts from FireEye HX: MalwareGuard and WindowsDefender:\n\nProcess Information\n\nfile_operation_closed\nfile-path*: \u201cc:\\\\windows\\\\syswow64\\\\netsetupsvc.dll\nactor-process:\npid: 17900\n\nWindow\u2019s defender Exploit Guard log entries: (Microsoft-Windows-Security-Mitigations/KernelMode event ID 12)       \n\nProcess\u201d\\Device\\HarddiskVolume2\\Windows\\System32\\svchost.exe\u201d (PID XXXXX) would have been blocked from\nloading the non-Microsoft-signed binary\n\u2018\\Windows\\SysWOW64\\NetSetupSvc.dll\u2019\n\nAttacker Hostnames Match Victim Environment\n\nThe actor sets the hostnames on their command and control infrastructure to match a legitimate hostname found\nwithin the victim\u2019s environment. This allows the adversary to blend into the environment, avoid suspicion, and evade\ndetection.\n\nDetection Opportunity\n\nThe attacker infrastructure leaks its configured hostname in RDP SSL certificates, which is identifiable in internet-wide\nscan data. This presents a detection opportunity for defenders -- querying internet-wide scan data sources for an\norganization\u2019s hostnames can uncover malicious IP addresses that may be masquerading as the organization. (Note: IP\nScan history often shows IPs switching between default (WIN-*) hostnames and victim\u2019s hostnames) Cross-\nreferencing the list of IPs identified in internet scan data with remote access logs may identify evidence of this actor in\nan environment. There is likely to be a single account per IP address.\n\nIP Addresses located in Victim\u2019s Country\n\nThe attacker\u2019s choice of IP addresses was also optimized to evade detection. The attacker primarily used only IP\naddresses originating from the same country as the victim, leveraging Virtual Private Servers.\n\nDetection Opportunity\n\nThis also presents some detection opportunities, as geolocating IP addresses used for remote access may show an\nimpossible rate of travel if a compromised account is being used by the legitimate user and the attacker from disparate\nIP addresses. The attacker used multiple IP addresses per VPS provider, so once a malicious login from an unusual\nASN is identified, looking at all logins from that ASN can help detect additional malicious activity. This can be done\nalongside baselining and normalization of ASN\u2019s used for legitimate remote access to help identify suspicious activity.\n\nLateral Movement Using Different Credentials\n\n3/9\n\n   \n\fOnce the attacker gained access to the network with compromised credentials, they moved laterally using multiple\ndifferent credentials. The credentials used for lateral movement were always different from those used for remote\naccess.\n\nDetection Opportunity\n\nOrganizations can use HX\u2019s LogonTracker module to graph all logon activity and analyze systems displaying a one-to-\nmany relationship between source systems and accounts. This will uncover any single system authenticating to\nmultiple systems with multiple accounts, a relatively uncommon occurrence during normal business operations.\n\nTemporary File Replacement and Temporary Task Modification\n\nThe attacker used a temporary file replacement technique to remotely execute utilities: they replaced a legitimate\nutility with theirs, executed their payload, and then restored the legitimate original file. They similarly manipulated\nscheduled tasks by updating an existing legitimate task to execute their tools and then returning the scheduled task to\nits original configuration. They routinely removed their tools, including removing backdoors once legitimate remote\naccess was achieved.\n\nDetection Opportunity\n\nDefenders can examine logs for SMB sessions that show access to legitimate directories and follow a delete-create-\nexecute-delete-create pattern in a short amount of time. Additionally, defenders can monitor existing scheduled tasks\nfor temporary updates, using frequency analysis to identify anomalous modification of tasks. Tasks can also be\nmonitored to watch for legitimate Windows tasks executing new or unknown binaries.\n\nThis campaign\u2019s post compromise activity was conducted with a high regard for operational security, in many cases\nleveraging dedicated infrastructure per intrusion. This is some of the best operational security that FireEye has\nobserved in a cyber attack, focusing on evasion and leveraging inherent trust. However, it can be detected through\npersistent defense.\n\nIn-Depth Malware Analysis\n\nSolarWinds.Orion.Core.BusinessLayer.dll (b91ce2fa41029f6955bff20079468448) is a SolarWinds-signed plugin\ncomponent of the Orion software framework that contains an obfuscated backdoor which communicates via HTTP to\nthird party servers. After an initial dormant period of up to two weeks, it retrieves and executes commands, called\n\u201cJobs\u201d, that include the ability to transfer and execute files, profile the system, and disable system services. The\nbackdoor\u2019s behavior and network protocol blend in with legitimate SolarWinds activity, such as by masquerading as\nthe Orion Improvement Program (OIP) protocol and storing reconnaissance results within plugin configuration files.\nThe backdoor uses multiple blocklists to identify forensic and anti-virus tools via processes, services, and drivers.\n\nUnique Capabilities\n\nSubdomain DomainName Generation Algorithm (DGA) is performed to vary DNS requests\n\nCNAME responses point to the C2 domain for the malware to connect to.\nThe IP block of A record responses controls malware behavior\n\nCommand and control traffic masquerades as the legitimate Orion Improvement Program\nCode hides in plain site by using fake variable names and tying into legitimate components\n\nDelivery and Installation\n\nAuthorized system administrators fetch and install updates to SolarWinds Orion via packages distributed by\nSolarWinds\u2019s website. The update package CORE-2019.4.5220.20574-SolarWinds-Core-v2019.4.5220-Hotfix5.msp\n(02af7cec58b9a5da1c542b5a32151ba1) contains the SolarWinds.Orion.Core.BusinessLayer.dll described in this report.\nAfter installation, the Orion software framework executes the .NET program SolarWinds.BusinessLayerHost.exe to\nload plugins, including SolarWinds.Orion.Core.BusinessLayer.dll. This plugin contains many legitimate namespaces,\nclasses, and routines that implement functionality within the Orion framework. Hidden in plain sight, the class\nSolarWinds.Orion.Core.BusinessLayer.OrionImprovementBusinessLayer implements an HTTP-based backdoor. Code\nwithin the logically unrelated routine\nSolarWinds.Orion.Core.BusinessLayer.BackgroundInventory.InventoryManager.RefreshInternal invokes the backdoor\ncode when the Inventory Manager plugin is loaded.\n\nSolarWinds.Orion.Core.BusinessLayer.dll is signed by SolarWinds, using the certificate with serial number\n0f:e9:73:75:20:22:a6:06:ad:f2:a3:6e:34:5d:c0:ed. The file was signed on March 24, 2020.\n\n4/9\n\n\fInitialization\n\nOn execution of the malicious SolarWinds.Orion.Core.BusinessLayer.OrionImprovementBusinessLayer.Initialize\nmethod the sample verifies that its lower case process name hashes to the value 17291806236368054941. This hash\nvalue is calculated as the standard FNV-1A 64-bit hash with an additional XOR by 6605813339339102567 after\ncomputing the FNV-1A. This hash matches a process named businesslayerhost.exe.\n\nThe sample only executes if the filesystem write time of the assembly is at least 12 to 14 days prior to the current time;\nthe exact threshold is selected randomly from an interval. The sample continues to check this time threshold as it is\nrun by a legitimate recurring background task. Once the threshold is met, the sample creates the named pipe\n583da945-62af-10e8-4902-a8f205c72b2e to act as a guard that only one instance is running before reading\nSolarWinds.Orion.Core.BusinessLayer.dll.config from disk and retrieving the XML field appSettings. The appSettings\nfields\u2019 keys are legitimate values that the malicious logic re-purposes as a persistent configuration. The key\nReportWatcherRetry must be any value other than 3 for the sample to continue execution.\n\nThe sample checks that the machine is domain joined and retrieves the domain name before execution continues. A\nuserID is generated by computing the MD5 of all network interface MAC addresses that are up and not loopback\ndevices, the domain name, and the registry value\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography\\MachineGuid. The userID is encoded via a custom\nXOR scheme after the MD5 is calculated. The ReportWatcherPostpone key of appSettings is then read from\nSolarWinds.Orion.Core.BusinessLayer.dll.config to retrieve the initial, legitimate value. This operation is performed as\nthe sample later bit packs flags into this field and the initial value must be known in order to read out the bit flags. The\nsample then invokes the method Update which is the core event loop of the sample.\n\nDGA and Blocklists\n\nThe backdoor determines its C2 server using a Domain Generation Algorithm (DGA) to construct and resolve a\nsubdomain of avsvmcloud[.]com. The Update method is responsible for initializing cryptographic helpers for the\ngeneration of these random C2 subdomains. These subdomains are concatenated with one of the following to create\nthe hostname to resolve:\n\n.appsync-api.eu-west-1[.]avsvmcloud[.]com\n.appsync-api.us-west-2[.]avsvmcloud[.]com\n.appsync-api.us-east-1[.]avsvmcloud[.]com\n.appsync-api.us-east-2[.]avsvmcloud[.]com\n\nProcess name, service name, and driver path listings are obtained, and each value is hashed via the FNV-1a + XOR\nalgorithm as described previously and checked against hardcoded blocklists. Some of these hashes have been brute\nforce reversed as part of this analysis, showing that these routines are scanning for analysis tools and antivirus engine\ncomponents. If a blocklisted process is found the Update routine exits and the sample will continue to try executing the\nroutine until the blocklist passes. Blocklisted services are stopped by setting their\nHKLM\\SYSTEM\\CurrentControlSet\\services\\<service_name>\\Start registry entries to value 4 for disabled. Some\nentries in the service list if found on the system may affect the DGA algorithms behavior in terms of the values\ngenerated. The list of stopped services is then bit-packed into the ReportWatcherPostpone key of the appSettings entry\nfor the samples\u2019 config file. If any service was transitioned to disabled the Update method exits and retries later. The\nsample retrieves a driver listing via the WMI query Select * From Win32_SystemDriver. If any blocklisted driver is\nseen the Update method exits and retries. If all blocklist tests pass, the sample tries to resolve api.solarwinds.com to\ntest the network for connectivity.\n\nNetwork Command and Control (C2)\n\nIf all blocklist and connectivity checks pass, the sample starts generating domains in a while loop via its DGA. The\nsample will delay for random intervals between the generation of domains; this interval may be any random value\nfrom the ranges 1 to 3 minutes, 30 to 120 minutes, or on error conditions up to 420 to 540 minutes (9 hours). The DNS\nA record of generated domains is checked against a hardcoded list of IP address blocks which control the malware\u2019s\nbehavior. Records within the following ranges will terminate the malware and update the configuration key\nReportWatcherRetry to a value that prevents further execution:\n\n10.0.0.0/8\n172.16.0.0/12\n192.168.0.0/16\n224.0.0.0/3\n\n5/9\n\n\ffc00:: - fe00::\nfec0:: - ffc0::\nff00:: - ff00::\n20.140.0.0/15\n96.31.172.0/24\n131.228.12.0/22\n144.86.226.0/24\n\nOnce a domain has been successfully retrieved in a CNAME DNS response the sample will spawn a new thread of\nexecution invoking the method HttpHelper.Initialize which is responsible for all C2 communications and dispatching.\nThe HTTP thread begins by delaying for a configurable amount of time that is controlled by the SetTime command.\nThe HTTP thread will delay for a minimum of 1 minute between callouts. The malware uses HTTP GET or HEAD\nrequests when data is requested and HTTP PUT or HTTP POST requests when C2 output data is being sent to the\nserver. The PUT method is used when the payload is smaller than 10000 bytes; otherwise the POST method is used.\nThe If-None-Match HTTP header holds an XOR encoded representation of the userID calculated earlier, with a\nrandom array of bytes appended that is of the same length.\n\nA JSON payload is present for all HTTP POST and PUT requests and contains the keys \u201cuserId\u201d, \u201csessionId\u201d, and\n\u201csteps\u201d. The \u201csteps\u201d field contains a list of objects with the following keys: \u201cTimestamp\u201d, \u201cIndex\u201d, \u201cEventType\u201d,\n\u201cEventName\u201d, \u201cDurationMs\u201d, \u201cSucceeded\u201d, and \u201cMessage\u201d. The JSON key \u201cEventType\u201d is hardcoded to the value\n\u201cOrion\u201d, and the \u201cEventName\u201d is hardcoded to \u201cEventManager\u201d. Malware response messages to send to the server are\nDEFLATE compressed and single-byte-XOR encoded, then split among the \u201cMessage\u201d fields in the \u201csteps\u201d array. Each\n\u201cMessage\u201d value is Base64 encoded separately. Not all objects in the \u201csteps\u201d array contribute to the malware message \u2013\nthe integer in the \u201cTimestamp\u201d field must have the 0x2 bit set to indicate that the contents of the \u201cMessage\u201d field are\nused in the malware message. Step objects whose bit 0x2 is clear in the Timestamp field contain random data and are\ndiscarded when assembling the malware response.\n\nSteganography\n\nIn observed traffic these HTTP response bodies attempt to appear like benign XML related to .NET assemblies, but\ncommand data is actually spread across the many GUID and HEX strings present. Commands are extracted from\nHTTP response bodies by searching for HEX strings using the following regular expression: "], "URLs": [], "weight": 0.0}